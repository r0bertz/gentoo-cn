<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/guide.xsl" ?>
<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/tw/portage-manual.xml,v 1.1 2004/05/24 22:50:10 bennyc Exp $ -->
<!-- rev 1.31 by ccpz --> 
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link = "/doc/tw/portage-manual.xml">
<title>Portage 手册</title>

<author title="Author and Editor">
  <mail link="blocke@shivan.org">Bruce A. Locke</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="erwin@gentoo.org">Erwin</mail>
</author>
<author title="Translator"> 
  <mail link="ccpz@gentoo.org.tw">ccpz</mail>
</author> 
<author title="Reviewer">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>

<abstract>
这份手册提供 Portage 的概览，详细的设定资讯及一般使用者使用 Portage 来安装，维
护套件的指南。
</abstract>

<license/>

<version>0.9.15</version>
<date>2004年3月25号</date>

<chapter>
<title>Portage：概览</title>
<section>
<title>概览</title>
<body>

<p>
Portage 是一个很有威力，并且先进的套件管理系统。他的弹性及从简单的编译程式到建
立创新的 Linux 套件让他赢得了 Meta-distribution Engine 得头衔。Gentoo Linux 是
依靠 Portage 来建立的。
</p>

<p>
Gentoo Linux 本身通常被视为准发行版。他由 Portage 及超过4000套以上叫做
 <e>ebuilds</e> 的软体套件编译指令搞组成。这些 <e>ebuilds</e> 告诉 Portage 核心
如何编译及安装软体套件。透过使用 <e>profiles</e> 以及指令列工具 <c>emerge</c>，
使用者和开发者可以使用 Portage 来安装及维护组成基本的作业系统及应用程式的软体套
件。
</p>

<p>
Gentoo Linux 是"即时编译"。安装 Gentoo Linux 的动作包含设定足以工作的编译器，由
 Portage 透过网际网路下载建立 Linux 环境所需的原始码，还有编译其余的系统"核心"
和合适的软体。虽然 Portage 的确支援使用预先编译好的程式来安装，但这只是一种妥协
，让比较慢的电脑也可以安装，或是想要快速还原某些套件的发展者，以及在较快的电脑
先编译再拿到比较慢的电脑去使用的使用者。
</p>

<p>
因为以上的性质以及 Portage 具有相当高的编译及安装方式的操控性。极少数的 Gentoo 
安装方式会一样，基本上来说，当使用者安装 Gentoo Linux 时，Portage 系统依照 
Portage 中的设定以及 ebuilds 本身的设定来编译自订的 Linux 套件。
</p>	

<p>
第一眼看到 Portage 这个概念时或许会觉得和传统的 BSD port 系统很类似，他们都从原
始码编译套件并且允许使用者安全的从系统安装或移除软体，以及自动的处理相依性。许
多 Portage 的概念是从 BSD ports 系统借来的，但是 Portage 绝不只是另一个 
"ports 模仿者"。
</p>

<p>
Portage 系统是融合了 Python 核心和以 <e>Ebuilds</e> 为基础的 Bash 指令搞。不是
由 Makefiles 和 <c>make</c> 处理，而是巧妙的使用 Python 的威力及轻松的使用指令
搞的物件导向特性来建立独一无二且有力的系统，我们敢将 Portage 放置在目前所有
 ports 系统之前。
</p>

<p>
一些 Portage 先进的功能让 Portage 提供同时使用同一软体的不同版本(校定版本)的能
力，相依性分析与功能的支援，容易使用的套件管理，安全的 sandbox 安装，档案保护设
定，profiles，还有其他许多。这些功能里一大部分会在手册的后面讨论到。
</p>

</body>
</section>
<section>
<title>相依性分析与功能的支援</title>
<body>

<p>
Portage 提供给使用者的弹性是相当特殊的。传统的 BSD ports 系统在 port 树中一次只
能支援该套件的单一版本，Portage 则没有这种限制。同一套件的不同版本都可以拿来安
装。套件相依性，也就是某个套件在编译时需要另一个套件，可以用名称或名称以及一段
版本范围来指定。这让多重版本同时存在是很安全的。
</p>

<p>
相依性系统也支援了可调控的相依性。Portage 有一种很有威力的概念叫做 
<e>USE 设定</e>系统。藉著改变 Portage 设定档中一个设定参数，你可以对所有套件在
编译时关闭某个非必要的功能支援(包括他需要的东西)或函式库。这是一个非常有弹性及
威力的系统，我们会在下一章更进一步讨论他。
</p>

<p>
此外 Portage 也支援 <e>SLOT</e> 的概念。在 Gentoo Linux 的发展过程中，发展者常
会发现需要某一套件的多重版本(例如函式库)同时安装来满足其他套件的要求。传统上解
决这个问题的方法是把同一个套建的不同版本当作不同套件来看待，给予略为不同的名称
。
</p>

<p>
发展者不把某一版本当作独立的版本，而是告诉 Portage 如何利用 <e>SLOT</e> 来处理
及维护套件的多个版本。一个为人所熟知的例子就是 freetype 函式库。1.x 系列版本和
 2.x 并不相容，但是许多套件都依赖这两种版本其中之一。大部分的发行版以及 port 系
统常常会有 "freetype" 套件来提供 freetype 1.x，以及 "freetype2" 提供 2.x。我们
认为这个方法基本上来说代表一个毁损的 portage 管理系统。我们只要轻松的指定
 <c>SLOT</c> 号码 1 给第一个，2给第二个。藉著这个资讯 Portage 可以同时追踪两个
版本以及两种分枝的新版本有更新时自动更新。
</p>

</body>
</section>
<section>
<title>Profiles</title>
<body>

<p>
Portage 支援 <e>profiles</e> 的概念。profile 包含套件名称的列表以及指令及一套预
设的设定选项让 Portage 使用。profile 告诉 Portage 那些套件中哪一个套件及哪一个
版本要允许，拒绝，还是由使用者决定。使用者可以藉著改变单一的符号连结
(<path>/etc/make.profile</path>)来改变 profiles。这或许看起来很简单`,但是可以让
 Portage 建立一个发行版的核心，以及一个专业级的变异系统。
</p>

<p>
建立 Gentoo Linux 发行版整个的工作是由一大群 Portage 所使用的 <e>ebuild</e> 档
案来完成的。Profile 定义哪些套件对系统使用上是足够重要而要视为 "核心" 套件。
Profile 也允许发展者限制或取消限制某个套件版本来暂时移除已损毁的套件等等。
<e>ebuild</e> 档案只要简单的告诉 Portage 实际上如何编译及安装 profile 所要求或
允许的套件。
</p>

</body>
</section>
</chapter>

<chapter>
<title>设定 Portage</title>
<section>
<title>概览</title>
<body>

<p>
下面的章节包含了多种角度的 Portage 设定，对使用者或发展者来说都很重要，Portage 
是非常有弹性的系统，你将会需要了解如何设定让 Portage 掌控你的系统，以及针对你的
需求最佳化。
</p>

<p>
请注意文件中的 "使用者" 代表有使用 Portage 管理权限，改变 Portage 设定，安装及
反安装软体的使用者。
</p>

</body>
</section>
<section>
<title>Portage 设定档</title>
<body>

<p>
几乎的下所有讨论的选项都可以在 <path>/etc/make.conf</path>，
<path>/etc/make.profile/make.defaults</path> 以及 
<path>/etc/make.globals</path> 找到。<path>/etc/make.conf</path> 包含许多 
Portage 用的参数。Portage 首先会检查目前的环境变数来套用在设定上，如果找不到的
话，Portage 接下来会检查 <path>/etc/make.conf</path>，如果在 
<path>/etc/make.conf</path> 还是没有，就检查 
<path>/etc/make.profile/make.defaults</path>。最后还是找不到的话，预设是从 
<path>/etc/make.globals</path> 中取得，请注意所有的设定要在环境中或 
<path>/etc/make.conf</path> 中设定，这通常是由使用者自订的。更重要的一点是要记
得 <path>/etc/make.conf</path> 中的任何设定会覆盖掉 
<path>/etc/make.globals</path> 的设定。在 <path>/etc/make.conf</path> 以及
 <path>/etc/make.globals</path> 中的设定到目前都被 Portage 当作全域的设定。
</p>

<p>
当你要检查哪个设定已经定义时，建议你先检查 <path>/etc/make.conf</path> ，然后检
查 <path>/etc/make.globals</path>。除非是特别提醒，<path>/etc/make.conf</path> 
中的设定会取代 <path>/etc/make.globals</path> 的设定。
</p>

</body>
</section>
<section>
<title>USE 设定</title>
<body>

<p>
USE 设定系统是一个非常有弹性的方法，在编译时对全域或个别软体开启或关闭套件的某
些功能。这让管理者控制套件如何编译，以决定哪些非必要的功能要加入。例如说支援 
GNOME 的套件可以关闭 <c>gnome</c> USE 设定来取消对 GNOME 的支援，开启 
<c>gnome</c> USE 设定可以让该套件支援 GNOME。
</p>

<p>
USE 设定对套件的效用决定在软体本身和套件的 ebuild 是否支援该 USE 设定。如果软体
没有支援和 USE 设定相对应的功能的话，USE 设定很明显的没有作用。而且许多套件的相
依性对那个套件来说并不是可以自由选择的，因此 USE 设定对强制的相依性也是没有作用
的。套件所使用的 USE 关键字列表可以在 ebuild 档案中的 <c>DEPEND</c> 以及 
<c>RDEPEND</c> 找到。
</p>

<p>
Gentoo Linux 使用的 USE 设定列表可以在 
<path>/usr/portage/profiles/use.desc</path> 中找到。每一个 USE 设定在单一行中列
出来，包含简单的描述这个 USE 设定开启哪些功能。
</p>

<p>
Portage 检查四个不同的位置来决定 USE 设定是开启还是关闭。这些位置用 "堆叠" 的方
法改变 USE 设定。Portage 阅览每一个位置并且记得前一个位置开启或关闭一个设定。
USE 设定在浏览的过程中累积。
</p>

<p>
检查 USE 设定的位置及顺序是由 <path>/etc/make.globals</path> 中的 
<c>USE_ORDER</c> 决定。要柜必一个位置你只要简单的将他从 <c>USE_ORDER</c> 中移除
。
</p>

<p>
接下来是 Portage 预设设定中由 <c>USE_ORDER</c> 中定义的每个位置的说明。
</p>

<p>
<b>Defaults</b>
</p>

<p>
Portage profiles 可以定义一套预设的 USE 关键字。这在任何 Portage profile 的 
make.defaults 档案中定义。因为 <path>/etc/make.profile</path> 只是一个指向目前
使用的 profile 的连结。<path>/etc/make.profile/make.defaults</path> 是目前有作
用的关键字。因为 porfile 的改变会盖掉你的设定，建议你不要编辑这个档案。
</p>

<p>
<b>Auto</b>
</p>

<p>
这在 Portage profile 中的 use.defaults 档案定义 
(<path>/etc/make.profile/use.defaults</path>)。每一行包含一个 USE设定以及相对应
的套件。如果列表上的套件安装了，那相对的 USE 设定就被视为开启的。例如你安装了 
<c>x11-base/xfree</c> 而且并没有明确的关闭位置在这之后的 X USE 设定，那 X 关键
字将会被全域的开启当这个套件安装完以后。因为 porfile 的改变会盖掉你的设定，建议
你不要编辑这个档案。
</p>

<p>
<b>Conf</b>
</p>

<p>
如果在 <path>/etc/make.conf</path> 有定义 <c>USE</c> 设定的话，这个设定也会被包
含在内。如果 <path>make.conf</path> 中没有 <c>USE</c> 设定的话，会检查 
<path>/etc/make.globals</path>。他的内容看起来可能像这样：
</p>

<pre caption="USE 内容">
USE="slang readline gpm berkdb gdbm tcpd pam libwww ssl gb tk
lm_sensors lvm ldap tex bonobo sdl gtk xfs evo pda ldap
mmx mitshm perl python guile ruby postgres dvd 3dnow tcl
lcms gif sdl vorbis ogg oss libg++ directfb decss snmp
gnome X opengl mozilla pdflib gpg -nls gd xface jpilot
-kde -qt -esd -motif -alsa oggvorbis"
</pre>

<p>
USE 设定只要加上名称就能轻松的开启了。在名称之前加上 <c>-</c> 字元就会被关闭。
例如说 <c>gnome</c> 开启 GNOME 支援，而 <c>-motif</c> 关闭 motif 支援。
</p>

<p>
当你要开启或关闭某个关键字时，建议你放在 <path>/etc/make.conf</path> 中的 
<c>USE</c> 设定。这个档案并不会被 Portage 取代掉。并且建议你开启或关闭在前两个
位置中你不想要被关闭或开启的 USE 关键字。
</p>

<p>
<b>Env</b>
</p>

<p>
USE 关键字可以手动的用 shell 环境变数取代掉。
</p>

<pre caption = "取代 USE 关键字">
# <i>export USE="-gnome"</i>
# <i>emerge net-im/gaim</i>
</pre>

<p>
这允许安装一个或多个特定软体时使用某些特定的 USE 设定。在设定之后就会一直使用这
些关键字，只要 emerge 是从这个 shell 执行而且 USE 设定仍然存在。
</p>

<note>
Portage 目前纪录下来用来安装的 USE 设定并不是永久的。如果重新安装或升级套件他将
会使用目前作用中的 USE关键字而不是上次安装的 USE 设定。
</note>

</body>
</section>
<section>
<title>编译设定</title>
<body>

<p>
Portage 用来编译套件的编译选项可以藉著编辑 <path>/etc/make.conf</path> 中的 
<c>CHOST</c>，<c>CFLAGS</c>，和 <c>CXXFLAGS</c> 来设定。<c>CHOST</c> 设定你编译
的平台，而 <c>CFLAGS</c> 及 <c>CXXFLAGS</c> 分别设定编译 C 和 C++ 时使用的编译
参数。
</p>

<p>
不同的平台要使用哪些编译参数在注解中提供了一些设定。这些预设值都很稳定且被测试
过了。改变他们可能会发现编译器或软体出现编译错误或是 bug。如果你想要自订设定请
小心，因为你可能会得到不稳定的系统。
</p>

<p>
多处理器的使用这可能会从调整 <path>/etc/make.globals</path> 中的 
<c>MAKEOPTS</c> 获得一些好处。这选项在编译时传给 <c>make</c> 指令同时开启多个 
gcc程序。
</p>

</body>
</section>
<section>
<title>目录位置</title>
<body>

<p>
Portsge 允许你去设定他存放档案及编译套件时使用的目录。大部分使用者并不需要改变
这些选项。底下这些是你可以设定的：
</p>

<ul>
  <li><c>PORTDIR</c> - Portage 树位置</li>
  <li><c>DISTDIR</c> - 已下载的档案存放位置</li>
  <li><c>PKGDIR</c> - 本机上产生的 tbz2 套件位置</li>
  <li><c>RPMDIR</c> - 本机上产生的 RPM 套件位置</li>
  <li><c>PORTAGE_TMPDIR</c> - 编译套件时所使用的暂存目录</li>
  <li><c>BUILD_PREFIX</c> - 和 PORTAGE_TMPDIR 有关</li>
  <li><c>PKG_TMPDIR</c> - 和 PKGDIR 有关</li>
</ul>

</body>
</section>
<section>
<title>设定档案保护</title>
<body>

<p>
Portage 允许保护特定目录内的所有设定档。Portage 不会覆盖掉被保护目录内的档案。
如果一个套件尝试安装一个已存在的档案，他会被更名成类似 
<path>._cfg0000_name</path> 的名称。这样可以让使用者之后查看这些新档案并且手动
的合并这两个档案的相异处。
</p>

<p>
被保护的目录可以在 <path>/etc/make.conf</path> 或 
<path>/etc/make.globals</path> 之中的 <c>CONFIG_PROTECT</c> 设定。特定的档案或
是被保护目录下的子目录可以用 <c>CONFIG_PROTECT_MASK</c> 解除保护。
</p>

<p>
下便是一个范例，但你不应该直接复制他：
</p>

<pre caption = "保护特定的档案或目录">
CONFIG_PROTECT="/etc /usr/share/config /usr/kde/2/share/config"
CONFIG_PROTECT_MASK="/etc/gconf /etc/init.d /etc/pam.d"
</pre>

<p>
使用者可以用下面的指令取得更多的设定档案保护资讯：
</p>

<pre caption = "更多的设定档案保护资讯">
# <i>emerge --help config</i>
</pre>

</body>
</section>
<section>
<title>FEATURES</title>
<body>

<p>
Portage 提供许多选项，控制 Portage 的行为，以及在安装套件的各种阶段后如何清除。
这些选项应该只有发展者有兴趣而对一般使用者可能会造成问题。
</p>

<p>
底下是可以在 <path>/etc/make.conf</path> 或 <path>/etc/make.globals</path> 中的
 <c>FEATURES</c> 设定选项列表：
</p>

<ul>
  <li><c>digest</c>：自动建立新的 ebuild 的 digest。</li>
  <li><c>cvs</c>：自动递交新的 digests 给 cvs。</li>
  <li><c>sandbox</c>：启动 "sandbox" 作为路径前置字元保护。</li>
  <li><c>noclean</c>：Portage 不会在安装完后清除档案。</li>
  <li><c>noauto</c>：不要自动执行预先的编译工作。</li>
  <li><c>distcc</c>：使用 distcc 提供的分散编译功能。</li>
  <li><c>ccache</c>：维持编译的目的档让重新编译时可以花比较少的时间。</li>
  <li><c>buildpkg</c>：当安装完后建立执行档套件。</li>
  <li><c>userpriv</c>：编译时使用一般使用者权限。</li>
  <li><c>usersandbox</c>：当 <c>userpriv</c> 启动时使用 sandbox。</li>
  <li><c>keeptemp</c>：安装完后不要移除暂存档案 (${T})。</li>
</ul>

<p>
一些功能可以藉著设定底下的选项来作更好的调整：
</p>

<ul>
  <li>
    <c>CCACHE_SIZE</c>：这定义 <c>ccache</c> 可以用多少空间。预设是 2 Gb。
  </li>
  <li>
    <c>DISTCC_HOSTS</c>：定义哪些主机执行 <c>distcc</c> 的分散编译。所有的主机
	都要执行  <c>distccd</c> 服务。
  </li>
</ul>

</body>
</section>
<section>
<title>Portage SYNC 设定</title>
<body>

<p>
Portage 支援透过 rsync 来更新 Portage 树。如果你发现其他的更新方法，你可以透过 
<path>/etc/make.conf</path> 中的 <c>SYNC</c> 来指定你想使用的方法。
</p>

<p>
<b>RSYNC</b>
</p>

<p>
rsync 是保持你的 Portage 最新的最常用的方法。在 <path>/etc/make.conf</path> 设
定 rsync 方式：
</p>

<pre caption = "设定 RSYNC 变数">
SYNC="rsync://rsync.gentoo.org/gentoo-portage"
</pre>

<note>
rsync 会盲目的覆盖掉你在本机上 Portage 树做的一切改变。如果你想要维持改变，使用
 <c>PORTDIR_OVERLAY="/some/dir/where/you/keep-your-tree"</c> 保护你想要保留的
Ebuild。
</note>

<note>
查看 <path>/etc/make.conf</path> 来了解如何设定到本地的 rsync 镜像。这可以让你
选择地理位置较靠近你的位置，通常速度会比较快。这也会帮助伺服器减轻负荷。
</note>

<p>
<b>发展者的 CVS</b>
</p>

<p>
有完整权限读取 CVS 树的发展者也可以让 <c>emerge</c> 透过 SSH 来和 CVS 树同步。
</p>

<p>
轻松的使用你的帐号检查 CVS 树，把他移动到 /usr/portage ，然后使用下面的
 <c>SYNC</c> 设定。
</p>

<pre caption = "使用 CVS 更新 Portage 树">
SYNC="cvs://youraccount@cvs.gentoo.org:/home/cvsroot"
</pre>

</body>
</section>
<section>
<title>镜像</title>
<body>

<p>
Gentoo 企划维持了一份本地的 Portage 树中所有档案的镜像。通常软体最新的原始档和
设定放在速度慢，可能会停止的伺服器上。而且软体发展者通常在新版本发行时移除 ftp 
上旧的版本。让使用 Gentoo 发行版的使用者用的比较轻松(以及减少原始码 ftp 的频宽
使用)，我们镜像这些档案。这让你可以从本地的站台更快速且稳定的下载档案。
</p>

<p>
当你想要安装一个套件时，Portage 会先检查镜像站上有没有档案，没有的话才从 ebuild
 档案中指定的位置下载。
</p>

<p>
Portage 使用的镜像站可以在 <path>/etc/make.conf</path> 中的 
<c>GENTOO_MIRRORS</c> 指定。底下是目前预设的设定：
</p>

<pre caption = "宣告镜像站">
GENTOO_MIRRORS="http://www.ibiblio.org/gentoo"
</pre>

<p>
你可以查看 Gentoo 网站或是本的的邮寄列表来找到离你较近的镜像站。也可以安装 
<c>mirrorselect</c> 来帮你寻找。请看安装指南来取得更多 <c>mirrorselect</c> 的资
讯。
</p>

</body>
</section>
<section>
<title>下载程式</title>
<body>

<p>
Portage 用来下载的程式可以在 <c>FETCHCOMMAND</c> 和 <c>RESUMECOMMAND</c> 指定。
在 <path>/etc/make.conf</path> 以及 <path>/etc/make.globals</path> 有一些设定的
范例。Portage 预设使用可以满足大部分需求的 <c>wget</c>。
</p>

<note>
Portage 可以使用 HTTP_PROXY 和 FTP_PROXY 环境变数取得 HTTP 和 FTP 代理伺服器资讯
。
</note>

</body>
</section>
<section>
<title>代理伺服器</title>
<body>

<p>
Portage 可以在下载档案时使用 HTTP 和 FTP 代理伺服器。这可以在 
<path>/etc/make.conf</path> 或 <path>/etc/make.globals</path> 中的 
<c>HTTP_PROXY</c> 和 <c>FTP_PROXY</c> 指定。如果 HTTP 和 FTP 都是使用同一个伺服
器，你也可以只设定 <c>PROXY</c>。
</p>

<p>
底下是一个范例：
</p>

<pre caption = "设定代理伺服器">
HTTP_PROXY="http://192.168.1.1:8080"
FTP_PROXY="http://192.168.1.1:8080"
<comment>或</comment>
PROXY="http://192.168.1.1:8080"
</pre>

<p>
Portage 也可以在使用 RSYNC 时使用 HTTP 代理伺服器。RSYNC 代理伺服器可以在 
<path>/etc/make.conf</path> 中的 RSYNC_PROXY 选项设定或设成环境变数。
</p>

<p>
底下是一个范例：
</p>

<pre caption = "设定 RSYNC 代理伺服器">
RSYNC_PROXY="192.168.1.1:8080"
</pre>

<note>
如果你连外要经过防火墙，而 rsync 不能使用 HTTP 代理伺服器，你可以透过最新的 
tarball 来更新，看我们的 <uri link="/doc/tw/faq.xml#doc_chap4_sect10">FAQ</uri>
 取得更多资讯。
</note>

</body>
</section>
<section>
<title>其他设定</title>
<body>

<p>
底下是一些可能对使用者有用的选项：
</p>

<ul>
  <li>
    <c>NOCOLOR</c>：让使用者关闭 emerge 工具的颜色。
  </li>
  <li>
    <c>CLEAN_DELAY</c>：Portage 在解除安装时延迟一些时间给使用者取消的机会。这
	指定要暂停几秒，设成 "0" 就会关闭。
  </li>
  <li>
    <c>PORTAGE_NICENESS</c>：这个变数设定 emerge 的优先权。
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>套件管理</title>
<section>
<title>更新 Portage 树</title>
<body>

<p>
位在 <path>/usr/portage</path> 的 Portage 树包含各种套件如何安装的函式库(叫做 
<e>ebuilds</e>)。这里面也包含让你的电脑保持最新的 profile 和 package.mask。为了
取得最新的套件以及修正，让套件保持在最新而且和官方的 Portage 树同步非常重要的。
你可以输入下面的指令来更新：
</p>

<pre caption = "更新 Portage 树">
# <i>emerge sync</i>
</pre>

<p>
emerge 用来更新的方法可以改变。查看 
<uri link="#doc_chap2">设定 Portage</uri> 中的  
<uri link="#doc_chap2_sect8">Portage SYNC 设定</uri> 来得到更多资讯。
</p>

</body>
</section>
<section>
<title>安装(merge) 套件</title>
<body>

<p>
Portage 编译及安装套件的工作称为 <e>merging</e>。Portage 编译套件然后暂时安装在
虚拟的目录纪录安装好的档案。然后这些档案从目录中移出来并且合并到真实的 / 档案系
统。
</p>

<p>
<c>emerge</c> 指令是 Portage 的前端程式。安装及移除软体是靠这个指令及他多种参数
来完成的。
</p>

<p>
安装最新且没有被封锁的套件只要简单的像底下指定套件名称就可以了：
</p>

<pre caption = "安装套件">
# <i>emerge galeon</i>
</pre>

<p>
这个指令会编译及安装任何需要的相依套件(任何 USE 设定都会被考虑)然后安装最新且没
有封锁的 galeon。galeon 也可以用跟著类别的完整名称来指定：<c>net-www/galeon</c>
</p>

<p>
<c>emerge</c> 也可以指定实际的 ebuild 档案。这让使用这可以安装比较旧的版本或安
装非官方的套件。注意这会覆盖掉告件的封锁并且忽略 <c>ACCEPT_KEYWORDS</c> 设定。
底下是一个范例：
</p>

<pre caption = "安装指定的 ebuild">
# <i>emerge /usr/portage/net-www/galeon/galeon-1.2.0-r3.ebuild</i>
</pre>

<p>
除了指定套件名称或 ebuild 档案，<c>emerge</c> 支援许多有用的命令列参数。在这些
参数之中 <c>--pretend</c> 或许是最有用的一个。当使用这个参数时指定的工作并不会
执行，相反的 Portage 显示执行这个动作会安装或更新的套件列表。底下是一个范例，显
是安装最新的 kdevelop 套件时哪些套件会被安装：
</p>

<pre caption = "查看 emerge 会做什么">
# <i>emerge --pretend kdevelop</i>

These are the packages that I would merge, in order.

Calculating dependencies ...done!
[ebuild  N   ] kde-base/kdelibs-2.2.2-r4 to /
[ebuild  N   ] dev-util/kdbg-1.2.2 to /
[ebuild   U  ] app-text/psutils-1.17 to /
[ebuild   U  ] app-text/a2ps-4.13b-r3 to /
[ebuild   U  ] app-text/jadetex-2.20 to /
[ebuild  N   ] app-text/sgmltools-lite-3.0.3-r2 to /
[ebuild  N   ] kde-base/kdoc-2.2.2-r1 to /
[ebuild  N   ] net-www/htdig-3.1.5-r2 to /
[ebuild  N   ] app-text/enscript-1.6.3-r1 to /
[ebuild  N   ] kde-base/kdebase-2.2.2-r2 to /
[ebuild  N   ] app-doc/qt-docs-2.3.1 to /
[ebuild  N   ] dev-util/kdevelop-2.0.2 to /
</pre>

<p>
在上面的列表中，有 <c>N</c> 标记的套件代表先前还没安装而在这次动作将会被安装。 
<c>U</c> 代表已经安装过而这次会将他更新。
</p>

<p>
其他可用的指令有：
</p>

<p>
<c>--fetchonly</c>：下载安装套件需要的档案以及他依赖的套件。
</p>

<p>
<c>--emptytree</c>：这个选项让 Portage 以为相依的套件都没有安装。这是一个很有用
的选项让 <c>--pretend</c> 显示完整的相依性列表。
</p>

<p>
<c>--nodeps</c>：Portage 指安装指定的套件而略过任何的相依性。如果你没优安装合适
的相依套件，编译时可能会失败。
</p>

<p>
<c>--onlydeps</c>：只安装相依套件，指定要安装的套件<b>不会</b>被安装。
</p>

<p>
<c>--noreplace</c>：如果套件已经安装了就略过不装。
</p>

<p>
<c>--usepkg</c>：不要编译指定的套件，Portage 会使用预先编译好放在指定位置的 
tbz2 套件，这个位置在 <c>PKGDIR</c> 环境变数指定。
</p>

<p>
<c>--debug</c>：ebuild会显示更多东西，这在发展者检查以 bash script 为基础的 
ebuild 档的语法错误是很有用的。
</p>

<p>
<c>--autoclean</c>：强制 <c>emerge</c> 在刊使编译前清除暂存目录。Portage 预设就
会执行这个动作，所以这对关闭这个选项的发展者才有用。
</p>

<p>
<c>--verbose</c>：告诉 <c>emerge</c> 以完整模式执行。这通常和 <c>--pretend</c> 
一起使用来显示这个套件可用的 USE 设定。
</p>

</body>
</section>
<section>
<title>移除 (unmerging) 套件</title>
<body>

<p>
unmerging 是从档案系统移除所有套件相关的档案。套件中的软体不能在被使用除非再次
安装他。
</p>

<p>
使用 <c>emerge</c> 指令加上 <c>unmerge</c> 参数，后面接著要移除的套件名称就可以
移除了。底下是移除 <c>ltrace</c> 套件所有安装的版本的范例：
</p>

<pre caption = "移除套件">
# <i>emerge unmerge ltrace</i>
<comment>或</comment>
# <i>emerge unmerge dev-util/ltrace</i>
</pre>

<p>
Portage 也允许指定移除特定的版本。可以用 <c>=</c> (同一版本)，<c>&lt;</c> (小於)
，<c>&gt;</c> (大於)，<c>&lt;=</c> (小於或等於)，或 <c>&gt;=</c> (大於或等於)来
指定范围。底下是指定移除版本等於 0.3.15 或更旧的 ltrace：
</p>

<pre caption = "移除特定的套件版本">
# <i>emerge unmerge \&lt;=dev-utils/ltrace-0.3.15</i>
</pre>

<p>
当你指定范围时，跳脱 <c>&gt;</c> 和 <c>&lt;</c> 是很重要的，以免 shell 执行他们
。而且你需要像范例一样指定他的类别。其他的指定版本范围范例可以在 
<c>emerge --help</c> 看到。
</p>

<warn>
移除套件可能很危险。如果你移除核心成是，你的系统可能中断某些功能，而且移除某些
函式库可能让软体无法执行。<b>Portage 当你在移除核心套件或其他程式依赖的套件时不
会警告你。</b>
</warn>

<p>
如果要移除的程式的确安装了 emerge 会显示目前要移除哪个套件并且会暂停指定时间，
让使用者有取消的机会。在这段警告的期间使用者可以按 Control-C 来取消移除。
</p>

<p>
一但开始解除安装后你可以看到一长串属於这个套件的档案清单。一些档案在档案名称左
边会有些标记。<c>!mtime</c>，<c>!empty</c>，和 <c>cfgpro</c> 说明这些档案为什么
不会被移除。没有这些标记的档案将会从档案系统中移除。
</p>

<p>
<c>!mtime</c> 标记代表这个档案在套件安装完成以后有被更改过。也就是说有人在安装
完以后编辑这个档案，或是之后安装的套件更动了档案内容。这让套件可以放心的更新而
不必担心移除旧的版本会删除重要的档案。
</p>

<p>
<c>!empty</c> 标记表示因为目录不是空的，所以 Portage 拒绝移除(通常多个套件会拥
有同一目录的使用权)。当你看到 <c>cfgpro</c> 标记代表这是受保护的而不会移除。也
就是说新安装的套件拥有一些设定档的使用权而 Portage 拒绝移除他。
</p>

<warn>
档案通常被视为最新的套件所拥有的。这是由安装的顺序来决定而不是安装套件的版本号
码或修订版号码决定。即使之前安装的套件也安装这个档案，移除最新安装的套件他拥有
的档案也会移除(假设你没有手动修改他)。
</warn>

</body>
</section>
<section>
<title>系统更新</title>
<body>

<p>
Portage 支援用单一指令自动更新安装过的套件。系统更新让使用者更新对操作 Gentoo 
Linux 系统很重要的 "核心" 程式到 Gentoo 核心发展者建议的版本。系统更新并不会更
新非基础的套件，只有在 Portage profile 中定义为操作及维持系统的基础套件才会更
新。
</p>

<p>
输入下列指令执行系统更新：
</p>

<pre caption = "更新你的系统">
# <i>emerge --update system</i>
</pre>

<p>
Portage 会依照目前安装及 Portage profile 建议的版本来编译及安装更新。使用者可
以在上面的例子用 <c>--pretend</c> 参数来取得会被安装及更新的列表。
</p>

<note>
你可能注意到安装指南中一个步骤是执行 <c>emerge system</c> 安装基础(核心)套件。
 <c>emerge --update system</c> 根据最新的建议版本更新基础套件。
</note>

</body>
</section>
<section>
<title>更新全系统</title>
<body>

<p>
Portage 也支援用单一指令更新选择的非必要套件。Portage 够聪明而可以在多个互相冲
突的套件版本存在时，安全的更新系统。
</p>

<p>
Portage 的全系统更新功能查看系统 profile，封锁的套件列表，全系统的 profile 以及
他里面列的相依性(包括版本范围)来决定哪些要升级。如果套件有新版本并且列在全系统 
profile 中，或是被全系统 profile 中某套件依赖，这个套件就会被更新。而且指定的套
件版本要没有在系统 profile 或 <path>package.mask</path> 中封锁才会更新。
</p>

<p>
当考虑哪些套件要更新时，Portage 尝试更新全系统 profile 中的所有套件邓最新的版本。
Portage 也会考虑被那些套件依赖的套件，如果有新的版本时，而且符合版本范围且没有
系统 profile 或 <path>package.mask</path> 封锁的话也会更新。他也会将前面提到的
 <c>SLOTS</c> 也列入考虑。
</p>

<p>
熟悉其他发行版和 Portage 以外的套件管理系统的使用者，可能会对 Portage 为什么不
直接根据版本号码升级(像 Gentoo 1.0 之前一样)感到疑惑。Gentoo 中的许多套件有多重
版本，较旧或较新的套件可能和其他依赖他的套件不相容。直接升及而不考虑其他套件的
需求可能导致许多严重的问题。为了避免这种情况，Portage 更新时注意这些状况并且依
据每一个套件的 ebuild 中宣告的需求来做。
</p>

<p>
Portage 的全系统更新核心是全系统 profile。不像系统 profile 由发展者决定而且使用
者不曾修改他，全系统更新根据使用者的动作间接产生。全系统 profile 像是一个当使用
者用 <c>emerge</c> 指令安装时会纪录的 "我的最爱列表"。他是纪录在位於 
<path>/var/cache/edb/world</path> 的 <path>world</path> 档。Portage 假设因为你
安装这个套件，所以你对保持最新的版本有兴趣。
</p>

<p>
<path>world</path> 包含套件名称以及他的类别的列表，每一行看起来会像下面这样：
</p>

<pre caption = "/var/cache/edb/world 范例">
net-im/gaim
net-www/skipstone
net-www/galeon
app-editors/vim
app-text/ispell
net-mail/evolution
dev-util/ltrace
sys-fs/xfsprogs
sys-apps/attr
sys-apps/dmapi
sys-kernel/linux-sources
sys-apps/acl
app-office/gnucash
app-cdr/xcdroast
</pre>

<p>
几乎上面的每一行是当使用者安装指定的套件时由 Portage 自动加进去的。如果这些套件
有新的版本就会被更新。
</p>

<note>
为了节省时间和保持你最爱的套件最新，你可能要手动编辑 <path>world</path> 加上哪
些套件。从旧的 Portage 版本升级的使用者可能需要建立这个档案。在最近安装的 
Gentoo 或 Portage 安装时就会建立这个档案了。
</note>

<p>
使用底下的指令来完成全系统更新：
</p>

<pre caption = "更新全系统">
# <i>emerge --update world</i>
</pre>

<p>
Portage 会尝试更新 <path>world</path> 中提到的套件以及需要的话相依套件也会更新
。相依套件会更新到最新且符合套件需求的版本。没有列在 <path>world</path> 而且没
有被里面套件相依的套件将不会被更新。
</p>

<p>
如果 <c>emerge</c> 相要降级一些套件但你不想这么做，使用 <c>--upgradeonly</c>：
</p>

<pre caption="只升级">
# <i>emerge --upgradeonly world</i>
</pre>

<warn>
Portage 不会覆盖设定档中设定要保护的目录，你需要手动合并旧版和新版的设定档。如
你没有更新设定档，安装好的软体可能会停止工作。查看
<uri link="#doc_chap2">设定 Portage</uri>中的
<uri link="#doc_chap2_sect6">设定档案保护</uri>或是使用这个指令
 <c>emerge --help config</c> 来取得更多的资讯。
</warn> 

<p>
想要查看全系统更新会更新的软体列表，你可以使用前面提到的 <c>--pretend</c> 参数。
</p>

<note>
全系统更新也会自动执行系统更新。
</note>

<p>
使用者想要更新所有系统上安装的软体可能会出现一个有趣的副作用。因为全系统更新会
尝试更新 <path>world</path> 档案内提到的套件以及他的相依套件。使用 
<c>--emptytree</c> 是一个强迫重新编译所有套件及相依套件的方法。这对使用者改变编
译选项或 USE 设定，而且希望所有套件套用新的设定，但不想手动重新安装的使用者相当
有用。用你常用的程式建立 <path>world</path> 档然后输入下列指令：
</p>

<pre caption = "也重新编译所有相依套件">
# <i>emerge --update world --emptytree</i>
</pre>

<p>
你可以加上 <c>--pretend</c> 参数来取得会被重新编译的套件列表。
</p>

</body>
</section>
<section>
<title>清理系统</title>
<body>

<p>
Portage 支援安装同一套件的不同版本。在 Portage 中只有少数套件会用到这个功能(为
了向下相容，因为旧的程式可能会和其他新的套件不相容)。
</p>

<p>
虽然新版的套件安装时就的套件大部分档案都会被覆盖。但还有一些文件档和一些不重要
档案会被留下来，随著时间过去，这些 "脏东西" 会越积越多而且浪费你宝贵的磁碟空间。
</p>

<p>
Portage 提供一个简单的功能从你的系统移除这些旧版本的遗迹，以解决这种情况。这个
功能只要使用 emerge 的 <c>clean</c> 选项。只要输入下面指令就可以使用：
</p>

<pre caption = "移除旧版本的套件">
# <i>emerge clean</i>
</pre>

<p>
<c>emerge</c> 会显示会被移除和会保留的套件版本，修订版列表，然后给使用者一些时
间按 Control-C 取消。在一般的系统中会有一阵混乱的动作，然后会显示要保留或移除的
长档案列表。
</p>

<p>
除非特别指定，Portage 假设要依照 <path>world</path> (所有安装套件)来执行清理。
你可以用类似 <c>world</c>，<c>system</c> 的选项，或是套件名称，前面提到的版本范
围来缩小清理的范围。
</p>

<p>
Portage 依照各种 profiles，其他套件的需要，套件的 SLOT 来决定哪些套件要移除。假
设相依性在所有套件中都正确定义，清理的动作将会安全的移除旧的套件系统，而且不会
移除任何功能也不会让系统失去作用。
</p>	

</body>
</section>
<section>
<title>修整套件</title>
<body>

<p>
Portage 也支援<c>修整</c> (prune) 的动作。修整是清除的不安全形式。他移除最新版
本以外的套件。他并不像<c>清理</c>做这么多安全检查，而且可能移除基础的软体。使用
者执行这个指令可能会轻易的毁掉整个系统，除了在特别情况我们不建议你执行他。
</p>

<p>
<c>修整</c>支援和清理一样的列表，你可以像底下这样执行：
</p>

<pre caption = "修整系统">
# <i>emerge prune</i>
</pre>

</body>
</section>
<section>
<title>搜寻 Portage 树</title>
<body>

<p>
像 Portage 这种建立 Gentoo Linux 核心的发行版核心的东西可能会相当大。
<c>emerge</c> 提供搜寻功能，他接受以括号括起来的正规表示式，正规表示式是一团非
常复杂的东东，如果你对熟练使用正规表示式有兴趣的话，建议你找一本关於这主题的好
书来看。
</p>

<p>
你可以不知道正规表示式就可以执行简单的搜寻。底下是一个范例，搜寻叫做 "gcc" 的套
件或是名称一部分有 "gcc" 的套件。
</p>

<pre caption = "以正规表示式搜寻">
# <i>emerge search gcc</i>
</pre>

<p>
每一个符合搜寻条件的套件会列出套件名，最新版本，已安装的最新版本，他的首页，以
及套件包含软体的描述。
</p>

</body>
</section>
<section>
<title>取得帮助</title>
<body>

<p>
更多关於 <c>emerge</c> 选项及动作的资讯可以输入下列的指令来取得：
</p>

<pre caption = "取得帮助">
# <i>emerge --help</i>
</pre>

</body>
</section>
<section>
<title>有用的工具</title>
<body>

<p>
一些有用的工具已经制作好了，让 Gentoo 使用者更轻松的使用。这些工具可以在 
Gentoo Portage 树中的 <c>app-portage/gentoolkit</c> 找到。
</p>

<ul>
  <li>
    <c>etc-update</c>：使用 vim 来决定如何合并 /etc 新旧档案的 shell 指令搞。
	(如果不正确使用可能很危险)。
  </li>
  <li>
    <c>qpkg</c>：套件资料库搜寻工具。
  </li>
  <li><c>epm</c>：另外一个套件资料库搜寻工具，使用类似 RPM 的语法。</li>
  <li><c>etcat</c>：显示并且解释套件的 USE 标记。</li>
  <li>
    <c>revdep-rebuild</c>：重新编译因为更新函式库而和 API 不相容的套件。
  </li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>什么是封锁 (Masked) 的套件</title>
<section>
<body>

<p>
许多人好奇为什么最新的套件没有包含在 <c>emerge -u world</c> 中。一个范例是 
xfree-4.3.0(在写这篇文章时的版本)，如果你执行 <c>emerge sync</c> 然后执行
 <c>emerge -u world</c>，你会发现 xfree 并不会被更新，为什么呢？
</p>

<p>
理由就是套件被标记为"封锁"，也就是说这个套件并不会被自动安装或更新，除非你指定
要这样做。详细的安装被封锁的套件说明，我们建议你参观
<uri link="http://forums.gentoo.org/">Gentoo 讨论区</uri>的
<uri link="http://forums.gentoo.org/viewtopic.php?t=33534">封锁套件 FAQ</uri>。
或是 <uri link="http://forums.gentoo.org.tw">Getoo 台湾讨论区</uri>。
</p>

</body>
</section>
</chapter>
</guide>
