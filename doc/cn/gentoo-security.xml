<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type="text/xsl" href="/xsl/guide.xsl" ?>
<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/gentoo-security.xml,v 1.54 2004/05/13 06:51:35 swift Exp $ -->


<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link = "/doc/zh_cn/gentoo-security.xml">
<title>Gentoo Linux 安全指南</title>
<author title="Author">
  <mail link="kn@insecurity.dk">Kim Nielsen</mail>
</author>
<author title="Editor"><!-- zhen@gentoo.org -->
  John P. Davis
</author>
<author title="Editor">
  <mail link="stocke2@gentoo.org">Eric R. Stockbridge</mail>
</author>
<author title="Editor">
  <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
  <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>
<author title="Editor">
  <mail link="jaervosz@itu.dk">Sune Jeppesen</mail>
</author>
<author title="Editor">
  <mail link="blubber@gentoo.org">Tiemo Kieft</mail>
</author>
<author title="Editor">
	<mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Translator">
	<mail link="lancez@spymac.com">Lance Zhang</mail>
</author>

<abstract>
本指南循序渐进地引导您强化Gentoo Linux的安全性。
</abstract>

<license/>

<version>0.4.26</version>
<date>2004年5月13日</date>

<chapter>
<title>简介</title>
<section>
<body>

<p>
本指南适用于在基于服务器的环境中使用Gentoo Linux和其他有意增强安全性的用户。
</p>

<note>
阅读完本指南后如果感觉意犹未尽，请移架到<uri link="http://www.gentoo.org/proj/en/hardened/">强化Gentoo计划</uri>
</note>

</body>
</section>

<!-- 
<section>
<title>Enhancements for future releases of this Guide:</title>
<body>

<p>
In version 0.6 (Backup)
</p>
<ul>
<li>Arpwatch</li>
<li>Full system backup using Systemimager</li>
<li>Partial backup using tar</li>
<li>Backing up postgres</li>
</ul>


<p>
In version 0.8 (Penetration testing)
</p>
<ul>
<li>Remote audits</li>
<li>Network audits</li>
<li>Host audits</li>
<li>Software audits</li>
</ul>

<p>
In version 1.0 (After a compromise)
</p>
<ul>
<li>How to report an incident</li>
<li>Forensics analysis</li>
<li>Creating an image of the system without destroying evidence (Using dd)</li>
<li>Trap and trace (Using tcpdump)</li>
<li>.. More to come ..</li>
<li>Restoring system</li>
</ul>

<note>
Please note that each version concentrates on one subject at a time.  This is for
quality assurance purposes.
</note>

</body>
</section>
-->
</chapter>

<chapter>
<title>安装前的考虑</title>
<section>
<title>物理安全</title>
<body>

<p>
如果攻击者可以使用你的机器，任何安全措施都可以轻松绕过。确保你的硬件不能随意接触。
比如可以放在加锁的壁橱里。加锁的机箱也不错。要达到最高级别的安全，
应设置BIOS使之只可从你的硬驱引导，而不允许从光驱软驱引导。对缺乏安全感的人，
启用BIOS密码是个不错的主意。对笔记本用户亦然。
</p>

</body>
</section>
<section>
<title>守护程序/服务规划</title>
<body>

<p>
为机器上应该或打算运行的服务做好文档。这样有助于你为系统构成更好的分区方案，
亦可简化入侵检测策略。当然如果只有一台或为数不多的机台电脑，你又是唯一使用它们的人，
那文档就大可不必了。例如，如果该机将用作防火墙，那它除了可能sshd外，
不应运行<e>任何</e>其他服务。
</p>

<p>
记下这点及sshd的当前版本，这样在他人发现了sshd的安全漏洞时有助于你追踪需要升级的系统。
也可帮你决定哪些人应该有权访问系统。
</p>

</body>
</section>
<section>
<title>分区方案</title>
<body>

<p>
黄金法则:
</p>

<ul>
<li>
  任何用户可写的目录树(<path>/home</path>、<path>/tmp</path>和<path>/var</path>)
  应放在单独的分区上并使用磁盘配额。Portage编译文件时使用<path>/var/tmp</path>，
  所以这个分区要大一点。这样降低了用户填满<path>/</path>挂载点的风险。
</li>
<li>
  任何你准备安装非发行软件的目录树应放在单独的分区上。根据<uri
  link="http://www.pathname.com/fhs/">文件目录层次标准</uri>, 应为
  <path>/opt</path>或<path>/usr/local</path>。这样如果你需要重装系统时，
  它们可以不受影响。
</li>
<li>
  尽量把静态数据放入单独的分区，以只读模式挂载此分区。如果实在放心不下，
  还可将其存储在比如CDROM的只读介质上。
</li>
</ul>

</body>
</section>
<section>
<title>根用户[root]</title>
<body>

<p>
root是系统中至关重要的用户，应在确属必须时才使用。如果攻击者获得root访问权限，
系统就不可靠了，只有重装一途。
</p>

<p>
root用户黄金法则
</p>

<ul>
<li>
  一定要建立一个日常使用的用户，如该用户需要有root访问权，把该用户加入wheel组。
  这使普通用户可以su为root用户。
</li>
<li>
  决不要以root运行X或其他用户应用程序。
</li>
<li>
  如以root登陆一定要使用绝对路径。root可能被欺骗运行与他意想之中不同的程序。
  例如如果有人对环境变量PATH动了手脚而root没有采用<c>su -</c>来su,
  则root使用的是该用户的路径。
</li>
<li>
  如果用户需要的是root通常可运行命令中的少数几个，考虑使用<c>sudo</c>, 但要小心。
</li>
<li>
  以root登陆后决不可离开终端。
</li>
</ul>

<p>
Gentoo对一般用户使用<c>su</c>有总体上的防范。默认的PAM设置规定wheel组的成员才可使用su。
</p>

</body>
</section>
<section>
<title>安全政策</title>
<body>

<p>
需要安全政策有几个方面的理由。
</p>

<ul>
<li>
  如果连你认为何为安全都没有定义，怎么能宣称自己有一个安全的网络呢？
</li>
<li>
  不监测网络信息流或私有home目录几乎不可能捕获潜在的攻击者、解决网络问题和进行审查。
  而在多数国家未经用户许可检查其私有的home目录是非法的。由于目前约60%的攻击来自组织内部，
  保持警惕非常必要。
</li>
<li>
  如果你从不向用户解释安全的重要性以及该如何保护自己和同事，怎能指望他们考虑到安全问题呢？
</li>
<li>
  无能如何，好的指导方针和网络文档总是值得的。
</li>
<li>
  如果不知道你的网络配置及其提供的服务，警察和联邦执法部门无法帮助你捉拿攻击者。
</li>
<li>
  遇到攻击你如何应付呢？你需要定义作什么及告诉谁。一有情况就给警察或电脑应急小组吗？
  他们不会拿你当真的。
</li>
</ul>

<p>
为不止一个用户的系统建立安全政策及教育用户的重要性说的很清楚了吧？
</p>

<p>
安全政策是一份或几分文档，它回答了诸如何人、何处、为何及如何的问题。
系统/网络的每个用户都必须通读、理解及在上面签字。花时间帮助用户理解政策、
需要他们签字的原因及违反政策的可能后果(安全政策也应该说明这点)非常重要。
这点应每年至少重复一次，一方面政策可能改变，另一方面也算对用户的提醒。
</p>

<note>
建立的政策应该易懂、切题。
</note>

<p>
政策中的大部分可以在操作系统中或通过防火墙直接实施。
</p>

<p>
安全政策至少应包含如下主题:
</p>

<ul>
<li>允许的使用</li>
<li>
  <ul>
  <li>屏保程序</li>
  <li>密码处理</li>
  <li>软件的下载和安装</li>
  <li>表明用户有否被监视的信息</li>
  <li>杀毒软件的使用</li>
  </ul>
</li>
<li>敏感信息的处理(任何书面表格，不论是纸上还是数字的l)</li>
<li>
  <ul>
  <li>保持桌面清洁，锁好机密信息</li>
  <li>离开前关机</li>
  <li>加密的使用</li>
  <li>移交钥匙给受信任的同事</li>
  <li>旅行中机密材料的处置</li>
  </ul>
</li>
<li>旅行中电脑设备的处置</li>
<li>
  <ul>
  <li>旅行和旅馆居留期间笔记本电脑的处置</li>
  </ul>
</li>
</ul>

<p>
对IT员工的政策可能与普通用户稍有不同。
</p>

<p>
安全政策可能变得庞大而关键信息反而容易被遗忘。
IT员工的政策可能包含对一般用户属于机密的信息，将其分割为较小的多个政策较为明智，
即: 允许的使用政策、密码政策、电邮政策和远程访问政策。
</p>

<p>
可在<uri link="http://www.sans.org/resources/policies/">SANS安全政策计划</uri>找到示范政策。
如果网络较小嫌这个太复杂，可以看看<uri link="http://www.cis.ohio-state.edu/cgi-bin/rfc/rfc2196.html">网站安全手册</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>安装期和安装后强化安全</title>
<section>
<title>USE标志</title>
<body>

<p>
<path>make.conf</path>文件包含用户定义的USE标志，
<path>/etc/make.profile/make.defaults</path>包含了Gentoo Linux的默认USE标志。
对本指南而言重要的标志有<c>pam</c> (Pluggable Authentication Modules 可插入鉴证模块),
<c>tcpd</c> (TCP包装)和<c>ssl</c> (Secure Socket Layer 加密套接字协议层)。
这些都在默认的USE标志集中。
</p>

</body>
</section>
<section>
<title>GRUB密码</title>
<body>

<p>
Grub支持两种不同的给其配置文件(<path>/boot/grub/grub.conf</path>)加入密码限制的方法。
一种是纯文本密码，一种是md5+salt加密。
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password changeme
</pre>

<p>
这将加上密码 <c>changeme</c> 。如果没有输入密码，将只使用默认引导设置。
</p>

<p>
要加md5密码，需要将密码转换为crypt格式(<c>man crypt</c>)，
该格式与<path>/etc/shadow</path>相同。详情参<c>man crypt</c>。
加密后的密码<e>changeme</e>看起来与这个差不多$1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs。
</p>

<p>
或者这个你可以直接在grub的shell中直接转化：
</p>

<pre caption="md5crypt in grub shell">
#<i>/sbin/grub</i>

    GRUB  version 0.92  (640K lower / 3072K upper memory)

   [ Minimal BASH-like line editing is supported.  For the first word, TAB
     lists possible command completions.  Anywhere else TAB lists the possible
     completions of a device/filename. ]

grub> <i>md5crypt</i>

Password: <i>********</i>
<codenote>Typed changeme</codenote>
Encrypted: $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.

grub> <i>quit</i>
</pre>

<p>
然后将密码拷贝粘贴到<path>/boot/grub/grub.conf</path>.
</p>

<pre caption="/boot/grub/grub.conf">
timeout 5
password --md5 $1$T7/dgdIJ$dJM.n2wZ8RG.oEiIOwJUs.
</pre>

<p>
如果是远程系统要不通过键盘交互重启的话，5秒超时非常方便。
执行<c>info grub</c>学习更多grub密码方面的知识。
</p>

</body>
</section>
<section>
<title>LILO密码</title>
<body>

<p>
LILO也支持两种处理密码的方式：全局和每映像，都是未加密的文本。
</p>

<p>
全局密码在配置文件的开始设定：
</p>

<pre caption="/etc/lilo.conf">
password=changeme
restricted
delay=3
</pre>

<p>
否则只要加到某个映像的设置中。
</p>

<pre caption="/etc/lilo.conf">
image=/boot/bzImage
      read-only
      password=changeme
      restricted
</pre>

<p>
若没有输入<c>restricted</c>选项，则LILO每次都会提示输入密码。
</p>

<p>
要把新信息存入<path>lilo.conf</path>，需要运行<c>/sbin/lilo</c>.
</p>

</body>
</section>
<section>
<title>限制控制台的使用</title>
<body>

<p>
<path>/etc/securetty</path>文件允许你指明root可以从那些<c>tty</c>
(终端)设备登录。
</p>

<p>
建议你把除 <c>vc/1</c> 外的其他行都注释掉。
这样可以保证root仅可登录一次而且只能使从一个终端上。
</p>

<note>
wheel组中用户还是可以在其他TTY上 <c>su -</c> 为root。
</note>

<pre caption="/etc/securetty">
vc/1
</pre>

</body>
</section>
</chapter>

<chapter>
<title>更多的日志</title>
<section>
<body>

<p>
应该加上额外的日志以捕获可以提醒你正在发生攻击或已被攻破的警告和错误消息。
攻击者攻击前常常先扫描或探测网络。
</p>

<p>
日志文件的易读和易管理性也很关键。安装时Gentoo Linux允许你从三种不同的日志程序中选择。
</p>

</body>
</section>
<section>
<title>日志: Syslogd</title>
<body>

<p>
Syslogd是Linux和Unix整体而言上最常用的日志程序。
它并不自带日志至循环，这一功能可以通过定时任务运行<path>/usr/sbin/logrotate</path>
处理，在<path>/etc/logrotate.conf</path>中配置。运行日志循环的频度应取决于系统负载。
</p>

<p>
下面是增加了一些功能的标准<path>syslog.conf</path>。
我们注释掉了 <c>cron</c> and <c>tty</c> 几行，增加了远程日至服务器。
为了进一步提高安全性，可以在两个地方保留日志。
</p>

<pre caption="/etc/syslog.conf">
#  /etc/syslog.conf     syslogd配置文件.
#
#                       参考syslog.conf(5) man手册页以获取更多的信息
#                       取自Debian, 目前我们使用这个
#                       Daniel Robbins, 5/15/99

#
# 首先，一些标准的日志文件。由工具记录
#

auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
cron.*                         /var/log/cron.log
daemon.*                        -/var/log/daemon.log
kern.*                          -/var/log/kern.log
lpr.*                           -/var/log/lpr.log
mail.*                          /var/log/mail.log
user.*                          -/var/log/user.log
uucp.*                          -/var/log/uucp.log
local6.debug                    /var/log/imapd.log

#
# 邮件系统日志。将其分开以便编写脚本分析这些文件
#
mail.info                       -/var/log/mail.info
mail.warn                       -/var/log/mail.warn
mail.err                        /var/log/mail.err

# INN新闻系统日志
#
news.crit                       /var/log/news/news.crit
news.err                        /var/log/news/news.err
news.notice                     -/var/log/news/news.notice

#
# 一些 `照单全收' 的日志文件。
#
*.=debug;\
        auth,authpriv.none;\
        news.none;mail.none     -/var/log/debug
*.=info;*.=notice;*.=warn;\
        auth,authpriv.none;\
        cron,daemon.none;\
        mail,news.none          -/var/log/messages

#
# 紧急情况和提醒发送给已登录的所有用户
#
*.emerg                         *
*.=alert                        *

#
# 我喜欢把消息显示在终端上，不过只在一个我通常不用的虚终端上
#
daemon,mail.*;\
       news.=crit;news.=err;news.=notice;\
       *.=debug;*.=info;\
       *.=notice;*.=warn       /dev/tty8

# 设置远端日志服务器
*.*                        @logserver

# /dev/xconsole命名管道用于`xconsole'工具。要使用它，
# 必须以`-file'选项调用`xconsole':
#
#    $ xconsole -file /dev/xconsole [...]
#
# 备注: 调整下面的列表，否则网站够忙时, 你就麻烦缠身了
#
# daemon.*,mail.*;\
#       news.crit;news.err;news.notice;\
#       *.=debug;*.=info;\
#       *.=notice;*.=warn       |/dev/xconsole

local2.*                -/var/log/ppp.log
</pre>

<p>
攻击者非常可能想编辑或删除日志文件掩盖其行踪。
在不同机器上的一或多个日至服务器上记录日志可以增加其难度。
可以通过执行<c>man syslog</c>了解更多syslogd的知识。
</p>

</body>
</section>
<section>
<title>Metalog</title>
<body>

<p>
Frank Dennis的<uri link="http://metalog.sourceforge.net">Metalog</uri>
不可写入远端服务器，但在性能和记录的灵活性方面独擅胜场。它可按程序名、紧急度和
设施(如syslogd)记录日志，自带正则表达式匹配，还可在发现特定模式后启动外部脚本。
特别便于在需要时采取行动。
</p>

<p>
标准配置基本够用。如果想在发生密码失败时收到邮件通知，使用如下脚本。
</p>

<p>
对postfix:
</p>

<pre caption = "postfix的/usr/local/sbin/mail_pwd_failures.sh">
#! /bin/sh
echo "$3" | mail -s "Warning (program : $2)" root
</pre>

<p>
对qmail:
</p>

<pre caption = "qmail的/usr/local/sbin/mail_pwd_failures.sh">
#!/bin/sh
echo "To: root
Subject:Failure (Warning: $2)
$3
" | /var/qmail/bin/qmail-inject -f root
</pre>

<p>
记得通过调用<c>/bin/chmod +x /usr/local/sbin/mail_pwd_failures.sh</c>
使这个脚本可执行。
</p>

<p>
然后去掉<path>/etc/metalog/metalog.conf</path>中`密码失败'下命令行的注释，像这样:
</p>

<pre caption="/etc/metalog/metalog.conf">
command  = "/usr/local/sbin/mail_pwd_failures.sh"
</pre>

</body>
</section>
<section>
<title>Syslog-ng</title>
<body>

<p>
Syslog-ng提供了一些与syslog和metalog相同的功能，有少许差别。
它可按级别和内容(类似于metalog)过滤消息，提供了和syslog相似的远程日志，
处理来自syslogd的日志(甚至是来自Solaris的流)，写到TTY, 执行程序，还可充当日志服务器。
基本而言兼有其他两个之长，并有高级的配置功能。
</p>

<p>
稍加修改的一个经典配置文件
</p>

<pre caption="/etc/syslog-ng/syslog-ng.conf">
options { long_hostnames(off); sync(0); };

# 读取日志的源
source src { unix-stream("/dev/log"); internal(); };
source kernsrc { file("/proc/kmsg"); };

# 定义目的地
destination authlog { file("/var/log/auth.log"); };
destination syslog { file("/var/log/syslog"); };
destination cron { file("/var/log/cron.log"); };
destination daemon { file("/var/log/daemon.log"); };
destination kern { file("/var/log/kern.log"); };
destination lpr { file("/var/log/lpr.log"); };
destination user { file("/var/log/user.log"); };
destination mail { file("/var/log/mail.log"); };

destination mailinfo { file("/var/log/mail.info"); };
destination mailwarn { file("/var/log/mail.warn"); };
destination mailerr { file("/var/log/mail.err"); };

destination newscrit { file("/var/log/news/news.crit"); };
destination newserr { file("/var/log/news/news.err"); };
destination newsnotice { file("/var/log/news/news.notice"); };

destination debug { file("/var/log/debug"); };
destination messages { file("/var/log/messages"); };
destination console { usertty("root"); };
destination console_all { file("/dev/tty12"); };
destination xconsole { pipe("/dev/xconsole"); };

# 创建过滤器
filter f_auth { facility(auth); };
filter f_authpriv { facility(auth, authpriv); };
filter f_syslog { not facility(authpriv, mail); };
filter f_cron { facility(cron); };
filter f_daemon { facility(daemon); };
filter f_kern { facility(kern); };
filter f_lpr { facility(lpr); };
filter f_mail { facility(mail); };
filter f_user { facility(user); };
filter f_debug { not facility(auth, authpriv, news, mail); };
filter f_messages { level(info..warn)
	and not facility(auth, authpriv, mail, news); };
filter f_emergency { level(emerg); };

filter f_info { level(info); };
filter f_notice { level(notice); };
filter f_warn { level(warn); };
filter f_crit { level(crit); };
filter f_err { level(err); };
filter f_failed { match("failed"); };
filter f_denied { match("denied"); };

# 把过滤器和目的地连接起来
log { source(src); filter(f_authpriv); destination(authlog); };
log { source(src); filter(f_syslog); destination(syslog); };
log { source(src); filter(f_cron); destination(cron); };
log { source(src); filter(f_daemon); destination(daemon); };
log { source(kernsrc); filter(f_kern); destination(kern); };
log { source(src); filter(f_lpr); destination(lpr); };
log { source(src); filter(f_mail); destination(mail); };
log { source(src); filter(f_user); destination(user); };
log { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };
log { source(src); filter(f_mail); filter(f_warn); destination(mailwarn); };
log { source(src); filter(f_mail); filter(f_err); destination(mailerr); };

log { source(src); filter(f_debug); destination(debug); };
log { source(src); filter(f_messages); destination(messages); };
log { source(src); filter(f_emergency); destination(console); };

# 默认日志
log { source(src); destination(console_all); };
</pre>

<p>
容易配置也容易在配置文件中漏掉些东西，因为它太大了。作者还承诺了诸如加密、鉴证、
压缩和MAC(强制访问控制)的一些额外功能。加上这些选项，可说是网络日志的极品。
因为攻击者无法偷窥日志了。
</p>

<p>
而syslog-ng还有其他长处: 无需以root来运行。
</p>

</body>
</section>
</chapter>

<chapter>
<title>挂载分区</title>
<section>
<body>

<p>
挂载<c>ext2</c>、<c>ext3</c> 或<c>reiserfs</c> 分区时，可在<path>/etc/fstab</path>
中施加几个选项。它们是:
</p>

<ul>
<li>
  <c>nosuid</c> - 忽略SUID位使之与一般文件无易
</li>
<li>
  <c>noexec</c> - 防止执行来自此分区的文件
</li>
<li>
  <c>nodev</c> - 忽略设备
</li>
</ul>

<p>
不幸的是这些设置可以通过执行间接路径轻松绕过。然而把 <path>/tmp</path>
设为noexec可以阻止约99%的有害脚本，因为它们被设计成直接从<path>/tmp</path>执行才能为害。
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp reiserfs notail,noatime,nodev,nosuid,noexec 0 0
/dev/sda5 /var reiserfs notail,noatime,nodev 0 0
/dev/sda6 /home reiserfs notail,noatime,nodev,nosuid 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro 0 0
/dev/cdroms /cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<warn>
把 <path>/tmp</path> 设为 <c>noexec</c> 模式可能会妨碍某些脚本正常执行。
</warn>

<note>
磁盘配额参<uri link="#doc_chap6_sect3">配额部分</uri>.
</note>

<note>
我没有设 <path>/var</path> 为 <c>noexec</c> 或 <c>nosuid</c> 尽管通常从不从这个挂载点执行。
理由是qmail安装在 <path>/var/qmail</path>，它必须执行及访问一个SUID文件。
我把<path>/usr</path>设为只读，因为除更新Gentoo外我从不往那里写入任何东西。
这样我把文件系统重挂为读写模式，更新，再重挂。
</note>

<note>
就算你不用qmail, Gentoo还是需要你设置 <path>/var/tmp</path> 的执行位，
因为ebuilds在那里完成。如果你坚持要把 <path>/var</path> 设为 <c>noexec</c> 模式，
可以设置一个替代的路径。
</note>

</body>
</section>
</chapter>

<chapter>
<title>用户/组限制</title>
<section>
<title>/etc/security/limits.conf</title>
<body>

<p>
要防止本地DoS或处理一个组或用户的最大登录数，控制资源限制是一个非常有效的途径。
</p>

<pre caption="/etc/security/limits.conf">
*    soft core      0
*    hard core      0
*    hard nproc     15
*    hard rss       10000
*    -    maxlogins 2
@dev hard core      100000
@dev soft nproc     20
@dev hard nproc     35
@dev -    maxlogins 10
</pre>

<p>
如果发现自己想设 <c>nproc</c> 或 <c>maxlogins</c> 为0，可能还不如删掉这个用户。
上面的例子设定了 <c>dev</c> 组的进程，核心文件和<c>maxlogins</c>的设置。
其他的设为一个默认值
</p>

<note>
<path>/etc/security/limits.conf</path> 是PAM包的一部分，仅适用于使用了PAM的包。
</note>

</body>
</section>
<section>
<title>/etc/limits</title>
<body>

<p>
<path>/etc/limits</path> 与限制文件<path>/etc/security/limits.conf</path>非常相似。
唯一的区别在于格式，仅对用户或通配符起作用(对组无效)。看看得体的配置:
</p>

<pre caption="/etc/limits">
*   L2 C0 U15 R10000
kn L10 C100000 U35
</pre>

<p>
这里我们设定了默认设置并为用户kn采用了特定的设置。限制是sys-apps/shadow包的一部分。
如果在 <path>make.conf</path> 禁用了<c>pam</c> 或者没有恰当的配置PAM，
在这个文件中设定限制就没有必要了。
</p>

</body>
</section>
<section>
<title>配额</title>
<body>

<warn>
确保你采用文件系统支持配额。ReiserFS就不支持。
</warn>

<p>
在文件系统上施加限额可以避免用户塞满磁盘甚至根本不许写入。限额在内核中启用并加入挂载点。
该内核选项在内核配置的<c>File systems->Quota support</c>下打开。采用如下的设置，
重建内核并重启到新内核。
</p>

<p>
敲入 <c>emerge quota</c> 开始安装配额。然后修改 <path>/etc/fstab</path>
给你想限制磁盘使用的分区增加<c>usrquota</c>和<c>grpquota</c>，如下例:
</p>

<pre caption="/etc/fstab">
/dev/sda1 /boot ext2 noauto,noatime 1 1
/dev/sda2 none swap sw 0 0
/dev/sda3 / reiserfs notail,noatime 0 0
/dev/sda4 /tmp ext3 notail,noatime,nodev,nosuid,noexec,usrquota,grpquota 0 0
/dev/sda5 /var ext3 notail,noatime,nodev,usrquota,grpquota 0 0
/dev/sda6 /home ext3 notail,noatime,nodev,nosuid,usrquota,grpquota 0 0
/dev/sda7 /usr reiserfs notail,noatime,nodev,ro	0 0
/dev/cdroms/cdrom0 /mnt/cdrom iso9660 noauto,ro 0 0
proc /proc proc defaults 0 0
</pre>

<p>
在开启了配额的每个分区上创建配额文件(<path>quota.user</path>和<path>quota.group</path>)，
将其放在分区的根目录中。
</p>

<pre caption="Creating the quota files">
# <i>touch /tmp/quota.user</i>
# <i>touch /tmp/quota.group</i>
# <i>chmod 600 /tmp/quota.user</i>
# <i>chmod 600 /tmp/quota.group</i>
</pre>

<p>
这一步必须在启用了配额的每个分区上完成。增加和配置配额文件后，
还要把<c>quota</c>脚本加入到引导运行级。
</p>

<pre caption="Adding quota to the boot runlevel">
# <i>rc-update add quota boot</i>
</pre>

<p>
现在我们配置系统以每周检查配额一次，在 <path>/etc/crontab</path> 中加入下行:
</p>

<pre caption="Adding quota check to crontab">
0 3 * * 0 /sbin/quotacheck -avug.
</pre>

<p>
重启，是时候设置用户和组配额了。<c>edquota -u kn</c> 将打开$EDITOR中定义的编辑器
(默认是nano)让你编辑用户kn的配额。<c>edquota -g</c>大体相同，编辑组配额。
</p>

<pre caption="Setting up quota's for user kn">
Quotas for user kn:
/dev/sda4: blocks in use: 2594, limits (soft = 5000, hard = 6500)
         inodes in use: 356, limits (soft = 1000, hard = 1500)
</pre>

<p>
进一步的细节参考 <c>man edquota</c> 或 <uri
link="http://www.tldp.org/HOWTO/mini/Quota.html">配额小指南</uri>.
</p>

</body>
</section>
<section>
<title>/etc/login.defs</title>
<body>

<p>
如果政策要求用户每两周改变一次密码，把 <c>PASS_MAX_DAYS</c> 的值改为14，
<c>PASS_WARN_AGE</c> 改为7。建议使用密码龄因为暴力方法可以找出任何密码，
只是迟早的问题。鼓励将 <c>LOG_OK_LOGINS</c> 设为yes。
</p>

</body>
</section>
<section>
<title>/etc/login.access</title>
<body>

<p>
<path>login.access</path> 文件也是sys-apps/shadow包的一部分，给出了登录访问控制表。
该表用于根据用户名，组名或主机名控制谁可以谁不能登录。按默认所有系统的用户都可以登录，
所以该文件全部由注释和示例组成。无论是服务器还是工作站，我们建议设置该文件以免除你
(管理员)之外的其他人访问控制台。
</p>

<note>
这个设置不适用于root。
</note>

<pre caption="/etc/login.access">
-:ALL EXCEPT wheel sync:console
-:wheel:ALL EXCEPT LOCAL .gentoo.org
</pre>

<impo>
配置这些选项时要小心，如果你没有root访问权限，一旦出错你将无法访问机器。
</impo>

<note>
这些设置不适用于SSH，因为默认SSH并不执行<c>/bin/login</c>。可以在
 <path>/etc/ssh/sshd_config</path> 中使用 <c>UseLogin yes</c> 来打开。
这样SSH就会使用login，设置对其就生效了。
</note>

<p>
这样设置登录访问使wheel组成员既可本地登录亦可从gentoo.org域登录。
可能过于杞人忧天了，不过有备无患啊！
</p>

</body>
</section>
</chapter>

<chapter>
<title>文件访问权限</title>
<section>
<title>其他人可读</title>
<body>

<p>
一般用户不可拥有配置文件或密码的访问权。攻击者可能从数据库或网站偷窃密码利用密码
歪曲甚而删除资料。这正是访问权限正确的重要性之所在。如果你能肯定某个文件仅为root使用，
设置其访问权限为<c>0600</c>，并通过<c>chown</c>将此文件指派给正确的用户。
</p>

</body>
</section>
<section>
<title>其他人/组成员可写</title>
<body>

<pre caption="Finding world-writable files and directories">
# <i>/usr/bin/find / -type f \( -perm -2 -o -perm -20 \) \
   -exec ls -lg {} \; 2>/dev/null >writable.txt</i>
# <i>/usr/bin/find / -type d \( -perm -2 -o -perm -20 \) \
   -exec ls -ldg {} \; 2>/dev/null >>writable.txt</i>
</pre>

<p>
这将创建一个包含了所有组成员或其他人有写权限的文件的巨大文件。检查权限，
在这些文件上执行<c>/bin/chmod o-w</c> 以消除其他人的写权限。
</p>

</body>
</section>
<section>
<title>SUID/SGID文件</title>
<body>

<p>
设了SUID或SGID位的文件允许以文件<e>所有者</e>或组而不是运行者的权限来执行。
通常这些位用于必须以root权限运行才能完成功能的文件。这些文件可能导致本地root安全泄漏
(如果其包含安全漏洞)。这样非常危险，要不惜一切代价避免带SUID或SGID位的文件。
如果你不用它们，对他们<c>chmod 0</c>或者干脆unmerge包含它们的包(用<c>qpkg -f</c>
检查它们所属的包。如果还没有qpkg, 只需<c>emerge gentoolkit</c>)。否则的话只有用
<c>chmod -s</c> 关闭SUID位。
</p>

<pre caption="Finding setuid files">
# <i>/usr/bin/find / -type f \( -perm -004000 -o -perm -002000 \) \
  -exec ls -lg {} \; 2>/dev/null >suidfiles.txt</i>
</pre>

<p>
这会创建一个包含所有SUID/SGID文件列表的文件。
</p>

<pre caption="List of setuid binaries">
/bin/su
/bin/ping
/bin/mount
/bin/umount
/var/qmail/bin/qmail-queue
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/crontab
/usr/bin/chage
/usr/bin/expiry
/usr/bin/sperl5.6.1
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/gpasswd
/usr/bin/procmail
/usr/bin/suidperl
/usr/lib/misc/pt_chown
/usr/sbin/unix_chkpwd
/usr/sbin/traceroute
/usr/sbin/pwdb_chkpwd
</pre>

<p>
默认情况下Gentoo Linux没有太多SUID文件(取决于你装的是什么)，
但你可能会得到类似上面的列表。
对<c>ping</c>, <c>mount</c>, <c>umount</c>, <c>chfn</c>, <c>chsh</c>,
<c>newgrp</c>, <c>suidperl</c>, <c>pt_chown</c> 和 <c>traceroute</c>
每个文件运行<c>chmod -s</c>以关闭SUID位。不要移去<c>su</c>,
<c>qmail-queue</c> 或 <c>unix_chkpwd</c>的SUID位，否则你不能SU或接收邮件了。
移去SUID位后，普通用户(或者攻击者)就不可能通过它们来获取root访问权限了。
</p>

<p>
我的系统中有SUID位的文件只有 <c>su</c>, <c>passwd</c>,
<c>gpasswd</c>, <c>qmail-queue</c>, <c>unix_chkpwd</c> 和 <c>pwdb_chkpwd</c>。
如果你运行X的话，可能会有更多，因为X需要该权限。
</p>

</body>
</section>
</chapter>

<chapter>
<title>PAM (可插入鉴证模块)</title>
<section>
<body>

<p>
PAM是一套共享库，它提供了在程序中进行鉴证的一种可供选择的途径。<c>pam</c>
USE标志默认是打开的。因此Gentoo Linux中的PAM设置一般已相当合理，当然百尺竿头，
还可更进一步。首先安装cracklib。
</p>

<pre caption="Installing cracklib">
# <i>emerge cracklib</i>
</pre>

<pre caption="/etc/pam.d/passwd">
auth	 required pam_unix.so shadow nullok
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 
password required pam_unix.so md5 use_authtok
session	 required pam_unix.so
</pre>

<p>
这样加入cracklib。cracklib保证用户密码不少于8位、至少两位数字、
两位其他并与前次的密码至少有3位不同。这样促使用户选择好的密码(密码政策)。
检查<uri link="http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html/pam-6.html#ss6.3">
PAM</uri>文档以获取更多的选项。
</p>

<pre caption="/etc/pam.d/sshd">
auth	 required pam_unix.so nullok 
auth     required pam_shells.so
auth	 required pam_nologin.so
auth	 required pam_env.so
account	 required pam_unix.so
password required pam_cracklib.so difok=3 retry=3 minlen=8 dcredit=2 ocredit=2 use_authtok
password required pam_unix.so shadow md5
session	 required pam_unix.so
session	 required pam_limits.so
</pre>

<p>
在<path>/etc/pam.d</path>中没有配置PAM文件的服务将使用
<path>/etc/pam.d/other</path>中的规则。默认设置是<c>deny</c>，这是妥当的。
不过我喜欢多一点日志，这正是我加上<c>pam_warn.so</c>的原因。最后的配置是
<c>pam_limits</c>，它受<path>/etc/security/limits.conf</path>控制。参
<uri link="#doc_chap6_sect1">/etc/security/limits.conf section</uri>
以了解更多这些设置方面的内容。
</p>

<pre caption="/etc/pam.d/other">
auth     required pam_deny.so
auth     required pam_warn.so
account  required pam_deny.so
account  required pam_warn.so
password required pam_deny.so
password required pam_warn.so
session  required pam_deny.so
session  required pam_warn.so
</pre>

</body>
</section>
</chapter>

<chapter>
<title>TCP包装</title>
<section>
<body>

<p>
是一种控制对通常由inetd运行的服务的访问的方式。Gentoo没有inetd，
但xinetd和其他服务也可以使用它。
</p>

<note>
此服务在其服务器参数(xinetd中)应执行tcpd。参关于xinetd的章节以获取更多信息。
</note>

<pre caption="/etc/hosts.deny">
ALL:PARANOID
</pre>

<pre caption="/etc/hosts.allow">
ALL: LOCAL @wheel
time: LOCAL, .gentoo.org
</pre>

<p>
容易发现其格式与<path>/etc/login.access</path>非常相似。Tcpd支持特定的服务，
它们在安全的不同领域发挥作用。这些设置只适用于使用tcp包装的服务。
</p>

<p>
也可能在访问服务时(可在激活拨入用户的中继时使用)执行命令，但不推荐这样做，
因为常常人们在张罗着解决问题时却制造了更多的问题。比如你配置一个脚本，
每当拒绝规则触发时发送邮件，可攻击者可以通过不断触发这个拒绝规则发起DoS(拒绝服务)攻击。
大量I/O和邮件应劫而生，所以不要这样做。参阅 <c>man 5 hosts_access</c> 以获取更多的信息。
</p>

</body>
</section>
</chapter>

<chapter>
<title>内核安全</title>
<section>
<title>除去一些功能</title>
<body>

<p>
配置内核的基本原则是不需要的通通清除。内核更紧凑，
可能隐藏在设备驱动和其他功能中的弱点也消除了。
</p>

<p>
也要考虑关闭可加载模块支持。尽管没有这个功能也可能加入模块(root工具包)，
但普通攻击者经由内核模块安装root工具包要困难些。
</p>

</body>
</section>
<section>
<title>/proc (内核旗标)</title>
<body>

<p>
许多内核参数都可通过 <path>/proc</path> 文件系统或使用 <c>sysctl</c> 修改。
</p>

<p>
要运行中动态更改内核参数你必须在内核中定义 <c>CONFIG_SYSCTL</c> 。
这是标准 2.4 内核的默认设置。
</p>

<pre caption="Drop ping packets">
# <i>/bin/echo "1" > /proc/sys/net/ipv4/icmp_echo_ignore_all</i>
</pre>

<p>
这会使内核忽略所有又称为ICMP类型0消息的ping消息。
这样做的原因是带有ICMP消息的IP包可能包含你意想不到的其他信息的有效负载。
管理员用ping作为诊断工具，如果不能ping他们会抱怨。外来者没有理由可以ping。
但是有时内部用户可以ping很方便。这可以通过在防火墙中禁止ICMP类型0消息来解决。
</p>

<pre caption="Ignore broadcast pings">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</i>
</pre>

<p>
这禁止响应ICMP广播，可以避免Smurf攻击。
Smurf攻击的原理是往一个网络的广播地址发送一个ICMP类型0(ping)消息。
攻击者一般使用伪装的源地址。该网络上的所有电脑都会应答这个ping消息，
这样就淹没了被伪装的主机。
</p>

<pre caption="Disable source routed packets">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_source_route</i>
</pre>

<p>
不要接受源路由包。攻击者可能利用源路由来产生伪装成产生于你的网络内部的通信量，
而实际上它是在反向路由回产生的地方，这样攻击者可以危及你网络的安全。
源路由极少用于合法用途，因此禁用之。
</p>

<pre caption="Disable redirect acceptance">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/conf/all/accept_redirects</i>
</pre>

<p>
禁用ICMP重定向。它可用于修改你的路由表，可能是恶意的。
</p>

<pre caption="Protect against bad error messages">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses</i>
</pre>

<p>
启用响应伪错误信息保护。
</p>

<pre caption="Enable reverse path filtering">
# <i>for i in /proc/sys/net/ipv4/conf/*; do
        /bin/echo "1" > $i/rp_filter
done</i>
</pre>

<note>
如果打开IP转发，也会得到这个结果。
</note>

<p>
打开逆向路径过滤。这可以保证包使用合法源地址，它自动拒绝源地址的路由表项与进入的网络接口不匹配的入包。
这样可以防止IP伪装，有安全优势。
</p>

<warn>
但是如果使用不对称路由(从你到你某个主机的包与从该主机到你的包采用不同的路径)
或者你使用不同接口上有几个IP地址的无路由主机，启用逆向路径过滤会有问题。
</warn>

<pre caption="Log all spoofed, source routed and redirect packets">
# <i>/bin/echo "1" &gt; /proc/sys/net/ipv4/conf/all/log_martians</i>
</pre>

<p>
记录IP伪装的包、源路由包和重定向包。
</p>

<pre caption="Deactivate IP forwarding">
# <i>/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
确保关闭了IP转发。只有对多宿主主机我们才需要它。
</p>

<p>
机器重启后所有这些设置都会被重设，因此建议把它们加入 <path>/etc/sysctl.conf</path>。 <path>/etc/init.d/bootmisc</path> 初始化脚本会自动运行它。
</p>

<p>
<path>/etc/sysctl.conf</path> 的语法很直白。从前面提到的路径中剥去 <path>/proc/sys/</path>，
用<path>.</path>替换掉 <path>/</path> 就可以了:
</p>

<pre caption="Translating to sysctl.conf">
<comment>(Manual using echo):</comment>
/bin/echo "0" &gt; /proc/sys/net/ipv4/ip_forward

<comment>(Automatic in sysctl.conf:)</comment>
net.ipv4.ip_forward = 0
</pre>

</body>
</section>
<section>
<title>Grsecurity</title>
<body>

<p>
<uri link="http://grsecurity.net">Grsecurity</uri>的不定是Gentoo内核源代码的标准，
但默认是禁用的。用通常的方式配置内核，配置Grsecurity选项。
可用的Grsecurity选项(1.9版)的详细说明在 <uri link="/proj/en/hardened">强化Gentoo</uri> 项目网页上。
</p>

<p>
最新的<c>grsec-sources</c>提供了Grsecurity的2.*版。关于改进了的Grsecurity补丁集的更多信息，
请参阅此处的文档 <uri link="http://www.grsecurity.net/">Grsecurity主页</uri>.
</p>

</body>
</section>
<section>
<title>Kerneli</title>
<body>

<p>
<uri link="http://www.Kerneli.org">Kerneli</uri>是给现有内核增加加密的一个补丁。
打了不定后会得到如Cryptographic ciphers、摘要算法和加密环过滤等新选项。
</p>

<warn>
对最新的内核该补丁目前尚为不稳定版本，使用时多家加小心。
</warn>

</body>
</section>
<section>
<title>其他内核补丁</title>
<body>

<ul>
<li><uri link="http://www.openwall.com">OpenWall工程</uri></li>
<li><uri link="http://www.lids.org">Linux入侵检测系统</uri></li>
<li><uri link="http://www.rsbac.org">基于规则集的访问控制</uri></li>
<li>
  <uri link="http://www.nsa.gov/selinux">NSA的安全增强内核</uri>
</li>
<li><uri link="http://sourceforge.net/projects/wolk/">Wolk</uri></li>
</ul>

<p>
可能还有更多。 
</p>

</body>
</section>
</chapter>

<chapter>
<title>加强服务的安全</title>
<section>
<title>Apache</title>
<body>

<p>
Apache (1.3.26) 自带的配置文件相当不错，同样，还可改进一些地方。
比如绑定到一个地址防止泄露信息。这些是你可以在配置文件中采用的选项。
</p>

<p>
如果安装apache前在<path>/etc/make.conf</path>中没有禁用 <c>ssl</c>，
你应该有了一个可使用SSL的服务器。只需加入下行启用之:
</p>

<pre caption="/etc/conf.d/apache">
HTTPD_OPTS="-D SSL"
</pre>

<pre caption="/etc/apache/conf/apache.conf">
#Make it listen on your ip
Listen 127.0.0.1
BindAddress 127.0.0.1
#It is not a good idea to use nobody or nogroup - 
#for every service not running as root 
#(just add the user apache with group apache)
User apache
Group apache
#Will keep apache from telling about the version
ServerSignature Off
ServerTokens Prod
</pre>

<p>
Apache是以<c>--enable-shared=max</c> 和 
<c>--enable-module=all</c>编译的。这样默认会启用所有模块，
所以应在<c>LoadModule</c>节(<c>LoadModule</c> and <c>AddModule</c>)
注释掉所有你不用的模块。执行<c>/etc/init.d/apache restart</c>重启服务。
</p>

<p>
可在<uri>http://www.apache.org</uri>找到相关文档。
</p>

</body>
</section>

<section>
<title>Bind</title>
<body>

<p>
可在<uri link="http://www.isc.org/products/BIND/bind9.html">Internet Software
Consortium</uri>找到文档BIND 9 管理员参考手册也在 <path>doc/arm</path> 里面.
</p>

<p>
较新的BIND ebuilds 支持chroot到本机以外。Emerge <c>bind</c> 后按这些简答的指示:
</p>
<pre caption="改换BIND根目录">
ebuild /var/db/pkg/net-dns/bind-9.2.2-r2/bind-9.2.2-r2.ebuild config\`"
<codenote>执行以上命令前可能要改变/etc/conf.d/named中的chroot目录，
否则会使用/chroot/dns。</codenote>
<codenote>可能需要用当前版本号替换上面的版本号</codenote>
</pre>
</body>
</section>
<section>
<title>Djbdns</title>
<body>

<p>
Djbdns是一个DNS实现，起作者愿意对它的安全性
<uri link="http://cr.yp.to/djbdns/guarantee.html">赌彩</uri>。
其工作于Bind 9大有不同，但值得一试。从  <uri>http://www.djbdns.org</uri> 可以获得更多的信息。
</p>

</body>
</section>

<section>
<title>FTP</title>
<body>

<p>
一般而言，使用 FTP (文件传输协议) 不太好。它使用未加密数据，监听2个端口（通常为端口20和21），
采用攻击者爱用的匿名登录。因为FTP协议包含了几个安全问题（如密码以明文发送），
你应该使用<c>sftp</c>或HTTP。如果不得不用，尽可能增强服务的安全，做好准备。
</p>

</body>
</section>
<section>
<title>Mysql</title>
<body>

<p>
如果只需要本地应用访问 <c>mysql</c> 数据库，去掉下面行的注释。
</p>
<pre caption="禁止网络访问">
skip-networking
</pre>

<p>
禁止使用<c>LOAD DATA LOCAL INFILE</c> 命令:
</p>

<pre caption="在[mysqld]区禁止 LOAD DATA LOCAL INFILE 命令的使用">
set-variable=local-infile=0
</pre>

<p>
<c>mysql</c> 的默认安装设置的 <c>root</c> 密码为空。 
</p>

<pre caption="设定 root 密码">
<i>/usr/local/mysql/bin/mysql -u root</i> 
mysql> <i>SET PASSWORD FOR root@localhost=PASSWORD('new_password');</i>
</pre>
<note>

不从命令行［如使用<c>mysqladmin password</c>命令］改变密码是好的做法。
服务器上还有其他用户使用时这点尤为重要。
那样密码很容易通过用如 <c>ps aux</c> 
命令和查看历史文件(<path>~/.history</path>，<path>~/.bash_history</path> etc)而暴露。
</note>

<p>
接着必须删除示例数据库(test)及除本地<c>root</c>外的所有帐户。
</p>

<pre caption="删除示例数据库和非必需用户">
mysql> <i>drop database test;</i>
mysql> <i>use mysql;</i>
mysql> <i>delete from db;</i>
mysql> <i>delete from user where not (host="localhost" and user="root");</i>
mysql> <i>flush privileges;</i>
</pre>

<warn>

如果已配置好用户帐户，进行上步时要多加小心。
</warn>
</body>
</section>
<section>
<title>Proftpd</title>
<body>

<p>
Proftpd有过几个安全问题，不过似乎多数已被修补好。还是采用一些改进措施:
</p>

<pre caption="/etc/proftpd/proftpd.conf">
ServerName "My ftp daemon"
#不显示服务器身份
ServerIdent on "Go away"

#便于创建虚用户
RequireValidShell off

#使用替代的密码和组文件(passwd采用加密格式)
AuthUserFile "/etc/proftpd/passwd"
AuthGroupFile "/etc/proftpd/group"

# 权限
Umask 077

# 超时和限制
MaxInstances 30
MaxClients 10 "Only 10 connections allowed"
MaxClientsPerHost 1 "You have already logged on once"
MaxClientsPerUser 1 "You have already logged on once"
TimeoutStalled 10
TimeoutNoTransfer 20
TimeoutLogin 20

# Chroot 每个人
DefaultRoot ~

# 不要以root运行
User  nobody
Group nogroup

# 记录每次传输
TransferLog /var/log/transferlog

# 使用通配符的问题
DenyFilter \*.*/
</pre>

<p>
可在 <uri>http://www.proftpd.org</uri> 找到文档。
</p>

</body>
</section>
<section>
<title>Pure-ftpd</title>
<body>

<p>
Pure-ftpd 是原来的 trollftpd 一个分枝。Frank Dennis基于安全和功能上的考虑做了修改。
</p>

<p>
启用 <c>AUTH</c> 选项使用虚用户(觉不要使用系统帐户)。把它设为 <c>-lpuredb:/etc/pureftpd.pdb</c>
并用 <c>/usr/bin/pure-pw</c> 创建用户。
</p>

<pre caption="/etc/conf.d/pure-ftpd">
AUTH="-lpuredb:/etc/pureftpd.pdb"

## Misc. Others ##
MISC_OTHER="-A -E -X -U 177:077 -d -4 -L100:5 -I 15"
</pre>

<p>
并配置 <c>MISC_OTHER</c> 设置为不允许匿名(<c>-E</c>)，chroot每个人(<c>-A</c>),
用户不可读写以.(小数点)开头的文件(<c>-X</c>), 最大空闲时间(<c>-I</c>), 
限制递归(<c>-L</c>), 及合理的 <c>umask</c>.
</p>

<warn>
<e>不要</e> 使用 <c>-w</c> 或 <c>-W</c> 选项! 如果想建 warez 网站，您还是别往下看了！
</warn>

<p>
可在 <uri>http://www.pureftpd.org</uri> 找到文档。
</p>

</body>
</section>
<section>
<title>Qmail</title>
<body>

<p>
Qmail被认为是最安全的邮件服务器。它是带着安全考虑(甚至是过虑)写成的。默认它不允许中继，
从1996年起就没有过安全漏洞。只需 <c>emerge qmail</c> 然后去配置!
</p>
</body>
</section>
<section>
<title>Samba</title>
<body>

<p>
Samba 是与Microsoft/Novell网络共享文件的协议，不可在互联网上使用。
尽管如此还是要考虑安全问题。
</p>

<pre caption="/etc/samba/smb.conf">
[global]
  # 绑定到接口
  interfaces = eth0 10.0.0.1/32

  # 确保使用加密口令
  encrypt passwords = yes
  directory security mask = 0700

  #允许来自 10.0.0.* 的通信
  hosts allow = 10.0.0.

  # 启用用户认证 
  #( 不要使用共享模式 )
  security = user
  
  # 不允许特权帐户
  invalid users = root @wheel

  # smb显示给共享的最大值 (不是限制)
  max disk size = 102400

  # 捍卫密码政策
  min password length = 8
  null passwords = no

  # 使用( 如果加入了支持 )
  obey pam restrictions = yes
  pam password change = yes
</pre>

<p>
要确保每个共享上的权限正确设置，记得看 <uri link="http://www.samba.org">文档</uri>.
</p>

<p>
重启服务器，加入应有访问权的用户。通过 <path>/usr/bin/smbpasswd</path> 命令代 -a 参数来完成。
</p>

</body>
</section>
<section>
<title>ssh</title>
<body>

<p>
OpenSSH需要的唯一安全强化是打开基于公密钥加密的一种更强的鉴证。
太多的网站（如<uri>http://www.sourceforge.net</uri>, <uri>http://www.php.net</uri> 和 
<uri>http://www.apache.org</uri>) 的系统由于口令泄露或口令不好而遭受非法入侵。
</p>

<pre caption="/etc/ssh/sshd_config">
# 只启用版本 2
Protocol 2

# 禁止 root 登录。用户必须su为root
PermitRootLogin no

# 打开公密钥鉴证
PubkeyAuthentication yes
AuthorizedKeysFile      .ssh/authorized_keys

# 禁止 .rhost 和常规密码鉴证
RhostsAuthentication no
PasswordAuthentication no
PermitEmptyPasswords no

AllowHosts *.gentoo.org

# 只允许 wheel 或 admin 组的用户登录
AllowGroups wheel admin

# 只允许那些组中的如下用户
AllowUsers kn bs

# 日志 
SyslogFacility AUTH
LogLevel INFO

ListenAddress 127.0.0.1
</pre>

<p>
现在你的用户们只需要用如下命令创建一个密钥（在他们想从其登录的机器上)：
</p>

<pre caption="创建 DSA 密钥对">
# <i>/usr/bin/ssh-keygen -t dsa</i>
</pre>

<p>
键入密码
</p>

<pre caption="ssh-keygen的输出">
Generating public/private dsa key pair.
Enter file in which to save the key (/home/kn/.ssh/id_dsa):<i>[Press enter]</i>
Created directory '/home/kn/.ssh'.
Enter passphrase (empty for no passphrase): <i>[Enter passphrase]</i>
Enter same passphrase again: <i>[Enter passphrase again]</i>
Your identification has been saved in /home/kn/.ssh/id_dsa.
Your public key has been saved in /home/kn/.ssh/id_dsa.pub.
The key fingerprint is:
07:24:a9:12:7f:83:7e:af:b8:1f:89:a3:48:29:e2:a4 kn@knielsen
</pre>

<p>
这会在你的<path>~/.ssh/</path>目录中加入两个文件，名字是
<path>id_dsa</path> 和 <path>id_dsa.pub</path>。 
<path>id_dsa</path> 文件是你的私钥不可让他人接触。另一个文件 <path>id_dsa.pub</path> 
要派发给你有访问权的每个服务器。在<path>~/.ssh/authorized_keys</path>中把该密钥加入用户的主目录，
这样用户应该就可以登录了。
</p>

<p>
现在用户们要看好这个私钥。放在他们可以随身携带的介质上或者他们的工作站上
(把这点写入<uri  link="#doc_chap2_sect5">密码</uri>政策中).
</p>

<p>
若需要更多信息，请移架 <uri link="http://www.openssh.org">OpenSSH</uri> 网址。
</p>

</body>
</section>
<section>
<title>使用 xinetd</title>
<body>

<p>
xinetd 取代互联网服务守护程序inetd (Gentoo没用这个)。它支持基于远程主机地址和访问时间的访问控制。
它还提供了扩展日志能力，包括服务开始时间、远程主机地址、远端用户名、服务运行时间和请求的动作。
</p>

<p>
与其他服务相同，好的默认配置非常重要。但是因为 <c>xinetd</c> 
是以root运行的而且支持多种你可能不知为何物的协议，我们建议你不要使用它。
如果还是决定使用，这是加入一些安全措施的办法:
</p>

<pre caption="安装l xinetd">
# <i>emerge xinetd tcp-wrappers</i>
</pre>

<p>
编辑配置文件:
</p>

<pre caption="/etc/xinetd.conf">
defaults
{
 only_from      = localhost
 instances      = 10
 log_type       = SYSLOG authpriv info
 log_on_success = HOST PID
 log_on_failure = HOST
 cps            = 25 30
}

# 将以如下设定经由xinetd设置 pserver (cvs):
# 最多 10 个实例 (一次 10 个连接)
# 限制 pserver 只用 tcp 
# 使用用户 cvs 运行本服务
# 把接口只绑定到一个ip上
# 允许来自 10.0.0.* 的连接
# 现在开发人员使用cvs的时间从早8点到晚5点
# 使用 tpcd 包装 ( 访问控制在
# <i>/etc/hosts.allow</i>和<i>/etc/hosts.deny</i>中)
# 该机 max_load 设为 1.0
# disable 标志默认设为no, 但我还是加上了 
# 以策安全
service cvspserver
{
 socket_type    = stream
 protocol       = tcp
 instances      = 10
 protocol       = tcp
 wait           = no
 user           = cvs
 bind           = 10.0.0.2
 only_from      = 10.0.0.0
 access_times   = 8:00-17:00
 server         = /usr/sbin/tcpd
 server_args    = /usr/bin/cvs --allow-root=/mnt/cvsdisk/cvsroot pserver
 max_load       = 1.0
 log_on_failure += RECORD
 disable        = no
}
</pre>

<p>
如需更多信息，参阅 <c>man 5 xinetd.conf</c>.
</p>

</body>
</section>
<section>
<title>Vsftpd</title>
<body>

<p>
Vsftpd (非常安全的ftp的缩写)是一个小型的ftp守护程序，运行的默认配置文件相当合理。
程序很单纯，没有pureftp和proftp那么多功能(比如虚用户)
</p>

<pre caption="/etc/vsftpd">
anonymous_enable=NO
local_enable=YES

#read only
write_enable=NO

#enable logging of transfers
xferlog_std_format=YES

idle_session_timeout=20
data_connection_timeout=20
nopriv_user=nobody

chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chrootlist

ls_recurse_enable=NO
</pre>

<p>
可以看出该服务没办法单个设置权限也没有默认的chroot动作。但说道匿名设置，它相当出色。
有时需要匿名ftp服务器(用于开源共享)，这是vsftpd的拿手绝活。
</p>

</body>
</section>
<section>
<title>X</title>
<body>

<p>
按默认XFree配置成充当X服务器。这可能非常危险，因为X使用未加密的TCP连接监听X客户。
</p>

<impo>
如果不需要这个服务，禁用之！ 
</impo>

<p>
但如果你需要把你的工作站用作X服务器，要慎重使用<c>/usr/X11R6/bin/xhost</c>命令。
如果你需要不同机器上的X程序而通过网络是唯一办法是，这个就很好用了。语法是: 
<c>/usr/X11R6/bin/xhost +hostname</c>
</p>

<warn>
绝对不要使用 <c>xhost +</c> 功能! 这会允许任何客户连入并控制你的X。如果攻击者能访问X，
他就可以记录下你的键盘动作并控制你的桌面。如果不能不用，一定记得指定主机。
</warn>

<p>
更安全的办法通过用<c>startx -- -nolisten tcp</c> 启动X彻底禁用它，或者在配置文件中永久性的禁用它。
</p>

<pre caption="/usr/X11R6/bin/startx">
defaultserverargs="-nolisten tcp"
</pre>

<p>
为了保证emerge新版的XFree时 <path>startx</path> 不被覆盖，必须保护它。把下面一行加入
<path>/etc/make.conf</path>:
</p>

<pre caption = "/etc/make.conf">
CONFIG_PROTECT_MASK="/usr/X11R6/bin/startx"
</pre>

<p>
如果使用图形登录管理器，办法有所不同。
</p>

<p>
对 <c>gdm</c> (Gnome 显示管理器)
</p>

<pre caption="/etc/X11/gdm/gdm.conf">
[server-Standard]
command=/usr/X11R6/bin/X -nolisten tcp
</pre>

<p>
对 <c>xdm</c> (X 显示管理器) 和 <c>kdm</c> (Kde 显示管理器)
</p>

<pre caption="/etc/X11/xdm/Xservers">
:0 local /usr/bin/X11/X -nolisten tcp 
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Chroot和虚用户</title>
<section>
<title>Chroot</title>
<body>

<p>
Chroot服务是限制(或用户)环境使之只可访问必要内容而不访问可能导向root访问权内容的一种限制。
通过以其他用户而非<c>root</c> (<c>nobody</c>, <c>apache</c>, <c>named</c>) 来运行服务，
攻击者只能以该用户的权限来访问文件。意味着即使服务有安全缺陷，攻击者也不能获得
 <c>root</c> 访问权。
</p>

<p>
有些服务，如 <c>pure-ftpd</c> 和 <c>bind</c>，有choot功能，有些没有。如果服务支持，使用它；
否则只好自己摸索创建一个。我们看看如何创建一个choot, 以便理解choot工作的基本原理，我们用
<c>bash</c>来测试之(最佳学习方法)。
</p>

<p>
用<c>mkdir chroot</c>建立<path>/chroot</path>目录。搞清 <c>bash</c> 编译所用的动态库
(如果是用<c>-static</c>选项编译的，这一步就不必了):
</p>

<p>
下面的命令会产生<c>bash</c>所用库的列表。 
</p>

<pre caption="取得使用库的列表">
# <i>ldd /bin/bash</i>
  libncurses.so.5 => /lib/libncurses.so.5 (0x4001b000)
  libdl.so.2 => /lib/libdl.so.2 (0x40060000)
  libc.so.6 => /lib/libc.so.6 (0x40063000)
  /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</pre>

<p>
现在建立 <c>bash</c> 的环境变量。
</p>

<pre caption="为bash建立 chroot 环境">
# <i>mkdir /chroot/bash</i>
# <i>mkdir /chroot/bash/bin</i>
# <i>mkdir /chroot/bash/lib</i>
</pre>

<p>
下一步把 <c>bash</c> (<path>/lib</path>) 使用的文件复制到 chroot 后的 <path>lib</path> 并将 
bash命令复制到chroot厚的 <path>bin</path>目录。这样会建立完全相同的环境，只是功能少一点。
复制完成后试着: <c>chroot /chroot/bash</c>。如果提示说 <path>/</path>就对了!
否则，可能会告诉你缺少了什么文件。有些共享库互相依赖。
</p>

<p>
注意到在chroot内除了<c>echo</c>什么都不能用了吗？这是因为在我们的chroot环境中除
bash外什么命令都没有，<c>echo</c> 是bash的内建功能。
</p>

<p>
基本而言，要建立chroot的服务方法相同。
唯一的区别服务有时依赖于设备和<path>/etc</path>中配置文件。只需将他们复制到chroot后的环境
(设备可用 <c>cp -a</c> 复制)，编辑 init 脚本以在执行前使用 chroot。
有时很难搞清服务使用了的设备和配置文件。这时 <c>strace</c> 命令九派上用场了。用
<c>/usr/bin/strace</c> bash 启动服务，查找open, read, stat可能还有connect。
这可以给你要拷贝那些文件的线索。但多数情况下只需复制passwd文件（编辑该拷贝，删除与本服务无关的用户),
<path>/dev/zero</path>, <path>/dev/log</path> 和 <path>/dev/random</path>.
</p>

</body>
</section>
<section>
<title>虚拟服务器</title>
<body>

<p>
通过虚拟服务器环境是建立更安全的环境的又一途径，它建立现有Linux的一个拷贝，在虚拟模式中引导之。
意味着如果该服务器被攻破，攻破的并非实际的安装，而只是该虚拟服务器。
</p>

<p>
虚拟服务器的示例:
</p>

<ul>
<li>
  <uri link="http://user-mode-linux.sourceforge.net">用户模式（User-Mode） Linux</uri> 及
  <uri link="http://www.gentoo.org/doc/uml.html">用户模式  Linux</uri>指南。
</li>
</ul>

</body>
</section>
</chapter>

<chapter>
<title>防火墙</title>
<section>
<title>防火墙</title>
<body>

<p>
人们常常认为防火墙提供了终极安全，错了。大多数情况下配置不良的防火墙比没有防火墙更不安全。
防火墙也是软件，应该象对待其他软件一样对待它，因为它同样可能包含bug。
</p>

<p>
所以实施前要想清楚! 是否真有必要？如果是，要写出它如何工作方式，类型，操作人员的政策。
还是现读完本指南。
</p>

<p>
防火墙用于两种目的:
</p>

<ul>
<li>把用户(蠕虫/攻击者)挡在外面</li>
<li>把用户(雇员/儿童)拦在里面</li>
</ul>

<p>
基本而言有三种类型的防火墙:
</p>

<ul>
<li>包过滤Packet filtering</li>
<li>回路中继</li>
<li>应用网关</li>
</ul>

<p>
防火墙应是专用机器，没有运行任何服务(或者只运行 <c>sshd</c> )，且用本指南推荐的方法强化安全。
</p>

</body>
</section>
<section>
<title>包过滤</title>
<body>

<p>
所有网络交通都是以包的形式。大量的通讯也分割成小的包以便于处理并在到达目的地后重新组装起来。 
每个包的包头中办好了如何投递及投递到那里的信息。包过滤防火墙正是使用这些信息。过滤基于:
</p>

<ul>
<li>根据源／目的IP地址放行或拒绝包</li>
<li>根据源／目的端口放行或拒绝包</li>
<li>根据协议放行或拒绝包</li>
<li>根据特定协议内的标志放行或拒绝包</li>
</ul>

<p>
基本而言过滤的依据是包头中的所有数据而非包内容。
</p>

<p>
弱点:
</p>

<ul>
<li>
  包中的地址信息有可能是假IP地址，即我们所说的发送者 <e>伪装[spoofed]</e> 的。
</li>
<li>
  放行包中的数据活请求可能含有可供攻击者用于利用防火墙上或防火墙后服务的已知bug的数据。
</li>
<li>通常单个失败点</li>
</ul>

<p>
长处:
</p>

<ul>
<li>简单、易实施</li>
<li>
  可在可能的攻击发生前发出警告(即，通过检测断头扫描)
</li>
<li>适于阻止 SYN 攻击</li>
</ul>

<p>
Linux上自由／免费包过滤程序举例:
</p>

<ul>
<li><uri link="http://www.iptables.org">Iptables</uri></li>
<li>
  <uri link="http://www.linuxdocs.org/HOWTOs/IPCHAINS-HOWTO.html">Ipchains</uri>
</li>
<li><uri link="http://www.smoothwall.org">SmoothWall</uri></li>
</ul>

</body>
</section>
<section>
<title>回路中继</title>
<body>

<p>
或称回路层网关，是在允许数据交换前先验证连接的一种防火墙。
这意味着不是根据包头来放行或拒绝包，而是在开始会话允许数据交换前，
根据可配置的规则验证两端之间的连接的有效性。过滤基于:
</p>

<ul>
<li>源/目的 IP 地址</li>
<li>源/目的端口</li>
<li>一段时间</li>
<li>协议</li>
<li>用户</li>
<li>口令</li>
</ul>

<p>
所有通讯都被验证、监视，不想要的通讯会被丢掉。
</p>

<p>
弱点:
</p>

<ul>
<li>
  工作在传输层，可能要求对通常提供传输功能的程序作重大修改。
</li>
</ul>

</body>
</section>
<section>
<title>应用网关</title>
<body>

<p>
应用层网关应用程序的代理，它代表客户程序与远端系统交换数据。它远离大众，安处DMZ(非军事区: 
通过防火墙可见的私有网络部分)或不允许外部连接的防火墙之后。他的过滤依据是:
</p>

<ul>
<li>根据源／目的IP地址放行或拒绝</li>
<li>根据包内容</li>
<li>根据文件类型或扩展名限制文件访问权限</li>
</ul>

<p>
长处:
</p>

<ul>
<li>可缓冲文件，提高网络性能</li>
<li>所有连接的详细日志</li>
<li>完美的可扩展性 ( 一些代理服务器可"共享"缓冲数据)</li>
<li>不存在从外部的直接访问</li>
<li>甚至可运行中修改包内容</li>
</ul>

<p>
弱点:
</p>

<ul>
<li>配置很复杂</li>
</ul>

<p>
应用网关被认为是最安全的解决办法，因为它无须以root运行，
其后的主机无法从互联网进入。
</p>

<p>
自由／免费应用网关的实例:
</p>

<ul>
<li><uri link="http://www.squid-cache.org/">Squid</uri></li>
</ul>

</body>
</section>
<section>
<title>Iptables</title>
<body>

<p>
必须在内核中启用，iptables才可工作。我把它们加为模块 
(<c>iptables</c> 命令会在需要是装入它们) 并重新编译了内核。如何配置iptables的更多信息，
请移架 <uri link="http://iptables-tutorial.frozentux.net/chunkyhtml/kernelsetup.html">Iptables 
教程第二章: 准备</uri>。编译新内核后(或编译时), 需要加入 <c>iptables</c> 命令。 
只需 <c>emerge iptables</c> 应该就可以了。
</p>

<p>
运行 <c>iptables -L</c> 测试是否正常工作。如果失败，一定是什么地方搞错了，
只好在检查一遍配置文件了。
</p>

<p>
Iptables是Linux 2.4.x内核中新的极大改进了的包过滤器。是以前的Linux 2.2.x内核
中的ipchains的后继。重大改进之一是iptables可完成有状态的包过滤。有状态包过滤
使管理每个已建立的TCP连接成为可能。
</p>

<p>
一个 TCP 连接由一系列的包含源IP地址，目的IP地址，序号信息的包组成，这样
包可以重新组装起来而不会遗漏数据。与无连接的UDP相对应，TCP是一种面向连接的协议。
</p>

<p>
通过检查TCP包头，有状态包过滤器可以判断接收到的包是否已建立连接的一部分，从而
决定是否接受该包。
</p>

<p>
通过在TCP包头做手脚欺骗无状态包过滤器接受应该丢弃的包是完全可能的。
可以改动TCP头的SYN或其他标志来做到。而有状态包过滤器则可能丢弃这些包，
因为他们不是已建立连接的一部分。"隐形扫描"也没了可能，因为这样的包不会属于
任何已建立的连接。
</p>

<p>
Iptables提供了诸如NAT(网络地址转换)和限速的一些其他功能。对防范比如SYN洪水一类的
某些DoS(拒绝服务)攻击，限速极其有用。
</p>

<p>
TCP连接通过所谓的三次握手建立。建立TCP连接是，客户端向服务器发送一个设置了SYN标志的包。
收到SYN包后，服务器向客户端回送SYN+ACK包。客户端收到SYN+ACK后用第三个ACK包应答，
确认连接的建立。
</p>

<p>
SYN洪水攻击通过发SYN包但不应答SYN+ACK包来进行。客户端可以编造一个代假源IP地址的包，
反正它根本不需要回复。服务器方系统收到SYN包后会在半开连接队列中加入一项，等到最后的
ACK后在把该项从队列中删除。队列的容量有限，填满后就无法打开新的连接了。在指定的超时
过后如果没有收到ACK, 该项将自动从队列中被删除。超时设定可以变化但大致在30-60秒，甚至更多。
客户方发起攻击的方法是，尽可能快地伪造大量不同源IP地址的SYN包发往目标IP地址，以填满
半开连接队列，从而使其他用户不能与服务器建立起合法的连接。
</p>

<p>
限速在这里派上用场。可以通过使用 <c>-m limit --limit 1/s</c> 来限制接受SYN包的速度。
这样会限制SYN包接受数目为每秒一个，从而限制了我方资源上的SYN洪水。
</p>

<p>
现在来点实际的东西!
</p>

<p>
内核装入iptables时有5个钩子可以放你的规则。他们是  <c>INPUT</c>, <c>OUTPUT</c>, <c>FORWARD</c>, 
<c>PREROUTING</c> 和 <c>POSTROUTING</c>。每个成为一个链，有一组规则组成。每个规则
指明如果包长得这样，就这样处置它。如果规则不匹配，就查看该链中的现一个规则。
</p>

<p>
可以直接在5个主链中放入规则，也可以建立新的链，作为一条规则加入现有的链中。
Iptables 支持如下选项:
</p>

<table>
<tr>
  <th>选项:</th>
  <th>说明:</th>
</tr>
<tr>
  <ti>-A</ti>
  <ti>追加</ti>
</tr>
<tr>
  <ti>-D</ti>
  <ti>删除</ti>
</tr>
<tr>
  <ti>-I</ti>
  <ti>插入</ti>
</tr>
<tr>
  <ti>-R</ti>
  <ti>替换</ti>
</tr>
<tr>
  <ti>-L</ti>
  <ti>列示</ti>
</tr>
<tr>
  <ti>-F</ti>
  <ti>删除链中的所有规则或所有链</ti>
</tr>
<tr>
  <ti>-Z</ti>
  <ti>链或所有链中的计数器归零</ti>
</tr>
<tr>
  <ti>-C</ti>
  <ti>在链上测试该包</ti>
</tr>
<tr>
  <ti>-N</ti>
  <ti>创建新的用户定义链</ti>
</tr>
<tr>
  <ti>-X</ti>
  <ti>删除用户定义链</ti>
</tr>
<tr>
  <ti>-P</ti>
  <ti>改变链上的政策为目标</ti>
</tr>
<tr>
  <ti>-E</ti>
  <ti>改变链名</ti>
</tr>
<tr>
  <ti>-p</ti>
  <ti>协议</ti>
</tr>
<tr>
  <ti>-s</ti>
  <ti>源地址/掩码</ti>
</tr>
<tr>
  <ti>-d</ti>
  <ti>目标地址/掩码</ti>
</tr>
<tr>
  <ti>-i</ti>
  <ti>输入名 (以太网名)</ti>
</tr>
<tr>
  <ti>-o</ti>
  <ti>输出名 (以太网名)</ti>
</tr>
<tr>
  <ti>-j</ti>
  <ti>跳到 (目标找规则)</ti>
</tr>
<tr>
  <ti>-m</ti>
  <ti>扩展匹配 (可能使用扩充)</ti>
</tr>
<tr>
  <ti>-n</ti>
  <ti>地址和端口的数字输出</ti>
</tr>
<tr>
  <ti>-t</ti>
  <ti>操作的表</ti>
</tr>
<tr>
  <ti>-v</ti>
  <ti>详细提示模式</ti>
</tr>
<tr>
  <ti>-x</ti>
  <ti>扩展数字 (显示确切值)</ti>
</tr>
<tr>
  <ti>-f</ti>
  <ti>只匹配第二个或更多的片段</ti>
</tr>
<tr>
  <ti>-V</ti>
  <ti>包版本</ti>
</tr>
<tr>
  <ti>--line-numbers</ti>
  <ti>列示时打印行号</ti>
</tr>
</table>

<p>
首先我们试着阻止到我们的机器上的所有ICMP包，就为了搞熟iptables。
</p>

<pre caption="阻止所有 ICMP 包">
# <i>iptables -A INPUT -p icmp -j DROP</i>
</pre>

<p>
首先指定要加入的链，接着是协议，然后是目标。目标可以是用户指定的链名，
也可以是如下特殊目标之一: <c>ACCEPT</c>, <c>DROP</c>, <c>REJECT</c>, <c>LOG</c>, 
<c>QUEUE</c>, <c>MASQUERADE</c>。本例中我们使用了<c>DROP</c>，它不响应客户，
直接丢弃包。
</p>

<p>
现在试着 <c>ping localhost</c>。不会得到应答，因为iptable丢弃了所有进入的ICMP报文。
也ping不到其他机器因为回复的ICMP会被丢弃。现在刷新链，以便可以再得到ICMP流。
</p>

<pre caption="刷新所有规则">
# <i>iptables -F</i>
</pre>

<p>
现在看看iptables中的有状态包过滤。如果想要对从eth0进入包进行有状态的检查，可以发出如下命令启用它:
</p>

<pre caption="接受产生自已经建立的连接的包">
# <i>iptables -A INPUT -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
</pre>

<p>
这会接受任何来自已建立连接或与在INPUT链中有关的包。可在此前发出<c>iptables -A INPUT -i eth0 -m state --state INVALID -j 
DROP</c> 以丢弃不在状态表中的包。这样通过装如扩展状态启用了iptables中的有状态包过滤。
如果想允许他人连接到你的机器，可以使用 <c>--state NEW</c>。iptables包含一些用于不同目的的模块。
其中的一些是:
</p>

<table>
<tr>
  <th>模块/匹配</th>
  <th>说明</th>
  <th>扩展选项</th>
</tr>
<tr>
  <ti>mac</ti>
  <ti>入包mac地址匹配扩展</ti>
  <ti>--mac-source</ti>
</tr>
<tr>
  <ti>state</ti>
  <ti>打开带状态检查</ti>
  <ti>--state (states为ESTABLISHED,RELATED, INVALID, NEW)</ti>
</tr>
<tr>
  <ti>limit</ti>
  <ti>速度匹配限制</ti>
  <ti>--limit, --limit-burst</ti>
</tr>
<tr>
  <ti>owner</ti>
  <ti>尝试匹配包建立这的各种特征</ti>
  <ti>
    --uid-owner userid --gid-owner groupid --pid-owner processid --sid-owner 
    sessionid
  </ti>
</tr>
<tr>
  <ti>unclean</ti>
  <ti>对包的各种随机理性检查</ti><ti></ti>
</tr>
</table>

<p>
我们来试试建立用户定义链并将其应用到一个现有的链中：
</p>

<pre caption="创建用户定义链">
<codenote>创建一个只有一条规则的新链</codenote>
# <i>iptables -X mychain</i>
# <i>iptables -N mychain</i>
# <i>iptables -A mychain -i eth0 -m state --state ESTABLISHED,RELATED -j ACCEPT</i>
<codenote>默认政策是允许所有流出的通讯，丢弃进入的。</codenote>
# <i>iptables -P OUTPUT ACCEPT</i>
# <i>iptables -P INPUT DROP</i>
<codenote>将其加入 INPUT 链</codenote>
# <i>iptables -A INPUT -j mychain</i>
</pre>

<p>
把该规则应用到输入链后我们得到这样的政策：允许所有流出包，丢弃所有流入包。
</p>

<p>
可在 <uri link="http://www.iptables.org/documentation/index.html#HOWTO">Netfilter/iptables 文档</uri>
找到文档。
</p>

<p>
看看一个完整的例子。这个例子下我的防火墙和网关的政策是这样的:
</p>

<ul>
<li>只允许通过SSH（端口22）连接防火墙</li>
<li>
  本地网应可访问 HTTP, HTTPS 和 SSH (也应该允许DNS)
</li>
<li>
  ICMP 通讯可能包含有效负载，不可放行。当然要放行某些ICMP通信。
</li>
<li>要检测并登记端口扫描</li>
<li>应避免SYN攻击</li>
<li>所有其他通信应丢弃并在日志中登记</li>
</ul>

<pre caption="/etc/init.d/firewall">
#!/sbin/runscript
IPTABLES=/sbin/iptables
IPTABLESSAVE=/sbin/iptables-save
IPTABLESRESTORE=/sbin/iptables-restore
FIREWALL=/etc/firewall.rules
DNS1=212.242.40.3
DNS2=212.242.40.51
#内部
IIP=10.0.0.2
IINTERFACE=eth0
LOCAL_NETWORK=10.0.0.0/24
#外部
OIP=217.157.156.144
OINTERFACE=eth1

opts="${opts} showstatus panic save restore showoptions rules"

depend() {
  need net
}

rules() {
  stop
  ebegin "Setting internal rules"

  einfo "Setting default rule to drop"
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP

  #默认规则
  einfo "Creating states chain"
  $IPTABLES -N allowed-connection
  $IPTABLES -F allowed-connection
  $IPTABLES -A allowed-connection -m state --state ESTABLISHED,RELATED -j ACCEPT
  $IPTABLES -A allowed-connection -i $IINTERFACE -m limit -j LOG --log-prefix \ 
      "Bad packet from ${IINTERFACE}:"
  $IPTABLES -A allowed-connection -j DROP

  #ICMP通迅
  einfo "Creating icmp chain"
  $IPTABLES -N icmp_allowed
  $IPTABLES -F icmp_allowed
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      time-exceeded -j ACCEPT
  $IPTABLES -A icmp_allowed -m state --state NEW -p icmp --icmp-type \ 
      destination-unreachable -j ACCEPT
  $IPTABLES -A icmp_allowed -p icmp -j LOG --log-prefix "Bad ICMP traffic:"
  $IPTABLES -A icmp_allowed -p icmp -j DROP

  #进入通讯
  einfo "Creating incoming ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-in
  $IPTABLES -F allow-ssh-traffic-in
  #Flood protection
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL RST --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL FIN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m limit --limit 1/second -p tcp --tcp-flags \ 
      ALL SYN --dport ssh -j ACCEPT
  $IPTABLES -A allow-ssh-traffic-in -m state --state RELATED,ESTABLISHED -p tcp --dport ssh -j ACCEPT

  #外出通讯
  einfo "Creating outgoing ssh traffic chain"
  $IPTABLES -N allow-ssh-traffic-out
  $IPTABLES -F allow-ssh-traffic-out
  $IPTABLES -A allow-ssh-traffic-out -p tcp --dport ssh -j ACCEPT

  einfo "Creating outgoing dns traffic chain"
  $IPTABLES -N allow-dns-traffic-out
  $IPTABLES -F allow-dns-traffic-out
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS1 --dport domain \ 
      -j ACCEPT
  $IPTABLES -A allow-dns-traffic-out -p udp -d $DNS2 --dport domain \ 
     -j ACCEPT

  einfo "Creating outgoing http/https traffic chain"
  $IPTABLES -N allow-www-traffic-out
  $IPTABLES -F allow-www-traffic-out
  $IPTABLES -A allow-www-traffic-out -p tcp --dport www -j ACCEPT
  $IPTABLES -A allow-www-traffic-out -p tcp --dport https -j ACCEPT

  #捕获端口扫描
  einfo "Creating portscan detection chain"
  $IPTABLES -N check-flags
  $IPTABLES -F check-flags
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -m limit \ 
      --limit 5/minute -j LOG --log-level alert --log-prefix "NMAP-XMAS:" 
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -m limit --limit \ 
      5/minute -j LOG --log-level 1 --log-prefix "XMAS:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL ALL -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG \ 
      -m limit --limit 5/minute -j LOG --log-level 1 --log-prefix "XMAS-PSH:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL SYN,RST,ACK,FIN,URG -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -m limit \ 
      --limit 5/minute -j LOG --log-level 1 --log-prefix "NULL_SCAN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags ALL NONE -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/RST:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -m limit \ 
      --limit 5/minute -j LOG --log-level 5 --log-prefix "SYN/FIN:"
  $IPTABLES -A check-flags -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP

  # 向链中应用并加入无效状态
  einfo "Applying chains to INPUT"
  $IPTABLES -A INPUT -m state --state INVALID -j DROP
  $IPTABLES -A INPUT -j icmp_allowed 
  $IPTABLES -A INPUT -j check-flags
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A INPUT -j allow-ssh-traffic-in
  $IPTABLES -A INPUT -j allowed-connection

  einfo "Applying chains to FORWARD"
  $IPTABLES -A FORWARD -m state --state INVALID -j DROP
  $IPTABLES -A FORWARD -j icmp_allowed 
  $IPTABLES -A FORWARD -j check-flags
  $IPTABLES -A FORWARD -o lo -j ACCEPT
  $IPTABLES -A FORWARD -j allow-ssh-traffic-in
  $IPTABLES -A FORWARD -j allow-www-traffic-out
  $IPTABLES -A FORWARD -j allowed-connection

  einfo "Applying chains to OUTPUT"
  $IPTABLES -A OUTPUT -m state --state INVALID -j DROP
  $IPTABLES -A OUTPUT -j icmp_allowed
  $IPTABLES -A OUTPUT -j check-flags
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  $IPTABLES -A OUTPUT -j allow-ssh-traffic-out
  $IPTABLES -A OUTPUT -j allow-dns-traffic-out
  $IPTABLES -A OUTPUT -j allow-www-traffic-out
  $IPTABLES -A OUTPUT -j allowed-connection

  #允许客户通过NAT(网路地址转换)路由
  $IPTABLES -t nat -A POSTROUTING -o $IINTERFACE -j MASQUERADE 
  eend $?
}

start() {
  ebegin "Starting firewall"
  if [ -e "${FIREWALL}" ]; then
    restore
  else
    einfo "${FIREWALL} does not exists. Using default rules."
    rules
  fi
  eend $?
}

stop() {
  ebegin "Stopping firewall"
  $IPTABLES -F
  $IPTABLES -t nat -F
  $IPTABLES -X
  $IPTABLES -P FORWARD ACCEPT
  $IPTABLES -P INPUT   ACCEPT
  $IPTABLES -P OUTPUT  ACCEPT
  eend $?
}

showstatus() {
  ebegin "Status"
  $IPTABLES -L -n -v --line-numbers
  einfo "NAT status"
  $IPTABLES -L -n -v --line-numbers -t nat
  eend $?
}

panic() {
  ebegin "Setting panic rules"
  $IPTABLES -F
  $IPTABLES -X
  $IPTABLES -t nat -F
  $IPTABLES -P FORWARD DROP
  $IPTABLES -P INPUT   DROP
  $IPTABLES -P OUTPUT  DROP
  $IPTABLES -A INPUT -i lo -j ACCEPT
  $IPTABLES -A OUTPUT -o lo -j ACCEPT
  eend $?
}

save() {
  ebegin "Saving Firewall rules"
  $IPTABLESSAVE &gt; $FIREWALL
  eend $?
}

restore() {
  ebegin "Restoring Firewall rules"
  $IPTABLESRESTORE &lt; $FIREWALL
  eend $?
}

restart() {
  svc_stop; svc_start
}

showoptions() {
  echo "Usage: $0 {start|save|restore|panic|stop|restart|showstatus}"
  echo "start)      will restore setting if exists else force rules"
  echo "stop)       delete all rules and set all to accept"
  echo "rules)      force settings of new rules"
  echo "save)       will store settings in ${FIREWALL}"
  echo "restore)    will restore settings from ${FIREWALL}"
  echo "showstatus) Shows the status" 
}
</pre>

<p>
建立防火墙的免费建议:
</p>

<ol>
<li>实施前建立好防火墙政策</li>
<li>尽量简单</li>
<li>
  了解协议工作原理(阅读 <uri 
  link="http://www.ietf.org/">RFC</uri>(征求意见稿))
</li>
<li>
  记住防火墙不过是又一个以root运行的软件
</li>
<li>测试防火墙</li>
</ol>

<p>
如果认为 iptables 难于理解，设置好的防火墙费时，可以使用 <uri 
link="http://www.shorewall.net">Shorewall</uri>。基本而言它使用 iptables 来产生 
防火墙规则，但重心放在规则而不是特定协议上。
</p>

</body>
</section>
<section>
<title>Squid</title>
<body>

<p>
Squid 是一款非常强大的代理服务器软件，它可基于时间、路径/URI上的正则表达式，源/目的
IP地址、域、浏览器、鉴证过的用户名、MIME类型和端口号(协议)对通讯过滤。可能漏说了一些
功能，不过要把它的完整的功能列表面面俱到太难了。
</p> 

<p>
下面的例子中我加入了条幅过滤器而不是色情网站过滤器。因为 Gentoo.org <e>not</e> 应该
列入色情网站。我可不想费劲给你找几个好的网站。
</p>

<p>
本例中我的政策是这样的:
</p>

<ul>
<li>
  工作时间（星期一到星期五8点到15点、星期六8点到13点)允许上网 (HTTP/HTTPS)，如果要加班，
  那就应该干活而不是上网。
</li>
<li>
  不允许下载 (.exe, .com, .arj, .zip, .asf, .avi, .mpg, .mpeg 等)
</li>
<li>
  我们不喜欢广告条幅，所以把他们都过滤掉，换成透明的gif(这就要看你的创造力了)。
</li>
<li>不允许其他进出互联网的连接</li>
</ul>

<p>
用 <e>简单</e> 的四个步骤来实施。
</p>

<pre caption="/etc/squid/squid.conf">
# 保定到一个 IP和端口
http_port 10.0.2.1:3128

# 标准配置
hierarchy_stoplist cgi-bin ?
acl QUERY urlpath_regex cgi-bin \?
no_cache deny QUERY

# 加入基本访问控制列表
acl all src 0.0.0.0/0.0.0.0
acl manager proto cache_object
acl localhost src 127.0.0.1/255.255.255.255

# 加入可以访问代理服务器的人员
acl localnet src 10.0.0.0/255.255.0.0

# 及端口
acl SSL_ports port 443
acl Safe_ports port 80
acl Safe_ports port 443
acl purge method PURGE

# 加入基于URL内的正则表达式的访问控制列表
acl archives urlpath_regex "/etc/squid/files.acl"
acl url_ads url_regex "/etc/squid/banner-ads.acl"

# 加入基于时间和日期的访问控制列表
acl restricted_weekdays time MTWHF 8:00-17:00
acl restricted_weekends time A 8:00-13:00

acl CONNECT method CONNECT

#允许manager从localhost访问
http_access allow manager localhost
http_access deny manager

# 只允许来自localhost(本地主机)的purge(清洗）请求
http_access allow purge localhost
http_access deny purge

# 拒绝对位置端口的请求
http_access deny !Safe_ports

# 就觉对SSL以外端口的CONNECT(连接)
http_access deny CONNECT !SSL_ports

# 我自己的规则

# 加入删除广告条幅后要显示的页
deny_info NOTE_ADS_FILTERED url_ads

# 可以拒绝它们了
http_access deny url_ads

# 拒绝所有的 archives（档案)
http_access deny archives

# 仅限于工作时间访问
http_access allow localnet restricted_weekdays
http_access allow localnet restricted_weekends

# 剩下的全部拒绝
http_access deny all
</pre>

<p>
接着是files中不希望你的用户下载的文件。我加入了zip, 
viv, exe, mp3, rar, ace, avi, mov, mpg, mpeg, au, ra, arj, tar, gz 和 z 文件。
</p>

<pre caption="/etc/squid/files.acl">
\.[Zz][Ii][pP]$
\.[Vv][Ii][Vv].*
\.[Ee][Xx][Ee]$
\.[Mm][Pp]3$
\.[Rr][Aa][Rr]$
\.[Aa][Cc][Ee]$
\.[Aa][Ss][Ff]$
\.[Aa][Vv][Ii]$
\.[Mm][Oo][Vv]$
\.[Mm][Pp][Gg]$
\.[Mm][Pp][Ee][Gg]$
\.[Aa][Uu]$
\.[Rr][Aa]$
\.[Aa][Rr][Jj]$
\.[Tt][Aa][Rr]$
\.[GgZz]$
\.[Zz]$
</pre>

<note>
请注意[]中每个字母的大小写。这样做是为了避免有人骗过它访问AvI而不是avi文件
</note>

<p>
下一步加入鉴定广告条幅的正则表达式。很可能你比我更有创意哦:
</p>

<pre caption="/etc/squid/banner-ads.acl">
/adv/.*\.gif$
/[Aa]ds/.*\.gif$
/[Aa]d[Pp]ix/
/[Aa]d[Ss]erver
/[Aa][Dd]/.*\.[GgJj][IiPp][FfGg]$
/[Bb]annerads/
/adbanner.*\.[GgJj][IiPp][FfGg]$
/images/ad/
/reklame/
/RealMedia/ads/.*
^http://www\.submit-it.*
^http://www\.eads.*
^http://ads\.
^http://ad\.
^http://ads02\.
^http://adaver.*\.
^http://adforce\.
adbot\.com
/ads/.*\.gif.*
_ad\..*cgi
/Banners/
/SmartBanner/
/Ads/Media/Images/
^http://static\.wired\.com/advertising/
^http://*\.dejanews\.com/ads/
^http://adfu\.blockstackers\.com/
^http://ads2\.zdnet\.com/adverts
^http://www2\.burstnet\.com/gifs/
^http://www.\.valueclick\.com/cgi-bin/cycle
^http://www\.altavista\.com/av/gifs/ie_horiz\.gif
</pre>

<p>
最后一步，希望删除条幅后显示这个文件。基本而言这是一个有4x4透明gif图像的半HTML文件。
</p>

<pre caption="/etc/squid/errors/NOTE_ADS_FILTERED">
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META HTTP-EQUIV="REFRESH" CONTENT="0; URL=http://localhost/images/4x4.gif"&gt;
&lt;TITLE>ERROR: The requested URL could not be retrieved&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;H1&gt;Add filtered!&lt;/H1&gt;
</pre>

<note>
不要关闭 &lt;HTML&gt; &lt;BODY&gt; 标签，交给squid吧。
</note>

<p>
可以看出，squid有很多可能性，它在过滤和代理上都非常有效。在非常大的网络上它
甚至可以使用替代squid代理来扩展。我这里列出的配置主要适于1－20个用户的小网络。
</p>

<p>
但是组合使用包过滤(iptables)和应用网关(squid)可能是最佳方案。即使squild处于不可
从外部访问的安全场所也是如此。内部攻击者也不可不防啊。
</p>

<p>
现在要配置你的客户的浏览器使用该代理服务器。网关可以可以阻止用户不通过代理直接与外部接触。
</p>

<note>
Mozilla中在Edit->Preferences->Advanced->Proxies设置。
</note>

<p>
也可使用iptables把流出的通讯转发给squid代理来透明的完成。
在网关上加入转发／预路由规则来做到这点。
</p>

<pre caption="启用到我们的代理服务器的端口转发">
# <i>iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to proxyhost:3128</i>
# <i>iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to proxyhost:3128</i>
</pre>

</body>
</section>
<section>
<title>至此我们学到了些什么?</title>
<body>

<p>
我们学到了:
</p>

<ol>
<li>
  防火墙本身也可能是一种风险。配置不当的防火墙有不如无。
</li>
<li>如何设置基本的网关和透明代理</li>
<li>好的防火墙的关键在于了解你想放行的协议</li>
<li>
  IP通讯并不总是包含合法数据，即，ICMP包可能包含有效负载。
</li>
<li>如何防止 SYN 攻击</li>
<li>
  过滤HTTP通讯，删除令人不快的图片并防止下载病毒。
</li>
<li>
  组合使用包过滤和应用网关提过了更好的控制。
</li>
</ol>

<p>
现在如果你<e>确有需要</e>，去建立一个满足你的需要的防火墙吧。
</p>

</body>
</section>
</chapter>

<chapter>
<title>入侵检测</title>
<section>
<title>AIDE (高级入侵检测环境)</title>
<body>

<p>
AIDE 是一种基于主机的入侵检测系统 ( Tripwire的免费替代品)。
如果你已经知道 Tripwire，学习AIDE的配置配置文件不在话下。
</p>

<p>
配置文家基于文件和目录的正则表达式、宏和规则。我们有如下啊的宏: 
</p>

<table>
<tr>
  <th>宏</th>
  <th>简述</th>
  <th>语法</th>
</tr>
<tr>
  <ti>ifdef</ti>
  <ti>如果定义了</ti>
  <ti>@@ifdef "name"</ti>
</tr>
<tr>
  <ti>ifndef</ti>
  <ti>如果未定义</ti>
  <ti>@@ifndef "name"</ti>
</tr>
<tr>
  <ti>define</ti>
  <ti>定义变量 </ti>
  <ti>@@define "name" "value"</ti>
</tr>
<tr>
  <ti>undef</ti>
  <ti>取消变量的定义</ti>
  <ti>@@undef "name"</ti>
</tr>
<tr>
  <ti>ifhost</ti>
  <ti>如果是 "hostname"</ti>
  <ti>@@ifhost "hostname"</ti>
</tr>
<tr>
  <ti>ifnhost</ti>
  <ti>如果非 "hostname"</ti>
  <ti>@@ifnhost "hostname"</ti>
</tr>
<tr>
  <ti>endif</ti>
  <ti>
    上面除define和undef外的其他宏之后都要使用endif
  </ti>
  <ti>@@endif</ti>
</tr>
</table>

<p>
如果有不止一个Gentoo机器想在它们上都用AIDE而机器上运行的服务甚至用户不完全相同,
这些宏就非常有用了。
</p>

<p>
下一步我们要检测文件和目录上的几套标志。这些是权限组合、文件属性和加密哈希/校验和
</p>

<table>
<tr>
  <th>标志</th>
  <th>简述</th>
</tr>
<tr>
  <ti>p</ti>
  <ti>权限</ti>
</tr>
<tr>
  <ti>i</ti>
  <ti>索引节点[inode]</ti>
</tr>
<tr>
  <ti>n</ti>
  <ti>连接数目</ti>
</tr>
<tr>
  <ti>u</ti>
  <ti>用户</ti>
</tr>
<tr>
  <ti>g</ti>
  <ti>组</ti>
</tr>
<tr>
  <ti>s</ti>
  <ti>大小</ti>
</tr>
<tr>
  <ti>b</ti>
  <ti>块数</ti>
</tr>
<tr>
  <ti>m</ti>
  <ti>最近修改时间[mtime]</ti>
</tr>
<tr>
  <ti>a</ti>
  <ti>最近访问时间[atime]</ti>
</tr>
<tr>
  <ti>c</ti>
  <ti>索引节点修改时间[ctime]</ti>
</tr>
<tr>
  <ti>S</ti>
  <ti>检查大小增长</ti>
</tr>
<tr>
  <ti>md5</ti>
  <ti>md5校验和</ti>
</tr>
<tr>
  <ti>sha1</ti>
  <ti>sha1校验和</ti>
</tr>
<tr>
  <ti>rmd160</ti>
  <ti>rmd160校验和</ti>
</tr>
<tr>
  <ti>tiger</ti>
  <ti>tiger校验和</ti>
</tr>
<tr>
  <ti>R</ti>
  <ti>p+i+n+u+g+s+m+c+md5</ti>
</tr>
<tr>
  <ti>L</ti>
  <ti>p+i+n+u+g</ti>
</tr>
<tr>
  <ti>E</ti>
  <ti>空组</ti>
</tr>
<tr>
  <ti>&gt;</ti>
  <ti>增大日志文件 p+u+g+i+n+S</ti>
</tr>
</table>

<p>
如果 AIDE 编译时加入了 mhash 支持，还有其他几个功能:
</p>

<table>
<tr>
  <th>标志</th>
  <th>简述</th>
</tr>
<tr>
  <ti>haval</ti>
  <ti>haval校验和</ti>
</tr>
<tr>
  <ti>gost</ti>
  <ti>gost校验和</ti>
</tr>
<tr>
  <ti>crc32</ti>
  <ti>crc32校验和</ti>
</tr>
</table>

<p>
现在可以组合这些标志创建你自己的规则了，如:
</p>

<pre caption="创建 AIDE 规则集">
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160
</pre>

<p>
建立自己的配置文件还差最后一步，如何把规则加入某个文件或目录。
基本而言只需敲入文件或目录名及规则。除非另外指明，AIDE会递归地
加入所有文件。
</p>

<table>
<tr>
  <th>标志</th>
  <th>简述</th>
</tr>
<tr>
  <ti>!</ti>
  <ti>不加入该文件或目录。</ti>
</tr>
<tr>
  <ti>=</ti>
  <ti>加入该目录，但不要管其子目录。</ti>
</tr>
</table>

<p>
好了，我们来观摩一个完整的例子
</p>

<pre caption="/etc/aide/aide.conf">
@@ifndef TOPDIR 
@@define TOPDIR /
@@endif

@@ifndef AIDEDIR 
@@define AIDEDIR /etc/aide
@@endif

@@ifhost smbserv
@@define smbactive
@@endif

# 要读的数据库的位置。
database=file:@@{AIDEDIR}/aide.db

# 要写入的数据库的位置。
database_out=file:aide.db.new

verbose=20
report_url=stdout

# 定义规则
All=R+a+sha1+rmd160
Norm=s+n+b+md5+sha1+rmd160

@@{TOPDIR} Norm
!@@{TOPDIR}etc/aide
!@@{TOPDIR}dev
!@@{TOPDIR}proc
!@@{TOPDIR}root
!@@{TOPDIR}tmp
!@@{TOPDIR}var/log
!@@{TOPDIR}var/run
!@@{TOPDIR}usr/portage
@@ifdef smbactive
!@@{TOPDIR}etc/smb/private/secrets.tdb
@@endif
=@@{TOPDIR}home Norm
</pre>

<p>
上例中我们用一些宏指明了topdir开始的位置和AIDE目录的位置。AIDE 检查文家完整性时
检查 <path>/etc/aide/aide.db</path>文件。但更新或创建新文件时存入 <path>/etc/aide/aide.db.new</path>。
这么做是为了避免自动覆盖旧数据库文件。<c>report_URL</c> 选项还没有完成，不过作者的意图
是它应可以email甚至执行脚本。
</p>

<p>
编辑配置后应执行 <c>aide -i</c> 以创建db文件，并把文件 <path>/etc/aide/aide.db.new</path> 
复制到 <path>/etc/aide/aide.db</path>， 并以root执行<c>crontab -e</c> 把该检查加入 cron。
</p>

<note>
取决于cpu, 磁盘访问(速度)和设定的文件访问标志，这个过程可能要花一些时间。 
take some time.
</note>

<pre caption="安排 aide 为 cron 工作">
0 3   * * * /usr/bin/aide -u
</pre>

<note>
记得设好可收到root的邮件，否则就无法知道 aide 报告的内容。
</note>

<p>
本例中每天早3点运行一次。这么做是不想影响用户的工作。注意我使用 <c>-u</c> 
(更新)选项而不是 <c>-C</c> (检查)。因为 <c>-u</c> 也检查文件而且不会改写原来地
db文件。这样节省了时间，因为只需复制测出变动了的文件。只需在复制前检查是你还是
攻击者作出的改变!
</p>

<p>
现在把db文件存在本地还有问题，因为攻击者肯定会（如果他们发现安装了aide)想修改、更新db文件，
或者修改 <path>/usr/bin/aide</path>。所以你应该创建一个CD或者别的媒体，放入.db文件和aide
二进制文件的副本。
</p>

<p>
可在 <uri 
link="http://www.cs.tut.fi/~rammer/aide.html">AIDE</uri> 项目主页找到信息。
</p>

</body>
</section>
<section>
<title>Snort</title>
<body>

<p>
Snort 是一种网络入侵检测系统 (NIDS)。使用下例安装、配置snort。
</p>

<pre caption="向系统中加入用户snort">
# useradd snort -d /var/log/snort -s /dev/null
# chown -R snort /var/log/snort
</pre>

<pre caption="/etc/conf.d/snort">
PIDFILE=/var/run/snort_eth0.pid
MODE="full"
NETWORK="10.0.0.0/24"
LOGDIR="/var/log/snort"
CONF=/etc/snort/snort.conf
SNORT_OPTS="-D -s -u snort -dev -l $LOGDIR -h $NETWORK -c $CONF"
</pre>

<pre caption="/etc/snort/snort.conf">
<codenote>第一步</codenote>
var HOME_NET 10.0.0.0/24
var EXTERNAL_NET any
var SMTP $HOME_NET
var HTTP_SERVERS $HOME_NET
var SQL_SERVERS $HOME_NET
var DNS_SERVERS [10.0.0.2/32,212.242.40.51/32]
var RULE_PATH ./

<codenote>第二步</codenote>
preprocessor frag2
preprocessor stream4: detect_scans detect_state_problems detect_scans disable_evasion_alerts
preprocessor stream4_reassemble: ports all
preprocessor http_decode: 80 8080 unicode iis_alt_unicode double_encode iis_flip_slash full_whitespace
preprocessor rpc_decode: 111 32771
preprocessor bo: -nobrute
preprocessor telnet_decode

<codenote>第三步</codenote>
include classification.config

<codenote>第四步</codenote>
include $RULE_PATH/bad-traffic.rules
include $RULE_PATH/exploit.rules
include $RULE_PATH/scan.rules
include $RULE_PATH/finger.rules
include $RULE_PATH/ftp.rules
include $RULE_PATH/telnet.rules
include $RULE_PATH/smtp.rules
include $RULE_PATH/rpc.rules
include $RULE_PATH/rservices.rules
include $RULE_PATH/dos.rules
include $RULE_PATH/ddos.rules
include $RULE_PATH/dns.rules
include $RULE_PATH/tftp.rules
include $RULE_PATH/web-cgi.rules
include $RULE_PATH/web-coldfusion.rules
include $RULE_PATH/web-iis.rules
include $RULE_PATH/web-frontpage.rules
include $RULE_PATH/web-misc.rules
include $RULE_PATH/web-attacks.rules
include $RULE_PATH/sql.rules
include $RULE_PATH/x11.rules
include $RULE_PATH/icmp.rules
include $RULE_PATH/netbios.rules
include $RULE_PATH/misc.rules
include $RULE_PATH/attack-responses.rules
include $RULE_PATH/backdoor.rules
include $RULE_PATH/shellcode.rules
include $RULE_PATH/policy.rules
include $RULE_PATH/porn.rules
include $RULE_PATH/info.rules
include $RULE_PATH/icmp-info.rules
include $RULE_PATH/virus.rules
# include $RULE_PATH/experimental.rules
include $RULE_PATH/local.rules
</pre>

<pre caption="/etc/snort/classification.config">
config classification: not-suspicious,Not Suspicious Traffic,3
config classification: unknown,Unknown Traffic,3
config classification: bad-unknown,Potentially Bad Traffic, 2
config classification: attempted-recon,Attempted Information Leak,2
config classification: successful-recon-limited,Information Leak,2
config classification: successful-recon-largescale,Large Scale Information Leak,2
config classification: attempted-dos,Attempted Denial of Service,2
config classification: successful-dos,Denial of Service,2
config classification: attempted-user,Attempted User Privilege Gain,1
config classification: unsuccessful-user,Unsuccessful User Privilege Gain,1
config classification: successful-user,Successful User Privilege Gain,1
config classification: attempted-admin,Attempted Administrator Privilege Gain,1
config classification: successful-admin,Successful Administrator Privilege Gain,1

# 新的分类
config classification: rpc-portmap-decode,Decode of an RPC Query,2
config classification: shellcode-detect,Executable code was detected,1
config classification: string-detect,A suspicious string was detected,3
config classification: suspicious-filename-detect,A suspicious filename was detected,2
config classification: suspicious-login,An attempted login using a suspicious username was detected,2
config classification: system-call-detect,A system call was detected,2
config classification: tcp-connection,A TCP connection was detected,4
config classification: trojan-activity,A Network Trojan was detected, 1
config classification: unusual-client-port-connection,A client was using an unusual port,2
config classification: network-scan,Detection of a Network Scan,3
config classification: denial-of-service,Detection of a Denial of Service Attack,2
config classification: non-standard-protocol,Detection of a non-standard protocol or event,2
config classification: protocol-command-decode,Generic Protocol Command Decode,3
config classification: web-application-activity,access to a potentially vulnerable web application,2
config classification: web-application-attack,Web Application Attack,1
config classification: misc-activity,Misc activity,3
config classification: misc-attack,Misc Attack,2
config classification: icmp-event,Generic ICMP event,3
config classification: kickass-porn,SCORE! Get the lotion!,1
</pre>

<p>
<uri link="http://www.snort.org">Snort</uri>网站有更多的信息。
</p>

</body>
</section>
</chapter>

<chapter>
<title>保持更新</title>
<section>
<body>

<p>
成功安装了系统并实施了较好级别的安全，不是就可以睡大觉了。安全是一个不断前进
的过程，必须不断更新系统，与最新的安全补丁同步。
</p>

<p>
如果安装了 <c>portage</c> 的近期版本， 可以首先用 <c>emerge sync</c> 同步portage树，
然后发出 <c>glsa-check --list</c> 命令检查系统在安全方面是否是最新的。
</p>

<pre caption="glsa-check -l输出示例">
# <i>glsa-check -l</i>
</pre>

<warn>
<c>glsa-check</c> 还是试验性质的，如果安全是你的首要问题，明智的做法是将该列表与
其他途径核对。
</warn>

<p>
所有有<c>[A]</c> 和 <c>[U]</c> 的行可以安全地忽略掉，因为系统不受这个GLSA的影响。
</p>

<p>
有些人还是更喜欢用 <c>emerge 包名</c> 而不是 
<c>glsa-check -f</c> 这样所有的 GLSA 都列为 <c>[N]</c>.
</p>

<p>
如果想在每次有新的GLSA发布是收到邮件同志，预订 <c>gentoo-announce</c> 邮件列表。
加入该列表及很多其他不错的邮件列表的方法，可以在 <uri 
link="/main/en/lists.xml">Gentoo Linux 邮件列表总揽</uri> 找到.
</p>

<p>
另外一个很不错的安全资源是 <uri 
link="http://www.securityfocus.com/archive/1">Bugtraq 邮件列表</uri>.
</p>

</body>
</section>
</chapter>
</guide>
