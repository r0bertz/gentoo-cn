<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/zh_cn/uml.xml">
<title>Gentoo Linux 开发者的用户模式 Linux 测试系统指南</title>

<author title="Editor"><mail link="g2boojum@gentoo.org">Grant Goodyear</mail></author>

<author title="Editor"><mail link="zhen@gentoo.org">John Davis</mail></author>

<author title="Editor"><mail link="swift@gentoo.org">Sven Vermeulen</mail></author>

<author title="Translator"><mail link="liqiang@iscas.cn">Zhang Liqiang</mail></author>

<abstract>
本指南揭示了 Gentoo Linux 开发者如何设置用户模式 linux，来测试有潜在系统破坏的改变。
</abstract>

<license/>

<version>0.2</version>
<date>2003年9月30日</date>

<chapter>
<title>获得用户模式 用户模式 Linux</title>
<section>
<body>

<p>
正如用户模式 linux 网站 
(<uri>http://用户模式-linux.sourceforge.net</uri>)
所述, 用户模式 linux
允许用户“自包含运行 Linux”。特别的，
用户模式 linux 提供了虚拟机，用户可以在上面“运行毛病软件，
尝试新的 Linux 内核或发布，在 Linux 内部敲敲打打，全都不会使你的主要 Linux 冒风险。”
对于 Gentoo 核心软件包，比如 <e>sys-apps/baselayout</e> 或是 <e>sys-libs/glibc</e> 的改变
有潜在的系统破坏性或是使它无法引导；通过用户模式
linux 我们可以测试这些改变而不用担心破坏现存的系统。
</p>

<p>
安装用户模式 linux 与一般的内核安装本质上是相同的
首先安装内核源码（加入用户模式 linux 恰当补丁），
然后以通常的习惯配置用户模式 linux 内核：
</p>

<pre>
# <i>emerge sys-kernel/usermode-sources</i>
# <i>cd /usr/src/uml/linux</i>
# <i>make menuconfig <comment>ARCH=um</comment></i>
# <i>make linux <comment>ARCH=um</comment></i>
# <i>cp linux /usr/local/bin/linux</i>
</pre>

<warn>
<e>ARCH=um</e> 参数是<e>非常</e>重要的！</warn>

<impo>
为了使用户模式 linux 内核恰当的引导 Gentoo 系统， 
内核<e>不</e>能配置为缺省自动加载
<path>/dev</path> （devfs）。  
同样，你也要肯定确保你内核编译中有
<e>tmpfs</e>（虚拟内存文件系统），
因为缺省的 Gentoo linux引导脚本
在一个小的 tmpfs 分区存储他们的信息。
（用户模式linux 的网站上的二进制内核包含自动加载<path>/dev</path>，
同时他们编译了 tmpfs；还是不要麻烦他们了。）
</impo>

<p>
我强烈建议阅读用户模式 linux 文档， but the
不过基本的观点就是运行 <path>/usr/local/bin/linux</path> 程序，
引导用户模式内核并且试着带起存储在文件 <path>root_fs</path> 中的系统，
位于恰当的工作目录。</p>

<p>
安装用户模式 linux 工具也不会有伤害的。</p>

<pre>
# <i>emerge sys-apps/usermode-utilities</i>
</pre>

<p>
这些工具会简化用户模式 linux 虚拟系统和宿主系统
之间的网络（在各种事情中）。
</p>
</body>
</section>
</chapter>

<chapter>
<title>创建 <path>root_fs</path></title>

<section>
<title>制造 Gentoo chroot</title>
<body>

<p>
用户模式 linux所需的 <path>root_fs</path> 文件 
是一个包含整个 Gentoo Linux 文件系统的单独文件。
要生成这个文件，你需要在宿主内核（非用户模式）
使用 Loopback 设备支持。
</p>

<p>
生成 <path>root_fs</path> 文件本身会是我们的最后一步。
首先，我们会在一般的 chroot 生成 Gentoo 文件系统。
我们需要可用的 stage 压缩包，
可以单独下载，从 liveCD 中解出，从 liveCD .iso 文件中解出。
</p>

<pre caption="加载 liveCD .iso">
# <i>mkdir /mnt/loop</i>
# <i>mount -o loop /path/to/build-&lt;TAB&gt;.iso /mnt/loop</i>
</pre>

<p>
设置 chroot 与一般 Gentoo Linux 的建造基本一致。
</p>

<pre>
# <i>mkdir /mnt/gentoo</i>
# <i>cd /mnt/gentoo</i>
# <i>tar xvjpf /path/to/build-&lt;TAB&gt;.tar.bz2</i>
</pre>

<p>
接着卸载 .iso。你不再需要它了。
</p>

<pre>
# <i>cp /etc/resolv.conf /mnt/gentoo/etc/</i>
# <i>mount -o bind /proc /mnt/gentoo/proc</i>
# <i>mkdir -p /mnt/gentoo/usr/portage/distfiles</i>
# <i>mkdir -p /mnt/gentoo/usr/portage/packages</i>
# <i>mount -o bind /usr/portage/distfiles /mnt/gentoo/usr/portage/distfiles</i>
# <i>mount -o bind /usr/portage/packages /mnt/gentoo/usr/portage/packages</i>
# <i>chroot /mnt/gentoo /bin/bash</i>
<!--per bug 16134, added emerge sync to supress warning, etc-->
# <i>emerge sync</i>
# <i>env-update</i>
# <i>source /etc/profile</i>
</pre>

<p>
通过绑定加载 <path>/usr/portage/distfiles</path> 和
<path>/usr/portage/packages</path>，我们避免了下载或建造
已经在 Gentoo 主机上已经存在的软件包。
</p>

<p>
以通常习惯 Bootstrap 和建造系统：
</p>

<pre>
<!--removed the emerge sync below because it is done above-->
# <i>cd /usr/portage</i>
# <i>nano -w /etc/make.conf</i>
# <i>nano -w /etc/make.profile/packages</i> 
# <i>nano -w /usr/portage/profiles/package.mask</i>
# <i>scripts/bootstrap.sh &amp;&amp; emerge --usepkg system</i>
</pre>

<warn>
<!--Changed grub to virtual/bootloader-->
<path>/etc/make.profile/packages</path> 文件需要编辑以便
从缺省系统中除去 virtual/bootloader ebuild （只需从“*virtual/bootloader”行的开头除去“*”）。 virtual/bootloader ebuild 
试着加载 /boot 分区，在我们的 chroot 中会失败。
</warn>

<note>
确保你检查 <path>/etc/make.profile/packages</path>
和 <path>/usr/portage/profiles/package.mask</path> 保证任何你要安装的
将测试软件包没有隐藏掉。
在写作时，<path>scripts/bootstrap.sh</path> 能够从源码编译
bootstrap 包。要使用已经存在的软件包，
增加 <c>alias emerge="emerge --usepkg"</c> 到你的 bootstrap 脚本顶上面的什么位置。
</note>

<p>
增加任何你想要得到的软件包。随意给你的虚拟
Gentoo 系统一个主机名，如果你愿意的话。在 <path>/etc/fstab</path>
中，你需要 <path>/dev/ROOT</path> 为 <path>/dev/ubd/0</path>，
一种 ext2，ext3，或 reiserfs 文件系统类型。设置 <path>/dev/SWAP</path>
为 <path>/dev/ubd/1</path>，和注释掉的 <path>/dev/BOOT</path>。
</p>

<p>
在此，记得设置你的 root 密码。</p>

<pre caption="设置 root 密码">
# <i>passwd</i>
</pre>

<p>
退出 chroot，卸载所有绑定加载，
tar 起新的 Gentoo 发布，并清理：
</p>

<pre>
# <i>exit</i>
# <i>umount /mnt/gentoo/usr/portage/distfiles</i>
# <i>umount /mnt/gentoo/usr/portage/packages</i>
# <i>umount /mnt/gentoo/proc</i>
# <i>du -ks /mnt/gentoo</i>
<!-- wtf is this? 261744	/mnt/gentoo-->
<!-- added dir change to be more explicit-->
# <i>cd /mnt/gentoo</i>
# <i>tar cvjpf ~/gentoo.tbz2 *</i>
# <i>cd</i>
# <i>rm -rf /mnt/gentoo</i>
</pre>

<p>
你也要考虑回顾
<uri link="http://www.gentoo.org/doc/en/gentoo-x86-install.xml">
Gentoo Linux x86 安装指南</uri>的最后步骤。 </p>
</body>
</section>

<section>
<title>建造 <path>root_fs</path></title>
<body>

<p>
我们的 Gentoo chroot 尺寸大约 300 MB，
所以 <path>root_fs</path> 大致需要那个大小。
我们会选取 0.5 GB 作为合理的大小。
</p>

<pre>
# <i>dd if=/dev/zero of=root_fs seek=500 count=1 bs=1M</i>
# <i>mke2fs -F root_fs</i>
# <i>mount -o loop root_fs /mnt/loop</i>
# <i>tar xvjpf gentoo.tbz2 -C /mnt/loop</i>
# <i>umount /mnt/loop</i>
</pre>

<p>
有0.5 GB 的交换空间也不错。
</p>

<pre>
# <i>dd if=/dev/zero of=swap_fs seek=500 count=1 bs=1M</i>
# <i>mkswap -f swap_fs</i>
</pre>

<p>
现在看看是否工作！
</p>

<pre>
# <i>linux ubd0=root_fs ubd1=swap_fs</i>
</pre>

<note>
用户模式 linux 使用 xterms 作为引导时的虚拟控制台，
所以你需要确保你运行用户模式 linux 的终端 $DISPLAY 设置恰当。
（需要恰当的 xhost/xauth 权限）。
</note>

<p>
运气好的话你应该能够登录你的用户模式 linux Gentoo 系统。
这个用户模式 Gentoo linux 版本和完全功能的差距仅仅是虚拟机器到宿主机器的网络。
</p>
</body>
</section>
</chapter>

<chapter>
<title>网络</title>

<section>
<body>
<p>
感谢 Martin Schlemmer (Azarah)，我现在知道了
如何在用户模式系统内使用网络。
思想是我们建立一个包含用户模式系统和宿主系统的私有网络，
然后用户模式系统把所有的通信包都路由到宿主系统，
它再将包发送到网上。
确保宿主内核有 
Networking --> IP: Netfilter Configuration --> IP tables support 
--> Full NAT --> MASQUERADE target support 和
Network Device Support --> Ethertap network tap
编译为模块；然后在<e>宿主</e>机器上这样操作：
</p>

<pre>
# <i>modprobe ethertap</i>
# <i>modprobe iptable_nat</i>
# <i>iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</i>
# <i>echo 1 > /proc/sys/net/ipv4/ip_forward</i>
</pre>

<p>
iptables 那行在我们用户模式系统和互联网之间设置 IP 伪装
（在我们这里通过 <c>eth0</c> ）。echo 那行启动私有网络和缺省网管界面之间的包转发
（我们这是 eth0）。
</p>

<p>
现在开动用户模式系统，来看看网络是否已经起作用了。
</p>

<pre>
# <i>linux ubd0=root_fs ubd1=swap_fs eth0=ethertap,tap0,,192.168.0.254</i>
<comment>（登录到用户模式系统）</comment>
# <i>ifconfig eth0 192.168.0.1 up</i>
# <i>ping -c 2 192.168.0.254</i>
PING 192.168.0.254 (192.168.0.254): 56 octets data
64 octets from 192.168.0.254: icmp_seq=0 ttl=255 time=0.8 ms
64 octets from 192.168.0.254: icmp_seq=1 ttl=255 time=0.6 ms

--- 192.168.0.254 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 0.6/0.7/0.8 ms
<i>route add default gw 192.168.0.254</i>
<i>netstat -rn</i>
Kernel IP routing table
Destination  Gateway        Genmask        Flags MSS Window irtt Iface
192.168.0.0  0.0.0.0        255.255.255.0  U      40 0         0 eth0
0.0.0.0      192.168.0.254  0.0.0.0        UG     40 0         0 eth0
<i>scp user@192.168.0.254:/etc/resolv.conf /etc/resolv.conf</i> <comment>（如果需要）</comment>
<i>ping -c 2 www.gentoo.org</i>
PING www.gentoo.org (207.170.82.202): 56 octets data
64 octets from 207.170.82.202: icmp_seq=0 ttl=240 time=119.6 ms
64 octets from 207.170.82.202: icmp_seq=1 ttl=240 time=92.0 ms

--- www.gentoo.org ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max = 92.0/105.8/119.6 ms
</pre>

<p>
在用户模式系统中，我们把私有 IP 地址192.168.0.1分配给用户模式的 eth0 界面，
并启动界面。宿主主机的私有 IP 是192.168.0.254，我们 ping 它，以确定我们的网络确实已经起来了。
route 那行增加一个缺省网关，即我们的宿主主机。
我们用 scp 拿回一个可以工作的 <path>/etc/resolv.conf</path>（如果必要），
我们 ping  www.gentoo.org来确定我们用户模式系统域名解析（一般互联网访问）工作正常。
现在用户模式系统可以完全 <c>emerge</c> 了。
</p>
</body>
</section>
</chapter>

<chapter>
<title>测试 .iso</title>

<section>
<body>

<p>
也许 Gentoo Linux 测试的真实意图是P
从用户模式 linux 引导 .iso，
并且在用户模式 linux 虚拟系统完全安装 Gentoo。
</p>

<p>
引导 .iso或者从.iso 取得 initrd，巧妙直接。
</p>

<pre>
# <i>mount -o loop /path/to/build-&lt;TAB&gt;.iso /mnt/loop</i>
# <i>cp /mnt/loop/isolinux/rescue.gz .</i>
# <i>linux load_ramdisk=1 prompt_ramdisk=0 ramdisk_size=22000 \</i>
&gt; <i>initrd=rescue.gz root=/dev/ram0 ubd0=root_fs ubd1=swap_fs \</i>
&gt; <i>ubd2=/dev/cdroms/cdrom0 eth0=ethertap,tap0,,192.168.0.254</i>
</pre>
<p>现在你基本上可以按部就班的遵从 Gentoo 安装文档，
即使你需要知道根文件系统是
<path>/dev/ubd/0</path>，交换“分区”会是
<path>/dev/ubd/1</path>，CD 光驱会是
<path>/dev/ubd/2</path>。</p>
</body>
</section>
</chapter>

</guide>
