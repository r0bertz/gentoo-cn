<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="/xsl/guide.xsl" type="text/xsl"?>
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">
<guide link="/doc/zh_cn/gentoo-x86-install.xml">
<title>Gentoo Linux 1.4 安装指南</title>
<author title="Chief Architect">
    <mail link="drobbins@gentoo.org">Daniel Robbins</mail>
</author>
<author title="Author">Chris Houser</author>
<author title="Author">Jerry Alexandratos</author>
<author title="Ghost, Reviewer">
    <mail link="g2boojum@gentoo.org">Grant Goodyear</mail>
</author>
<author title="Editor">
    <mail link="zhen@gentoo.org">John P. Davis</mail>
</author>
<author title="Editor">
    <mail link="Pierre-Henri.Jondot@wanadoo.fr">Pierre-Henri Jondot</mail>
</author>
<author title="Editor">
    <mail link="stocke2@gentoo.org">Eric Stockbridge</mail>
</author>
<author title="Editor">
    <mail link="rajiv@gentoo.org">Rajiv Manglani</mail>
</author>
<author title="Editor">
    <mail link="seo@gentoo.org">Jungmin Seo</mail>
</author>
<author title="Editor">
    <mail link="zhware@gentoo.org">Stoyan Zhekov</mail>
</author>
<author title="Editor">
    <mail link="jhhudso@gentoo.org">Jared Hudson</mail>
</author>
<author title="Editor">Colin Morey</author>
<author title="Editor">
    <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Editor">
    <mail link="carl@gentoo.org">Carl Anderson</mail>
</author>
<author title="Editor, Reviewer">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Editor">
    <mail link="avenj@gentoo.org">Jon Portnoy</mail>
</author>
<author title="Editor">
     <mail link="klasikahl@gentoo.org">Zack Gilburd</mail>
</author>
<author title="Reviewer">
    <mail link="gerrynjr@gentoo.org">Gerald J. Normandin Jr.</mail>
</author>
<author title="Reviewer">
    <mail link="spyderous@gentoo.org">Donnie Berkholz</mail>
</author>
<author title="Reviewer">
    <mail link="antifa@gentoo.org">Ken Nowack</mail>
</author>
<author title="Editor, Reviewer">
    <mail link="bennyc@gentoo.org">Benny Chuang</mail>
</author>

<abstract>
These instructions step you through the process of installing Gentoo
Linux 1.4, release version (not _rc versions). The Gentoo Linux installation 
process supports various installation	approaches, depending upon how much of 
the system you want to custom-build from scratch.
</abstract>

<license/>

<version>2.6.17</version>
<date>September 30, 2003</date>

<chapter>
<title>安装简介</title>
<section>
<body>

<p>
首先，如果你是个gentoo新手，欢迎你进入Gentoo Linux世界！Gentoo Linux
可以采取多种方法安装。如果你在寻找一种快捷安装方法，你可以使用预编译包安装，
如果你想安装过程完全由自己来定义，你可以从源代码来编译你的Gentoo Linux。
采用哪种方法完全取决于你。
</p>

<p>
官方1.4发布版本的重要变化就是我们所提供的2CD的安装套装。这份套装你可以在<uri
link="http://store.gentoo.org">The Gentoo Linux Store</uri>订购，或者
访问我们的<uri link="http://www.gentoo.org/main/en/mirrors.xml">镜像站点下载
</uri>。我们现在提供的2CD安装套装支持x86 (486及以上),i686 (Pentium Pro, Pentium II, Athlon/Duron及以上), Pentium III,
Pentium 4 and Athlon XP。想知道你所需要哪一种安装套装，请阅读<uri
link="http://store.gentoo.org">store</uri>中每种产品的详细说明，说明中对各种CPU平台做了相关介绍。
</p>

<p>
你可以在我们的镜像上下载各种LiveCD。其中x86平台的LiveCD位于<path>releases/x86/1.4/livecd/</path>子目录中。
</p>

<p>
现在我们来看看安装套装中的内容：第一张CD（CD1）我们称作“Live CD 安装盘”，它是一张启动光盘，这意味着你可以直接将其放入CD驱动器来运行
Gentoo Linux。你可以使用这张光盘来把Gentoo Linux安装到你的硬盘中。除了内置启动环境之外，CD1包含了你快速安装Gentoo Linux所需的所有东西，甚至不需要网络连接。同时CD1中还包括了一些如重要的XFree X服务器组件等预编译的软件包。如果你有CD1的ISO镜像文件，命名时要在后面加上<path>-cd1</path>字样。
</p>

<p>
与CD1不同，第二张CD（CD2）不能用来启动系统，CD2中包含大量系统所需的预编译软件包，如优化过的KDE,GNOME,OpenOffice,Mozilla,
Evolution等。CD2<e>不是</e>必须的，主要是针对那些想简易快速安装Gentoo Linux的人设计的。CD2中所有的软件包在标准的单CPU平台下，如果要从源代码开始编译的话大约需要
36个小时。如果你有CD2的ISO镜像文件，命名时要在后面加上<path>-cd2</path>字样。
</p>

<note>
完整的Gentoo Linux安装光盘套装包含一套 Gentoo参考平台（Gentoo Reference Platform），它是一个包括了GNOME,KDE, Mozilla and OpenOffice的完整的预编译Gentoo Linux,。使用Gentoo Reference Platform ("GRP")来可以实现快速打包安装Gentoo Linux。
“原始编译(compile from source)”方法包含所有的安装功能和选项。设计GRP的的目的是为了让部分用户安装Gentoo Linux更为方便快速，而不需
接触到Gentoo最为强大原始编译”安装模式。
</note>

<p>
除了2CD安装套装以外，我们还提供一种称为“基本(basic)”的可启动系统的Live CD。系统启动后，你可以配置你的网络连接，然后从网络开始安装
Gentoo Linux。“basic”光盘的优势在于体积小所以其ISO文件更便于下载。如果你是个高级用户，并且具备较快的网络连接速度，想安装最新的
Gentoo Linux,那么这是你最佳的选择。如果你有“basic”Live CD的ISO镜像文件，命名时要在后面加上<path>-basic</path>字样。
</p>
		
<p>
不管选择何种方法安装Gentoo Linux，你必须具备以下硬件条件：486以上处理器，至少64M内存（虽然Gentoo Linux可以在64M内存＋64M交换空间下
运行，但运行速度较慢）。
</p>

<p>
如果你使用我们Live CD启动了系统，你可以选择几种安装方式。Gentoo Linux可以从三个&quot;stage&quot;压缩包文件中的一个开始安装。
选择哪一个要看你的最终系统中自己编译的部分占多大比例。如果你选择stage1,你将需要bootstrap然后来自己建立系统；stage2压缩包文件通常是
stage1的“半成品”；stage3压缩包包含了一个已经编译好的Gentoo Linux基础系统。如果你对“GRP”安装方式感兴趣，你就应该选择stage3。
</p>

<p>
<b>
如果你不采用GRP方式安装，那么应该选择 stage1,stage2和stage3中的哪一个呢？</b>
下面的介绍应该能帮你做出选择。
</p>

<p>
从stage1开始安装，你能够完全自定义和控制编译过程的优化设置来初始你的系统。这使得高级用户可以知道自己在做什么。这也是一个让你更多
了解Gentoo Linux核心的方法。
</p>

<p>
从stage2开始安装，你可以跳过bootstrap，这样你可以应用到我们特别为stage2做的各种优化设置。
</p>

<p>
从stage3开始安装，你将可以快速地安装 Gentoo Llinux,这意味着你的系统将是我们为你所编译的（主要指比较完善的设置，较高的效率和
稳定性）。Gentoo Linux的重要发布版本都有特别为stage3做的最佳优化，所以从stage3开始安装你将可以获得一个快速优化过的系统。
</p>

<p>
<b>
如果你是第一次安装 Gentoo Linux, 请选择 stage3 压缩包，或基于 stage3 的GRP。</b>
</p>

<note>
<b>高级用户:</b>
如果你使用stage3安装，请不要修改<path>/etc/make.conf</path>中的 CHOST 设置值。如果必须修改，你应该从stage1开始
编译你的而系统和需要的 CHOST 设置。CHOST的设置一般应该象这样：<c>i686-pc-linux-gnu</c>。
</note>

<impo>
如果你在安装过程中遇到问题，而且愿意报告错误（BUG）的话，请访问<uri>http://bugs.gentoo.org</uri>。
如果这个错误需要返回到开发者（比如KDE开发组）<e>Gentoo Linux Developers</e>会为你发送。
</impo>

<note>
Live CD安装指南也许已经过期，查看最新文档请访问：<uri>http://www.gentoo.org/doc/en/gentoo-x86-install.xml</uri>。
</note>

<p>
现在，让我们概括一下安装过程。首先，我们要下载、刻录一张LiveCD。然后用它开机启动到有一个root提示（prompt），接下来我们要
建立硬盘分区和文件系统，释放stage1、stage2或stage3压缩包。如果使用stage1或stage2开始，我们必须一步一步进行直到stage3。当系统
达到stage3状态，我们要进行必要的设置（设定相关配置文件，安装一个启动程序等等），重启之后我们将有一个具备基本功能的Gentoo Linux
系统。当你的基本系统正常运转之后，你可以用我们提供的2CD安装套装中的“CD2”来安装你需要的预编译的软件包，如KDE，GNOME，OpenOffice
,Mozilla等。
</p>

<p>
根据你选择的安装方式，下面是各种方式一个对照：
</p>

<table>
<tcolumn width="0.75in"/>
<tcolumn width="1in"/>
<tcolumn width="1.25in"/>
<tcolumn width="3.5in"/>
<tr>
 <th>Stage压缩包</th>
 <th>是否需要网络连接</th>
 <th>所需安装介质</th>
 <th>步骤</th>
</tr>
<tr>
 <ti>1</ti>
 <ti>是</ti>
 <ti><e>basic</e> 或 <e>CD 1</e></ti>
 <ti>硬盘分区/建立文件系统, emerge sync, bootstrap, emerge system, 最后设置</ti>
</tr>
<tr>
 <ti>2</ti>
 <ti>是</ti>
 <ti><e>basic</e> 或 <e>CD 1</e></ti>
 <ti>硬盘分区/建立文件系统, emerge sync, emerge system, 最后设置</ti>
</tr>
<tr>
 <ti>3</ti>
 <ti>如果使用CD1不需要，其它则需要</ti>
 <ti><e>basic</e> 或 <e>CD 1</e></ti>
 <ti>硬盘分区/建立文件系统, emerge sync (使用 <e>CD 1</e>则不需要), 最后设置</ti>
</tr>
<tr>
 <ti>3+GRP</ti>
 <ti>否</ti>
 <ti><e>CD 1</e>, <e>CD 2</e> 可选</ti>
 <ti>硬盘分区/建立文件系统, 最后设置, 安装CD1上的软件包 (可选), 重启, 安装其它如 KDE，GNOME等软件包（使用 CD2）</ti>
</tr>
</table>

<note>
ATA RAID硬件用户开始安装前需阅读本文档尾部的关于ATA RAID说明。
</note>

</body>
</section>
</chapter>

<chapter>
<title>启动</title>
<section>
<body>

<warn>
开始前需认真阅读本节，特别是启动参数。否则可能导致误设键盘、无法启动 pcmcia 服务等...
</warn>

<p>
使用LiveCD启动机器后，你会看到一个漂亮的 Gentoo 图示。这时你可以按下 Enter 键来开启安装进程，
或使用LiveCD的自定义启动参数然后按下 Enter 键。如：<c>gentoo nousb nohotplug</c>。
如果你的机器有一个以上的处理器（"SMP"），你应该在提示符下键入<c>smp</c>而不是<c>gentoo</c>。
这样 LiveCD 就可以检测到你所有的CPU,而不仅仅是第一个。
</p>

<p>
参考下表了解可用的内核参数和选项，或者按 F2、F3查询帮助。
</p>

<table>
<tcolumn width="2in"/>
<tcolumn width="4in"/>
<tr><th>可用内核</th><th>说明</th></tr>
<tr><ti>gentoo</ti><ti>标准Gentoo内核 (默认值)</ti></tr>
<tr><ti>nofb</ti><ti>关闭framebuffer模式</ti></tr>
<tr><ti>smp</ti><ti>在noframebuffer模式下载入smp内核</ti></tr>
<tr><ti>acpi</ti><ti>开启acpi + 初始过程加载 acpi 模块</ti></tr>
<tr><ti>memtest</ti><ti>启动时开启内存检测程序</ti></tr>
</table>

<table>
<tcolumn width="2in"/>
<tcolumn width="4in"/>
<tr><th>可用启动选项</th><th>说明</th></tr>
<tr><ti>doataraid</ti><ti>从 initrd 装载 ide raid 模块</ti></tr>
<tr><ti>dofirewire</ti><ti>从 initrd 装载 firewire 模块 (适用于 firewire cdroms,等.)</ti></tr>
<tr><ti>dokeymap</ti><ti>启用 non-us 键盘布局映射</ti></tr>
<tr><ti>dopcmcia</ti><ti>启用 pcmcia 服务</ti></tr>
<tr><ti>doscsi</ti><ti>检测 scsi 设备 (可能对某些网卡造成损害)</ti></tr>
<tr><ti>noapm</ti><ti>关闭 apm 模块</ti></tr>
<tr><ti>nodetect</ti><ti>禁止 hwsetup/kudzu 以及 hotplug 程序运行</ti></tr>
<tr><ti>nodhcp</ti><ti>关闭 DHCP</ti></tr>
<tr><ti>nohotplug</ti><ti>关闭 hotplug 服务</ti></tr>
<tr><ti>noraid</ti><ti>关闭 evms 模块</ti></tr>
<tr><ti>nousb</ti><ti>关闭从 initrd 装载 USB 模块,禁止 hotplug</ti></tr>
<tr><ti>ide=nodma</ti><ti>强制关闭无法使用的IDE设备的DMA</ti></tr>
<tr><ti>cdcache</ti><ti>缓存光盘中的数据到内存。这可能需要占用40M内存,但这样你可以卸载<path>/mnt/cdrom</path>
来挂载其它光盘。</ti></tr>
</table>

<p>
当你按下 Enter 键，你会看到一个更漂亮的启动界面和一个进度条。
</p>

<p>
启动进程完成后，你会自动登录为“root”，最高权限用户。你会看到一个 root 终端提示符（“#”）
,同时你可以通过按 Alt-F2,Alt-F3及Alt-F4来切换到其它终端界面。返回第一个终端请按Alt-F1。
</p>

<note>
<b>高级用户:</b>
当 LiveCD 启动后，出于安全原因，root的登录密码是随机设定的，如果你要使用<c>sshd</c>来进行远程登录LiveCD，你必须键入<c>passwd</c>，
根据提示来重新设定 Live CD 的 root 登录密码，否则你将无法通过网络远程登录 LiveCD。
</note>

<p>
你应该也注意到 # 上方有一些说明文字, 这些文字将告诉你如何设定你的网络连接以及光盘里 Gentoo Linux Stage 压缩包和其它软件包的位置。
</p>

</body>
</section>
</chapter>

<chapter>
<title>选择性硬件设置</title>
<section>
<body>

<p>
当Live CD启动时，它会尝试检测你的所有硬件并装载相应的内核模块。大部分情况下，它可以做得很好，但某些情况下，它可能会
漏掉一些你需要的模块。如果 PCI自动检测错过了一些系统硬件，你必须手动装载相应的内核模块。如要查看所有支持的网卡模块，键入
<c>ls /lib/modules/`uname -r`/kernel/drivers/net/*</c>，装载某个模块键入：
</p>

<pre caption="PCI 模块设置">
# <i>modprobe pcnet32</i>
<comment>(替换 pcnet32 为你的网卡模块名)</comment>
</pre>

<p>
如果你正使用某些未被检测到的 SCSI 硬件，你需要从<path>/lib/modules</path>中装载相应模块，方法如下：
</p>

<pre caption="装载 SCSI 模块">
# <i>modprobe aic7xxx</i>
<comment>(替换 aic7xxx 为你的 SCSI 适配器模块名)</comment>
# <i>modprobe sd_mod</i>
<comment>(sd_mod 是模块支持的 SCSI disk磁盘)</comment>
</pre>

<note>
SCSI 光盘驱动器和硬盘已在内核里支持
</note>

<note>
<b>高级用户:</b>
Gentoo LiveCD 默认已经开启硬盘 DMA 模式以加快硬盘数据传输速度,如果没有，你可以使用 <c>hdparm</c> 命令来开启硬盘 DMA,方法如下：
<pre caption="设置 DMA">
<comment>(替换 hdX 为你的硬盘标识)</comment>
# <i>hdparm -d 1 /dev/hdX</i> 
<comment>(开启 DMA)</comment>
# <i>hdparm -d1 -A1 -m16 -u1 -a64 /dev/hdX</i>
<comment>(开启 DMA 和其它增强选项)</comment>
# <i>hdparm -X66 /dev/hdX</i>
<comment>(强制使用 Ultra-DMA -- 危险 -- 可能破坏硬盘数据)</comment>
</pre>
</note>

			
</body>
</section>
</chapter>
<chapter>
<title>选择性网络设置</title>
<section>
<title>或许系统已经设置好了?</title>
<body>

<p>
如果你的系统有一个网卡，很可能网络已经自动设置好了。如果是这样，你就可以使用LiveCD上提供的如
<c>ssh</c>,<c>scp</c>, <c>ping</c>, <c>irssi</c>, <c>wget</c> 和 <c>links</c>等网络工具了。
</p>
	  
<p>
如果网络设置完毕，可以使用<c>/sbin/ifconfig</c>命令来查看除 lo 以外的网络接口，比如 eth0 ：
</p>

<pre caption="用 /sbin/ifconfig 查看工作中的网络接口">
eth0      Link encap:Ethernet  HWaddr 00:50:BA:8F:61:7A
          inet addr:192.168.0.2  Bcast:192.168.0.255  Mask:255.255.255.0
          inet6 addr: fe80::50:ba8f:617a/10 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:1498792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1284980 errors:0 dropped:0 overruns:0 carrier:0
          collisions:1984 txqueuelen:100
          RX bytes:485691215 (463.1 Mb)  TX bytes:123951388 (118.2 Mb)
          Interrupt:11 Base address:0xe800 
</pre>

<p>
你应该尝试 ping 一下你的ISP的DNS服务器（地址可以在<path>/etc/resolv.conf</path>找到）或是你喜欢的其它网站，以确认你的
系统已经正常连接到网络，域名解析工作正常等等..
</p>

<pre caption="进一步的网络测试">
# <i>ping -c 3 www.yahoo.com</i>
</pre>

<p>
那么你的网络设置好了吗？如果是的，你可以跳过本节下面的部分。
</p>

</body>
</section>
<section>
<title>PPPoE 设置</title>
<body>

<p>
如果你使用 PPPoE 来连接到网络，LiveCD(任何版本)都已内置了一个<c>rp-pppoe</c>工具来帮你实现。你要做的就是
使用<c>adsl-setup</c>脚本来配置你的连接。你必须提供连接到 ADSL Modem 的网络接口、帐户名和密码、DNS的IP地址
以及是否需要设置防火墙。
</p>

<pre caption="配置 PPPoE">
# <i> adsl-setup </i>
# <i> adsl-start </i>
</pre>

<p>
如果发生错误，请仔细检查<path>/etc/ppp/pap-secrets</path>中的帐户名和密码，以及<path>/etc/ppp/chap-secrets</path>
中设定的网络接口是否正确。
</p>

</body>
</section>

<section>
<title>自动网络设置 </title>
<body>

<p>
如果网络没有自动设置好，最简单的方法就是运行<c>net-setup</c> script:
</p>

<pre caption="网络设置脚本">
# <i>net-setup eth0</i>
</pre>

<p>
当然，如果你高兴，你可以手动设置网络，下面将教你如何做：
</p>

</body>
</section>
<section>
<title>手动配置动态IP（DHCP）</title>
<body>

<p>
设置 DHCP 非常简单，如果你使用静态IP，请跳到下面静态IP设置部分。
</p>

<pre caption="DHCP 设置">
# <i>dhcpcd eth0</i>
</pre>

<note>
某些 ISP 需要提供主机名（hostname）,如果需要，请在上面命令后加上<c>-h 你的主机名</c>参数。
</note>

<p>
如果你看到 <e>dhcpConfig</e> 警告, 别紧张，请跳至下面网络测试部分。
</p>

</body>
</section>
<section>
<title>手动设置静态IP</title>
<body>

<p>
我们只需要设置网络能够让我们下载系统构件所需的源代码，Localhost界面就可以了。下表是需要设置的参数以及说明。
</p>

<table>
<tcolumn width="1.25in"/>
<tcolumn width="4in"/>
<tcolumn width="1.25in"/>
<tr><th>参数</th><th>说明</th><th>示例值</th></tr>
<tr><ti>IP地址</ti><ti>你的网卡必须指定一个IP地址</ti><ti>192.168.1.2</ti></tr>
<tr><ti>广播地址(Broadcast)</ti><ti>向这个网络上的其它主机广播你的IP地址</ti><ti>192.168.1.255</ti></tr>
<tr><ti>子网掩码(Netmask))</ti><ti>子网掩码配合IP地址使用同一网络，以方便查询你的IP地址是在哪个网络里面，便于辨认主机</ti><ti>255.255.255.0</ti></tr>
<tr><ti>网关(Gateway)</ti><ti>用于转发你的的IP地址封包到本地网络以外的地方（通常用于 Internet 共享）</ti><ti>192.168.1.1</ti></tr>
</table>

<p>
键入一下命令, 替换 <c>$IFACE</c>为你的网络接口 (通常为 <c>eth0</c>), 替换<c>$IPNUM</c> 为你的IP地址,
替换<c>$BCAST</c> 为你的广播地址，替换 <c>$NMASK</c> 为你的子网掩码。
对于<c>route</c> 命令,替换 <c>$GTWAY</c> 为你的默认网关地址。
</p>

<pre caption="静态 IP 设置">
# <i>ifconfig $IFACE $IPNUM broadcast $BCAST netmask $NMASK</i>
# <i>route add -net default gw $GTWAY netmask 0.0.0.0 metric 1 $IFACE</i>
</pre>

<p>
接下来我我们来建立<path>/etc/resolv.conf</path>文件，用来解析域名（用域名来定位 Web/FTP 服务器而不是用IP地址）。
你可以使用<c>nano -w /etc/resolv.conf</c>来创建<path>/etc/resolv.conf</path>。 <c>nano</c> 是一个小巧易用
的文本编辑器。
</p>

<p>
下面是一个 <path>/etc/resolv.conf</path>文件范例：
</p>

<pre caption="/etc/resolv.conf 范例">
domain mydomain.com
nameserver 10.0.0.1
nameserver 10.0.0.2
</pre>

<p>
替换<c>10.0.0.1</c> 和 <c>10.0.0.2</c> 为你的主DNS和辅DNS地址。
</p>

</body>
</section>

<section>
<title>代理服务器设置</title>
<body>

<p>
如果你必须使用代理服务器，你必须在开始前先设置你的代理服务器环境变量：
</p>

<pre caption="设置代理服务器">
<comment>HTTP 代理服务器:</comment>
# <i>export http_proxy="http://machine.company.com:1234"</i>
<comment>FTP 代理服务器:</comment>
# <i>export ftp_proxy="ftp://machine.company.com"</i>
<comment>RSYNC 代理服务器:</comment>
# <i>export RSYNC_PROXY="rsync://machine.company.com"</i>
</pre>

</body>
</section>

<section>
<title>网络设置完成！</title>
<body>

<p>
到此，网络应该已经设置完毕了。你可以使用内置的<c>ssh</c>, <c>scp</c>, <c>links</c>, <c>irssi</c> 和 <c>wget</c>
命令连接到网络。
</p>

</body>
</section>
</chapter>

<chapter>
<title>设置系统日期和时间</title>
<section>
<body>

<p>
现在你需要使用<c>date</c>命令设置系统的日期和时间。
</p>

<pre caption="设置系统日期">
# <i>date</i>
Thu Feb 27 09:04:42 CST 2003
<comment>(如果日期有误，使用下面的命令来设置)</comment>
# <i>date 022709042003</i>
<comment>(日期格式：月日时分年)</comment>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>文件系统、硬盘分区和区块设备</title>
<section>
<title>区块设备简介</title>
<body>

<p>
这个部分，我们将仔细介绍一下Gentoo Linux和大部分Linux有关磁盘、Linux 文件系统、硬盘分区以及
区块设备的概念。一旦你熟悉了这部分内容，你就可以进入下面硬盘分区和建立文件系统安装部分。
</p>

<p>
我们将以”区块设备“开始。最有名的区块设备恐怕就是Linux系统中的第一个IDE设备了：
</p>

<pre caption="/dev/hda, 代表你系统中的第一个IDE设备">
/dev/hda
</pre>

<p>
如果你的系统使用的是SCSI硬盘, 那么你的第一个SCSI设备就是:
</p>

<pre caption="/dev/sda, 代表你系统中的第一个SCSI设备">
/dev/sda
</pre>

<p>
以上的区块设备代表<e>连接磁盘</e>的界面。用户程序可以访问磁盘而不用关心你的硬盘是IDE、SCSI还是其它类型。
程序将随机读取512-byte区块镜像简单磁盘存取。
</p>

</body>
</section>
<section>
<title>硬盘分区和 fdisk</title>
<body>

<p>
Linux下，我们使用<c>mkfs</c> (或者 <c>mke2fs</c>, <c>mkreiserfs</c>, 等.)命令后面接
上设备名来创建文件系统。
</p>

<p>
当然，你可以将整个硬盘来作为一个分区，例如<path>/dev/hda</path>或<path>/dev/sda</path>，但实际上没人这样做。
一般情况下，我们将硬盘划分成几个小一点的分区，我们称之为“partitions”。我们使用<c>fdisk</c>这个工具来划分分区并指定
其大小。
</p>

<p>
我们也用 <c>fdisk</c>来查看分区表，所以我们要指定一个硬盘设备给它作为参数：
</p>

<note>
除了“fdisk”以外，还有<c>cfdisk</c>、<c>parted</c> 和 <c>partimage</c>可以用来分区。我们建议使用<c>fdisk</c>，
因为它是 Unix/Linux 世界里最知名的强大分区工具。</note>

<pre caption="运行 fdisk">
# <i>fdisk /dev/hda</i>
</pre>

<p>
或者
</p>

<pre caption="运行 fdisk 查看/dev/sda分区表">
# <i>fdisk /dev/sda</i>
</pre>

<impo>
如果你的硬盘和分区中有重要数据，请<e>不要</e>将变动保存至分区表，否则会导致数据丢失。
</impo>

<p>
运行<c>fdisk</c>后，你会看到下面的提示：
</p>

<pre caption="fdisk 提示符">
Command (m for help): 
</pre>

<p>
键入<c>p</c> 来显示当前硬盘分区设置：
</p>

<pre caption="分区设置范例">
Command (m for help): <i>p</i>

Disk /dev/hda: 240 heads, 63 sectors, 2184 cylinders
Units = cylinders of 15120 * 512 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1        14    105808+  83  Linux
/dev/hda2            15        49    264600   82  Linux swap
/dev/hda3            50        70    158760   83  Linux
/dev/hda4            71      2184  15981840    5  Extended
/dev/hda5            71       209   1050808+  83  Linux
/dev/hda6           210       348   1050808+  83  Linux
/dev/hda7           349       626   2101648+  83  Linux
/dev/hda8           627       904   2101648+  83  Linux
/dev/hda9           905      2184   9676768+  83  Linux

Command (m for help): 
</pre>

<p>
上面的画面显示这个硬盘有7个Linux分区（分区后面标识 "Linux")和一个交换分区(swap)（分区后面标识 "Linux swap"）。
</p>

<p>
每个分区名在左面显示，从<path>/dev/hda1</path>一直到<path>/dev/hda9</path>。
早期的PC上，分区工具只能在一个硬盘上划分4个分区（称为 "primary"（主）分区）。有点限制，新版的"fdisk"可以使用
<e>extended partitioning（扩展分区）</e>。一个扩展分区中可以创建多个<e>logical（逻辑分区）</e>,因此克服
了4个主分区的限制。
</p>

<p>
从<path>/dev/hda5</path>开始后面的都是逻辑分区。1到4是为主分区和扩展分区保留的。
</p>

<p>
因此我们看到，上面的例子中，<path>hda1</path> 到 <path>hda3</path>是三个主分区。
<path>hda4</path>是扩展分区，它包含了从<path>hda5</path> 到 <path>hda9</path>的5个
逻辑分区。实际上你<e>不能</e>使用扩展分区<path>hda4</path>来建立文件系统－－所以我们能建立文件系统的只有
<path>hda1</path> 到 <path>hda3</path> 和 <path>hda5</path> 到 <path>hda9</path>。
</p>

<p>
同时我们注意到每个分区都有一个 "Id"，也叫“分区类型”。一旦你建立了一个分区，你必须同时正确设定它的分区类型。
‘83’代表Linux文件系统，‘82’代表Linux swap交换分区类型，‘fd’是使用软件RAID推荐的类型。你可以使用<c>fdisk</c>中的
<c>t</c>选项来设定分区类型。Linux内核在启动时会按照分区类型自动检测文件系统和交换分区。
</p>

</body>
</section>

<section>
<title>使用 fdisk 来建立硬盘分区</title>
<body>

<p>
现在你是否对硬盘分区有一定的了解了呢？下面我们将带你一步一步建立硬盘分区。当你建立好硬盘分区后，你的分区表
应该象这个样子：
</p>

<pre caption="完成分区后的分区表">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1   *         1        14    105808+  83  Linux
/dev/hda2            15        81    506520   82  Linux swap
/dev/hda3            82      3876  28690200   83  Linux

Command (m for help):
</pre>

<p>
我们建议新手建立三个分区。第一个分区（<path>/dev/hda1</path>）是位于硬盘最前面的一个小分区称作启动分区。
启动分区保存着系统启动时需要的重要数据－－如Grub启动程序（如果你使用Grub）、Linux系统内核。
启动分区是为了确保系统启动数据不被意外所影响。正常情况下启动分区是<e>unmounted</e>(不被挂载)的。
如果你使用SCSI，你的启动分区应该是<path>/dev/sda1</path>。
</p>

<p>
我们建议把启动分区放在硬盘最前面，虽然这不是强制性的，但这是一个有用的老办法，因为以前的lilo
无法在超过1024 cylinder（柱面）处装载内核。
</p>

<p>
第二个分区(<path>/dev/hda2</path>)用来建立交换分区(swap)。内核在内存用尽时将其用来当作虚拟内存。这个分区
不需太大，一般 512MB 即可。如果你使用SCSI，这个分区应该是<path>/dev/sda2</path>。
</p>

<p>
第三个分区应该足够大，或许你应该把全部剩余空间给它。这个分区我们称作根("root")分区，其中我们要存储所有系统数据和
Gentoo Linux本身。如果你使用SCSI，这个分区应该是<path>/dev/sda3</path>。
</p>

<p>
在开始分区之前，请阅读下面的关于分区和文件系统的建议说明。
</p>

<table>
<tcolumn width="1.5in"/>
<tcolumn width="2.5in"/>
<tcolumn width="2.5in"/>
<tcolumn width="1in"/>
<tr>
 <th>分区</th>
 <th>大小</th>
 <th>类型</th>
 <th>设备范例</th>
</tr>
<tr>
 <ti>启动分区，包含内核和启动数据</ti>
 <ti>32 Mb</ti>
 <ti>建议使用ext2/3 (最简单); 如果使用 ReiserFS 在挂载时要加上 <c>-o notail</c> 参数。 如果你使用 ext3 或 ReiserFS, 在设定分区
 大小时一定要加入日志式记录空间，建议 64 Mb</ti>
 <ti><path>/dev/hda1</path></ti>
</tr>
<tr>
 <ti>swap 分区 (以前限制不大于 128 M,现在是 2GB)</ti>
 <ti>通常情况下，swap 空间一般介于系统物理内存的1到2倍</ti>
 <ti>Linux swap</ti>
 <ti><path>/dev/hda2</path></ti>
</tr>
<tr>
 <ti>root 根分区，包含主要系统数据 (/usr, /home, 等.)</ti>
 <ti>&gt;=1.5 Gb</ti>
 <ti>ReiserFS, 建议ext3 或 ext2</ti>
 <ti><path>/dev/hda3</path></ti>
</tr>
</table>

<p>
OK，现在我们来建立这些分区。首先键入<c>fdisk /dev/hda</c> 或 <c>fdisk /dev/sda</c>（倚赖于你使用IDE或SCSI硬盘）
。然后键入<c>p</c>来查看现有分区表。硬盘上有什么要保留的吗？如果有，请<b>马上停止</b>。如果继续的话，<b>所有
数据将会丢失</b>
</p>

<impo>
下面的步骤将会把硬盘上的数据全部<b>删除</b>!所以如果你的硬盘上有数据的话，请确认这些数据没有保留的必要。同时
再次确认你选择的是<b>正确的硬盘驱动器</b>。
</impo>

<p>
现在，我们把所有的分区删除。键入<c>d</c>然后按 Enter 键。你将会被提示删除哪个分区。要删除<path>/dev/hda1</path>，键入：
</p>

<pre caption="删除一个分区">
Command (m for help): <i>d</i>
Partition number (1-4): <i>1</i>
</pre>

<p>
这个分区已被设定为删除。如果你按 <c>p</c> 它将不会出现在分区表中，但注意在你保存修改到分区表之前，这个分区仍然存在，
如果你删除错误，请马上按 <c>q</c> 撤消刚才的删除操作。
</p>

<p>
现在，假如你确定要删除所有的分区，请重复按 <c>p</c> 显示分区表，然后按 <c>d</c> 和分区号来删除分区。最后你的分区表应该
象这个样子：
</p>

<pre caption="空白分区表">
Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System

Command (m for help):
</pre>

<p>
现在我们来建立启动分区（boot partition）。键入 <c>n</c> 建立新分区，然后按 <c>p</c> 告诉 fdisk
你想建立的是一个主分区，按 <c>1</c> 建立第一个主分区。当提示 first cylinder 时按 Enter 键，当提示
 last cylinder 时键入 <c>+32M</c> 设置分区大小为 32Mb。请参考下面说明：
</p>

<note>
日志文件系统需要额外的空间以存放日志数据。默认空间大小为 33 Mb，因次，如果你的启动分区使用日志文件系统，那么在 fdisk
提示 last cylinder 时键入 <c>+64M</c> 。
</note>

<pre caption="建立启动分区">
Command (m for help): <i>n</i>
Command action
e   extended
p   primary partition (1-4)
<i>p</i>
Partition number (1-4): <i>1</i>
First cylinder (1-3876, default 1): <comment>(Hit Enter)</comment>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-3876, default 3876): <i>+32M</i>
</pre>

<p>
现在，当你按 <c>p</c> 时，你就会看到如下输出：
</p>

<pre caption="已经建立的第一个分区">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
</pre>

<p>
接下来，我们建立交换分区（swap）。按 <c>n</c> 建立新分区，然后按 <c>p</c> 告诉 fdisk
你想建立的是一个主分区，按 <c>2</c> 建立第二个主分区。当提示 first cylinder 时按 Enter 键，
当提示 last cylinder 时键入 <c>+512M</c> 设置分区大小为 512Mb。然后按 <c>t</c> 来设置
分区类型为 <c>82</c> （”Linux Swap”）。然后按 <c>p</c> 来查看结果：
</p>

<pre caption="Swap 分区已经建立">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
</pre>

<p>
最后，我们来建立根分区。按<c>n</c> 建立新分区，然后按 <c>p</c> 告诉 fdisk
你想建立的是一个主分区，按 <c>3</c> 建立第三个主分区。当提示 first cylinder 时按 Enter 键，
当提示 last cylinder 时按 Enter 表示使用所有剩余空间。然后按 <c>p</c> 来查看结果：
</p>

<pre caption="根分区已经建立">
Command (m for help): <i>p</i>

Disk /dev/hda: 30.0 GB, 30005821440 bytes
240 heads, 63 sectors/track, 3876 cylinders
Units = cylinders of 15120 * 512 = 7741440 bytes

Device Boot    Start       End    Blocks   Id  System
/dev/hda1          1        14    105808+  83  Linux
/dev/hda2         15        81    506520   82  Linux swap
/dev/hda3         82      3876  28690200   83  Linux
</pre>

<p>
最后我们在启动分区上设置一个启动标识。标识 <path>/dev/hda1</path> 为“启动”分区，按 <c>a</c> 然后按
 <c>1</c> 。如果现在按 <c>p</c> ，你会看到 <path>/dev/hda1</path> 的“Boot”一栏上有一个 <c>*</c>标记。
现在，让我们将更改写入分区表。按 <c>w</c> 然后回车。你为 Gentoo Linux 安装所做的的硬盘分区工作就已经完成了。
</p>

<note>
如果你使用 <c>fdisk</c> 或 <c>cfdisk</c>，建立完分区后要重启系统以使系统能检测到新分区。
</note>

</body>
</section>

<section>
<title>建立文件系统</title>
<body>

<p>
现在分区已经建立，下面需要为启动分区和根分区建立文件系统，以使它们可以被挂载和存储数据。同时我们还要
配置交换分区以存储交换数据。
</p>

<p>
Gentoo Linux 支持多种文件系统，每种文件系统都有其长处和不足。目前我们支持ext2, ext3, XFS, JFS 和 ReiserFS
文件系统。
</p>

<p>
ext2文件系统是一种较旧的文件系统，不支持日志功能，启动时耗费的时间较长。目前新一代<e>日志</e>文件系统
可以以更快的速度和更高的效率启动系统检查。
</p>

<p>
ext3是基于ext2文件系统的日志版，提供了 metadata 日志系统，可以使用日志系统还原。ext3是一个相当不错且稳定的文件系统，在
大部分情况下都表现良好，不足之处是它不使用“Trees”，所以不能有效地处理过大的文件。但它参数设计不错，是个非常不错的文件系统。
</p>

<p>
ReiserFS整体来说是个不错的文件系统，由于它基于 B*-tree 设计，因此在处理小文件(小于 4k)时性能要优于ext2 和 ext3（
10％-15％）。对于内核版本在 2.4.18以上，推荐使用 ReiserFS 文件系统，从很少到大文件，到目录中的几万个文件，ReiserFS都能
达到较高的效率。启动分区不推荐使用 ReiserFS 文件系统。
</p>

<p>
XFS是一个日志文件系统，Gentoo Linux 也支持它，你可以使用 <c>xfs-sources</c> 内核配合 XFS。
如果你使用高速 SCSI 设备并配有不间断电源，我们推荐你使用XFS，否则请使用其它文件系统。
</p>  

<p>
JFS是IBM开发的高性能日志文件系统。虽然目前已是个成品，但关于稳定性没有更多的记录。
point.
</p>

<p>
如果你正在寻找一种耐用的日志文件系统，推荐使用 ext3，如果你想找一个各方面都相当优秀的日志文件系统，我们推荐使用 ReiserFS。
ext3和ReiserFS都相当成熟，推荐一般使用。
</p>

<p>
基于以上的介绍，我们使用下面的命令来为建立的分区建立文件系统：
</p>

<pre caption="建立文件系统 (范例)">
# <i>mke2fs -j /dev/hda1</i>
# <i>mkswap /dev/hda2</i>
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
我们将为启动分区 <path>/dev/hda1</path> 选择 ext3，因为这种文件系统坚固耐用并被大部分启动程序所支持。
我们用 <c>mkswap</c> 命令在 <path>/dev/hda2</path> 建立交换分区。根分区 <path>/dev/hda3</path>
我们选择 ReiserFS ，以为它能提供完整的日志系统并具有较高的性能。现在我们来建立文件系统：
</p>

<p>
你可以看到，在安装过程中有许多类似 <c>mkfs</c> 的命令：
</p>

<p>
<c>mkswap</c> 命令用来建立交换分区：
</p>

<pre caption="初始化交换分区">
# <i>mkswap /dev/hda2</i>
</pre>

<p>
建立 ext2 文件系统，使用 <c>mke2fs</c> 命令：
</p>

<pre caption="建立 ext2 文件系统">
# <i>mke2fs /dev/hda1</i>
</pre>

<p>
建立 ext3 文件系统，使用 <c>mke2fs -j</c>命令：
</p>

<pre caption="建立 an ext3 文件系统">
# <i>mke2fs -j /dev/hda3</i>
</pre>

<note>
有关2.4内核下使用 ext3 文件系统的其它信息请访问：
<uri>http://www.zip.com.au/~akpm/linux/ext3/ext3-usage.html</uri>.
</note>

<p>
建立 ReiserFS 文件系统,使用 <c>mkreiserfs</c> 命令：
</p>

<pre caption="建立 ReiserFS 文件系统">
# <i>mkreiserfs /dev/hda3</i>
</pre>

<p>
建立 XFS 文件系统, 使用 <c>mkfs.xfs</c> 命令：
</p>

<pre caption="建立 XFS 文件系统">
# <i>mkfs.xfs /dev/hda3</i>
</pre>

<note>
你可以在 <c>mkfs.xfs</c> 命令后加上 <c>-d agcount=3 -l size=32m</c> 参数。
<c>-d agcount=3</c> 参数表示减少簇群的数量。XFS 邀请每 4Gb 至少一个簇群，例如你有一个
20Gb的分区，那么这个参数至少要设为5。<c>-l size=32m</c> 参数表示增加日志存储空间到 32Mb 以提高性能。
</note>

<p>
建立 JFS 文件系统, 使用 <c>mkfs.jfs</c> 命令：
</p>

<pre caption="建立 JFS 文件系统">
# <i>mkfs.jfs /dev/hda3</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>挂载分区</title>
<section>
<body>

<p>
现在，我们先激活新建的交换分区，以便为下面的工作提供虚拟内存：
</p>

<pre caption="激活交换分区">
# <i>swapon /dev/hda2</i>
</pre>

<p>
下面我们将建立 <path>/mnt/gentoo/boot</path> 挂载点，然后挂载我们的系统到这个挂载点中。
一旦启动分区和根分区挂载完毕，任何复制到 <path>/mnt/gentoo</path> 中的文件就会成为我们新系统的一部分。
注意如果你有 <path>/usr</path> 或 <path>/var</path> 文件系统，你必须建立相应的目录
<path>/mnt/gentoo/usr</path> 和 <path>/mnt/gentoo/var</path>并挂载。
</p>

<impo>
如果你的启动分区（存有内核）使用 ReiserFS，那么在挂载时要确保带有 <c>-o notail</c>，这样Grub才能正确安装。
同时确保在你的新 <path>/etc/fstab</path> 文件中的 boot 分区一行也有 <c>notail</c> 参数（ReiserFS专用）。
如果你使用 Lilo 启动，你就不需要 <c>-o notail</c> 参数，如果你不确定，安全起见，就带上 <c>-o notail</c> 参数。
</impo>

<pre caption="创建挂载点">
# <i>mount /dev/hda3 /mnt/gentoo</i>
# <i>mkdir /mnt/gentoo/boot</i>
# <i>mount /dev/hda1 /mnt/gentoo/boot</i>
</pre>

<impo>
如果你在挂载 ext2 类型的启动分区时出错，请使用 <c>mount /dev/hXX /mnt/gentoo/boot -t ext2</c> 命令。
</impo>

</body>
</section>
</chapter>


<chapter>
<title>Stage 压缩包及 chroot</title>
<section>
<title>选择一个你想安装的 stage 压缩包</title>
<body>

<p>
现在，你必须选择要从哪一个stage压缩包开始安装。stage压缩包位于LiveCD的 <path>/mnt/cdrom/stages/</path> 目录中，
你可以键入 <c>ls /mnt/cdrom/stages/</c> 查看。
</p>

<p>
使用<b>GRP</b>安装的用户应该选择 <path>stage3-xx-yy.tar.bz2</path> 压缩包。
</p>

<p>
如果你想使用一个 <e>没有</e> 包括在光盘上的 stage 压缩包（如如果你使用"basic"光盘启动），你必须按照下面方法下载你需要的压缩包，
然后转至“释放压缩包”部分。
</p>

<note>
如果你使用代理服务器（如 proxy.server.tld:8080），在下面的 <c>links</c> 命令加入
 <c>-http-proxy proxy.server.tld:8080</c>。
</note>

<pre caption="下载所需的 Stages">
# <i>cd /mnt/gentoo</i>
<comment>使用 Link 命令来获取 stage 的地址:</comment>
# <i>links http://gentoo.oregonstate.edu/releases/x86/1.4/</i>
<comment>使用 <c>上</c>、<c>下</c> 方向键 (或者 <c>TAB</c> 键) 寻找你想下载的压缩包，
按 <c>d</c> 开始下载，存储文件然后离开 Link。

<b>另一个方法</b> 是使用 wget 命令：</comment>
# <i>wget </i><comment>(后面接要下载的 stage 压缩包地址)</comment>
</pre>

</body>
</section>
<section>
<title>释放 stage 压缩包</title>
<body>

<p>
现在我们来解压缩你选择的 stage 压缩包到 <path>/mnt/gentoo/</path>。记住，你只能在 stage1、stage2和stage3三个
压缩包中选择 <b>一个</b>。所以你选的是stage3，那么只要解压缩 stage3 压缩包：
</p>

<impo>
确保 <c>tar</c> 命令中有 <c>p</c> 参数，否则可能导致某些文件权限错误。
</impo>

<pre caption="释放 Stage">
# <i>cd /mnt/gentoo</i>
<comment>修改 "stage3-*.tar.bz2" 为你选择的 stage 压缩包文件名。</comment>
<comment>如果你是下载的 stage 压缩包，将 "/mnt/cdrom/stages/" 修改为你的下载的压缩包存放位置。</comment>
# <i>tar -xvjpf /mnt/cdrom/stages/stage3-*.tar.bz2</i>
</pre>

<p>
如果你把下载压缩包放在 <path>/mnt/gentoo</path>，现在你可以删除你下载的 stage 压缩包了，
键入 <c>rm /mnt/gentoo/stage*.tar.bz2</c>
</p>

</body>
</section>

<section>
<title>GRP 套装/快照 步骤</title>
<body>

<impo>
下面部分只使用于使用 GRP 安装方法用户。如果你不使用 GRP，请跳过这一段，从“选择镜像（可选）”继续。
</impo>

<p>
<b>GRP 用户</b>:Live CD中有一份 portage 快照。你需要使用这份快照，
由于 <c>emerge sync</c> 需要网络连接，所以请跳过下面的 <c>emerge sync</c> 一步。
下面我们来解开快照。
</p>

<pre caption="解开 Portage 快照">
<comment>替换 yyyymmdd 为文件名中的日期。</comment>
# <i>tar -xvjf /mnt/cdrom/snapshots/portage-yyyymmdd.tar.bz2 -C /mnt/gentoo/usr</i>
</pre>

<p>
上面的操作将会释放 portage 树到你的Gentoo系统中。现在你就不需连接到网络再 <c>emerge sync</c>
去下载 portage 树了。现在我们从 LiveCD 中把 distfiles和软件包复制过来：
</p>

<pre caption="复制 GRP 文件">
# <i>cp -R /mnt/cdrom/distfiles /mnt/gentoo/usr/portage/distfiles</i>
# <i>cp -a /mnt/cdrom/packages /mnt/gentoo/usr/portage/packages</i>
</pre>

<p>
所有需要文件都已经复制到硬盘中了，现在你可以不用连接到网络继续安装 Gentoo Linux 了。
</p>

</body>
</section>

<section>
<title>选择 Mirrors (可选)</title>
<body>

<p>
<c>mirrorselect</c> 是一个帮你自动/手动寻找速度最快镜像的工具。
不过, <c>mirrorselect</c> 的缺点是在防火墙和路由器后无法正常运行。
</p>

<pre caption="使用 mirrorselect">
<comment>自动选择镜像:</comment>
# <i>mirrorselect -a -s4 -o &gt;&gt; /mnt/gentoo/etc/make.conf</i>
<comment>手动选择镜像:</comment>
# <i>mirrorselect -i -o &gt;&gt; /mnt/gentoo/etc/make.conf</i>
</pre>

<p>
如果 <c>mirrorselect</c> 无法正常工作，你一样可以继续安装。
</p>

</body>
</section>
<section>
<title>进入 chroot 环境</title>
<body>

<p>
下面，我们使用 <c>chroot</c> 命令进入新 Gentoo 编译环境。</p>

<note>
你可能在运行 <c>env-update</c> 看到警告说：<path>/etc/make.profile/make.defaults</path> 文件
不存在，不用理会。后面我们会用 <c>emerge sync</c> 解决这个问题。
</note>

<pre caption="准备和进入 chroot 环境">
# <i>mount -t proc proc /mnt/gentoo/proc</i>
# <i>cp /etc/resolv.conf /mnt/gentoo/etc/resolv.conf</i>
# <i>chroot /mnt/gentoo /bin/bash</i>
# <i>env-update</i>
Regenerating /etc/ld.so.cache...
# <i>source /etc/profile</i>
<comment>(以上会将更新你的 Shell 搜索路径)</comment>
</pre>

<p>
当你执行完这些命令后，你就已经“进入”了新 Gentoo Linux 系统环境了（<path>/mnt/gentoo</path>）。下面我们将
在 chroot 环境中继续剩下的安装进程。
</p>

</body>
</section>
</chapter>

<chapter>
<title>使用 sync 更新 portage 树</title>
<section>
<body>

<impo>
如果你是使用 GRP 方式安装，你可以略过 <c>emerge sync</c> 这个步骤。
</impo>

<p>
现在你需要运行 <c>emerge sync</c>。这个命令告诉 portage 去下载更新 Gentoo Linux Portage 树。
如果你先前曾从 <e>CD 1</e>释放了 portage 树的快照，你可以放心地跳过这一步。
Portage 树包括了在 Gentoo Linux 下编译每个软件包的脚本（称为 ebuild）。
目前，我们有大约 4000 个软件包的 ebuild 脚本。当你 <c>emerge sync</c> 完毕后，你的 <path>/usr/portage</path>
目录中就会有一个完整的 Portage 树了。
</p>

<pre caption="使用 sync 更新">
# <i>emerge sync</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>设置 Gentoo 优化参数 (make.conf)</title>
<section>
<body>

<p>
现在你已经有了一个完整的 Portage 树了，下面你应该设置你的 Gentoo Linux 系统下的编译优化参数。
Porage 会在编译每个软件的时候用到这些参数。你要编辑 <path>/etc/make.conf</path> 文件。在这个文件中你要设置 USE 参数，它
告诉系统你要编译哪些软件和如何编译，一般情况下 USE 参数是<e>空</e>的，所以你必须设置好以使系统达到最佳效率。
你可以参考 <uri link="http://www.gentoo.org/doc/en/use-howto.xml">USE 指南</uri>
和<uri link="http://www.gentoo.org/dyn/use-index.xml">USE 参数说明</uri>以获取更多关于 USE 的帮助。
</p>

<p>
如果你从 stage1 开始安装，你必须同时设置好 CHOST、CFLAGS 和 CXXFLAGS ,它们用来告诉编译器你的系统类型
(文件中的注释会告诉你该如何设置)。如果你使用 stage2 或 stage3 开始安装，那么这些参数已经设置好了。
</p>

<warn>
<b>高级用户：</b>
如果你在编译一个 x86 Gentoo 系统(ACCEPT_KEYWORDS="~x86"),那么在 bootstrap (stage1) 完成之前不要修改 ACCEPT_KEYWORDS 参数。
</warn>

<impo>
<b>高级用户：</b> CFLAGS 和 CXXFLAGS 参数是用来告诉 C 和 C++ 编译器如何编译最适合你的系统。
一般使用 Athlon XP 处理器的用户会设为 "-march=athlon-xp" 以使所有的软件都被编译成最适合你的处理器达到最佳效率。
<path>/etc/make.conf</path> 文件中的注释会告诉你该如何正确设置 CFLAGS 和 CXXFLAGS 参数。
</impo>

<note>
<b>高级用户:</b>如果你使用 stage1 开始安装，而不想手动修改 CFLAGS 和 CXXFLAGS 参数，
你可以使用 <c>genflags</c> 工具，它会为你根据你的CPU选择正确的设置值。
只要键入 <c>emerge -O genflags</c>，然后键入 <c>info2flags</c>。 <c>info2flags</c> 会给出
CHOST, CFLAGS 和 CXXFLAGS 的建议值，然后你可以根据给出结果将其添加至 <path>/etc/make.conf</path>文件。
</note>


<p>
如果需要，你也可以在这里加入你的代理服务器设置。使用 <c>nano</c> 命令来编辑 <path>/etc/make.conf</path> 文件：
</p>

<pre caption="设置 make.conf 中的参数">
# <i>nano -w /etc/make.conf</i>
</pre>

<note>
<b>高级用户：</b> 需要完全自定义的用户可以看一下 <path>/etc/make.globals</path> 文件。
这个文件是 Gentoo 的预设，你不要修改它。如果预设值无法满足你，你可以将新增设置添加到
 <path>/etc/make.conf</path> 文件中，<path>make.conf</path> 文件中的设置会覆盖 <path>make.globals</path> 中的
相应设置。如果你对自定义 USE 感兴趣，你可以看一下 <path>/etc/make.profile/make.defaults</path> 文件。
如果你想关闭这里的任何 USE 设置，你可以将 <c>USE="-foo"</c> 加入 <path>/etc/make.conf</path> 文件中以关闭
<path>/etc/make.globals</path> 或 <path>/etc/make.profile/make.defaults</path>中的 <c>foo</c>设置。
</note>

<warn>
不要在 stage1 完成之前设置 '<c>static</c>' USE 参数值。
</warn>

</body>
</section>
</chapter>

<chapter>
<title>从 Stage1 开始</title>
<section>
<body>

<note>
如果你不是从 stage1 开始，请跳过这一节。
</note>

<p>
stage1 让你可以完全自定义和优化你的系统。如果你选择 stage1 ，你将获得一个最优和最新的 Gentoo。慢慢享受吧！
虽然从 stage1 开始将会耗费很长时间，但结果将会完全达到你的要求。
</p>

<p>
现在，我们将开始 "bootstrap"。完成这个步骤作者在 1200MHz AMD Athlon 系统下大约花费了两个小时。
这个阶段我们将编译 GNU C 库、编译器和其它重要的系统软件。跟着下面步骤进行：</p>

<pre caption="Bootstrapping">
# <i>cd /usr/portage</i>
# <i>scripts/bootstrap.sh</i>
</pre>

<p>
"bootstrap" 开始了。
</p>

<note>
<c>bootstrap.sh</c> 现在支持 <c>--fetchonly</c> 选项。拨号用户会发现这非常有用。
它会将 bootstrap 需要的文件全部下载下来以便后续编译。查看 <c>bootstrap.sh -h</c> 脚本以获得更多帮助。</note>

<note>
portage 默认情况下会在 <path>/var/tmp</path> 编译每个软件包，有时会占用几百兆的硬盘空间。
如果你想把 portage 编译临时目录放在其它地方，请在 bootstrap <e>之前</e> 修改 PORTAGE_TMPDIR 环境变量，如下修改：
<pre caption="修改 portage 编译临时目录">
# <i>export PORTAGE_TMPDIR="/otherdir/tmp"</i>
</pre>
</note>

<p>
<c>bootstrap.sh</c> 会编译 <c>binutils</c>, <c>gcc</c>, <c>gettext</c>,
和 <c>glibc</c>, 在 <c>glibc</c> 之后重新编译 <c>gettext</c> 。不用说这会耗费很长时间。
当所有编译都完成之后，你的系统就等同于一个 "stage2" 系统了，现在你就可以进行到 stage2 一步了。
</p>

</body>
</section>
</chapter>

<chapter>
<title>从 Stage2 开始，或继续 Stage1</title>
<section>
<body>

<note>
这一节指从 stage2 开始，或者完成 stage1 后继续。如果你不是（比如你选择 stage3），那么跳过这一节。
</note>

<warn>
如果你从 stage2 开始，那么不要修改 <path>/etc/make.conf</path> 中的 CHOST 变量值，否则可能导致编译失败。
</warn>
		
<p>
Stage2 压缩包已经包含了 bootstrapping 阶段。你需要做的就是继续下面的系统安装：
</p>

<note>
如果你从预编译的 stage2 开始，你想确认你的编译器是最新的，可以在下面命令加入 <c>-u</c> 选项以更新系统软件。
如果你不明白是什么意思，你可以忽略这个建议。
</note>

<pre caption="完成剩下的系统安装">
# <i>emerge -p system</i>
<comment>(列出要安装的软件包)</comment>
# <i>emerge system</i>
</pre>

<p>
完成整个系统的编译需要一定的时间，这段时间你可以去喝杯咖啡、玩玩游戏,比如 PS2 的 "Star Wars - Super Bombad Racing" ;-)
</p>

<p>
当编译全部完成，直接跳过下面一节，从“设置时区”继续。
</p>

</body>
</section>
</chapter>


<chapter>
<title>从 Stage3 开始</title>
<section>
<body>

<note>
这一节是指从 stage3 <b>开始</b>的用户，从stage1或stage2开始的用户不需要这一节。GRP用户也应该跳过这一节。
</note>

<warn>
记住，如果你从 stage3 开始，不要修改 <path>/etc/make.conf</path> 文件中的 CHOST 变量值，
否则可能导致编译失败。
</warn>

<p>
stage3 压缩包提供了一个完整的基本 Gentoo 系统，所以我们不需要进一步的编译。
</p>

<note>
<b>高级用户：</b> 由于 stage3 压缩包是编译好的，所以它有可能有点过时。
如果你想更新其中的软件，可以见备份 <path>/etc/make.conf</path> 文件，然后键入
 <c>export CONFIG_PROTECT="-*" emerge -u system</c> (需要网络连接) ，完成后回复备份文件。
注意如果你的 stage3 很老的话可能要花费很长时间。任何情况下，你都可以放心地跳过这一步。
</note>
		
</body>
</section>
</chapter>


<chapter>
<title>设置时区</title>
<section>
<body>

<p>
现在你需要设置你的时区。
</p>

<p>
到 <path>/usr/share/zoneinfo</path> 中找到你的时区（如果你使用格林威治时间，情用 GMT），然后链接至
<path>/etc/localtime</path> ：
</p>

<pre caption="建立时区链接">
# <i>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</i>
<comment>（中国大陆时区设置为 Shanghai）</comment>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>编辑 /etc/fstab 文件</title>
<section>
<body>

<impo>
记住使用 <c>nano -w "filename" 编辑文件</c>.
</impo>

<p>
你的 Gentoo Linux 系统已经快完成了。我们现在要为系统启动配置一些系统文件。首先就是编辑
 <path>/etc/fstab</path> 文件。记住如果你的启动分区使用的是 ReiserFS 文件系统，要在启动分区的选项部分
加入 <c>notail</c>。同时要将 <c>ext2</c>, <c>ext3</c> 或 <c>reiserfs</c> 文件系统类型部分替换成
你的分区文件系统类型。
</p>

<warn>
参考下面的 <path>/etc/fstab</path> 文件范例。当然要把 "BOOT", "ROOT" 和 "SWAP" 替换为你的
分区的设备标识（如 <c>hda1</c>, 等) ，还要替换 "ext2" and "ext3" 为你的文件系统类型。
</warn>

<pre caption="编辑 fstab">
<comment># /etc/fstab: static file system information.
#
# noatime turns off atimes for increased performance (atimes normally aren't
# needed; notail increases performance of ReiserFS (at the expense of storage
# efficiency).  It is safe to drop the noatime options if you want and to 
# switch between notail and tail freely.

# &lt;fs&gt;           &lt;mount point&gt;   &lt;type&gt;   &lt;opts&gt;          &lt;dump/pass&gt;

# NOTE: If your BOOT partition is ReiserFS, add the notail option to opts.
</comment>
/dev/BOOT           /boot       ext2	 noauto,noatime	 1 2
/dev/ROOT           /           ext3	 noatime         0 1
/dev/SWAP           none        swap	 sw              0 0
/dev/cdroms/cdrom0  /mnt/cdrom  iso9660	 noauto,ro       0 0
proc                /proc       proc	 defaults        0 0
</pre>

<warn>
注意 <path>/boot</path> 默认状态启动时是 <e>不会</e> 被挂载的。
目的是保护 <path>/boot</path> 上的数据。如果你需要，请手动挂载！
</warn>

</body>
</section>
</chapter>


<chapter>
<title>安装内核（kernel）和系统日志记录器</title>
<section>
<title>选择内核</title>
<body>
	
<p>
有两种方法安装系统内核。你可以自己手动编译，也可以利用 <c>genkernel</c> 工具帮你编译。</p>

<p>
不管是手动编译还是用 <c>genkernel</c> 编译，你都需要将内核源代码安装到你的系统中。
Gentoo 提供了许多种内核；你可以在<uri link="/doc/en/gentoo-kernel.xml">这里</uri>查看支持列表。
如果你不确定安装哪一个内核，我们建议你安装 <c>gentoo-sources</c>。
如果你想有 XFS 支持, 你应该选择 <c>xfs-sources</c> 或 <c>gs-sources</c>。
Gentoo的 LiveCD 使用的就是 <c>gs-sources</c> 和 <c>xfs-sources</c>。
还有一种 <c>gaming-sources</c> 内核，此内核专门对游戏软件做了优化（打开了"Preemptible kernel"选项）</p>

<p>
选择一个内核，开始安装：
</p>

<pre caption="安装内核源代码">
# <i>emerge -k sys-kernel/gentoo-sources</i>
</pre>

<p>
<path>/usr/src/linux</path> 链接应该指向你的心内核源代码树。任何你编译的内核模块都会被Portage透过
 <path>/usr/src/linux</path> 链接来编译适合你的内核的模块。
<path>/usr/src/linux</path> 会在你第一次安装内核源代码时创建，之后 Portage 不会修改这个链接。
</p>

</body>
</section>
<section>
<title>使用 genkernel 编译内核</title>
<body>

<p>
现在内核源代码树已经安装完毕，你可以开始编译内核了。有两种方法，第一种是使用我们提供的
<c>genkernel</c> 脚本来自动为你编译。
<c>genkernel</c> 编译内核方法就象我们的 LiveCD 一样，因此如果你使用 <c>genkernel</c> 来编译内核，系统启动时
会自动检测你的所有硬件，就象 Live CD 启动时的样子。因为 genkernel 不需要任何手动配置，所以它对那些不熟悉内核编译的
用户来说是个理想的工具。
</p>

<p>
现在，要运行 gentkernel，首先得安装它：
</p>

<pre caption="安装 genkernel">
# <i>emerge -k genkernel</i>
</pre>
		
<p>
现在，开始用 <c>genkernel</c> 编译内核：
</p>

<note>
<b>高级用户：</b> 你可以键入 <c>genkernel --config</c> ，这样 genkernel 会允许你在编译前对内核配置进行调整。
</note>

<pre caption="运行 genkernel">
<comment>如果你使用的是 genkernel 1.2 (包含在 1.4-20030803 x86/i686 GRP 套装中), 键入：</comment>
# <i>genkernel gentoo-sources</i>
<comment>如果你使用的是 genkernel 1.4 或更新版本，则不需指定内核：</comment>
# <i>genkernel</i>
Gentoo Linux genkernel, version 1.4
Copyright 2003 Gentoo Technologies, Inc., Bob Johnson, Daniel Robbins
Distributed under the GNU General Public License version 2

Settings:
compile optimization: 1 processor(s)
source tree: /usr/src/linux-2.4.20-gaming-r3
config: gentoo (customized)
config loc: /etc/kernels/config-2.4.20-gaming-r3
initrd config: (default) /etc/kernels/settings

* Running "make oldconfig"...                                                                     [ ok ]
* Logging to /var/log/genkernel.log...                                                            [ ok ]
* Starting 2.4.20-gaming-r3 build...                                                              [ ok ]
* Running "make dep"...                                                                           [ ok ]
* Running "make bzImage"...                                                                       [ ok ]
* Running "make modules"...                                                                       [ ok ]
* Running "make modules_install"...                                                               [ ok ]
* Moving bzImage to /boot/kernel-2.4.20-gaming-r3...                                              [ ok ]
* Building busybox...                                                                             [ ok ]
* Creating initrd...                                                                              [ ok ]

* Build completed successfully!

* Please specify /boot/kernel-2.4.20-gaming-r3 and /boot/initrd-2.4.20-gaming-r3
* when customizing your boot loader configuration files.
</pre>

<p>
当 <c>genkernel</c> 运行完毕, 一个包括整套模块和 <e>可启动根磁盘</e> (initrd) 的内核就已经创建好了。
我们将用这个内核和 initrd 配置稍后的启动程序。记下你的内核和 initrd 的文件名。initrd 会在系统启动检测硬件后自动加载
，(就像 Live CD 一样)。
</p>

<p>
现在，我们只要在做一步就能是我们的系统更像 LiveCD了－－安装 <c>hotplug</c>。
当系统启动时 initrd 自动检测已经时， <c>hotplug</c> 会自动检测其它的。
要安装和启用 <c>hotplug</c>, 键入：
</p>

<pre caption="安装和启用 hotplug">
# <i>emerge -k hotplug</i>
# <i>rc-update add hotplug default</i>
</pre>

<p>
现在你已经用 <c>genkernel</c> 编译好了内核，你可以跳过下面的”手动配置内核“部分。
</p>

</body>
</section>
<section>
<title>手动配置内核</title>
<body>

<p>
如果你不想用 genkernel 来编译内核，这一节将指导你如何手动编译内核...
请查看 <path>/usr/src/linux</path> 链接是否指向你的内核源代码树。
如果你有多个内核源代码，确保 <path>/usr/src/linux</path> 链接指向正确的内核源代码树是非常必要的。
</p>

<warn>
如果你自己配置内核，请注意 <i>grsecurity</i> 选项。过于严格的安全设置可能会导致一些程序（如 X）无法正常工作。
如果你不确定，就不要设置它。
</warn>

<note>
如果你想使用和 Live CD一样的内核配置，键入
 <c>cd /usr/src/linux &amp;&amp; cat /proc/config > .config &amp;&amp; make oldconfig</c>。
如果你正使用 <c>xfs-sources</c>,它将会提示一些如你的内核配置和 <c>xfs-sources</c> 之间区别的问题。
</note>

<pre caption="配置内核">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<warn>
为了保证你的内核运行无误，必须确保以下建议的选项<e>内置(而不是编译成模块)</e>在内核里。
如果你使用 ReiserFS 或 Ext3 ，请确保将 &quot;ReiserFS&quot; 和 &quot;Ext3&quot;编入内核。
如果你使用 XFS, 编入 &quot;SGI XFS filesystem support&quot; 。不论是否使用 ext2 都要把其编入内核。
</warn>

<p>
下面是一些编译时需要的选项：
</p>

<pre caption="配置选项">
Code maturity level options ---&gt;
[*] Prompt for development and/or incomplete code/drivers&quot;
<comment>(你需要这个以使用下面的功能)</comment>
...

File systems ---&gt;
&lt;*&gt; Reiserfs support
<comment>(如果你使用 reiserfs)</comment>
... 
&lt;*&gt; Ext3 journalling file system support
<comment>(如果你使用 ext3)</comment>
...
[*] Virtual memory file system support (former shm fs)
<comment>(Gentoo Linux 必须使用此项)</comment>
...
&lt;*&gt; JFS filesystem support
<comment>(如果你使用 JFS)</comment>
...
[*] /proc file system support
<comment>(Gentoo Linux 必须使用此项)</comment>
[*] /dev file system support (EXPERIMENTAL)
[*]   Automatically mount at boot          
<comment>(Gentoo Linux 必须使用此项)</comment>
[ ] /dev/pts file system for Unix98 PTYs
<comment>(除非你使用 2.6 内核，否则取消这一项)</comment>
...
&lt;*&gt; Second extended fs support
<comment>(如果你使用 ext2)</comment>
...
&lt;*&gt; XFS filesystem support
<comment>(如果你使用 XFS)</comment>
</pre>

<p>
如果你使用 PPPoE 连接到 Internet，你要把下面的选项编译进内核（内建或模块）：
&quot;PPP (point-to-point protocol) support&quot;,
&quot;PPP support for async serial ports&quot;,
&quot;PPP support for sync tty ports&quot;。
有两个压缩选项不是必需的，&quot;PPP over Ethernet&quot;选项一般在你使用 <c>rp-pppoe</c> 配置 PPoE 时需要。
</p>

<p>
如果你有 IDE 刻录机，那么你需要将 SCSI emulation 编译进内核。
打开 &quot;ATA/IDE/MFM/RLL support&quot; ---&gt;
&quot;IDE, ATA and ATAPI Block devices&quot; ---&gt;
 &quot;SCSI emulation support&quot; (一般编译成模块)，然后在 &quot;SCSI support&quot; 下打开
 &quot;SCSI support&quot;, &quot;SCSI CD-ROM support&quot; 和
 &quot;SCSI generic support&quot; (同样，编译成模块)。
如果你选择编译成模块，那么键入 <c>echo -e &quot;ide-scsi\nsg\nsr_mod&quot;
&gt;&gt; /etc/modules.autoload.d/kernel-2.4</c> 来让系统启动时自动加载这些模块。
</p>

<p>
如果需要，别忘了将你的网卡编译进内核。
</p>

<note>
给那些想要在 Gentoo Linux 使用 2.2 内核的使用者, 现在 Gentoo Linux 可以使用 2.2 版的内核。 但是, 这样做要付出代价的。 你将会损失很多功能, 包括 XFS, iptables 等等。虽然 2.2 版的内核可以利用补丁增加 ReiserFS 和 devfs 支持。
Gentoo Linux 启动程序需要使用到内核內建的 tmpfs 或是 ramdisk。
所以 2.2 的使用者必需确定 ramdisk 有被內建(不是编译成模块)。 你一定要在 /boot/grub/grub.conf 或是 /etc/lilo.conf
中加入 gentoo=notmpfs 到内核 kernel 选项。 然后 2.2 版的内核才能使用 ramdisk 而略过 tmpfs。
如果你选择不用 devfs, 那就加入 gentoo=notmpfs,nodevfs。
</note>

<pre caption = "编译及安装内核">
# <i>make dep &amp;&amp; make clean bzImage modules modules_install</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /boot</i>
</pre>

</body>
</section>
<section>
<title>安装其它的硬件所需要的软件</title>
<body>

<p>
最后，我们来安装一些系统硬件需要的软件。下面是一些建议：
</p>

<table>
<tcolumn width="1in"/>
<tcolumn width="4in"/>
<tcolumn width="2in"/>
<tr>
 <th>安装的软件</th>
 <th>用途</th>
 <th>安装命令</th>
</tr>
<tr>
 <ti>nvidia-kernel</ti>
 <ti>为 XFree86 提供 Nvidia 图像加速卡支持</ti>
 <ti><c>emerge -k nvidia-kernel</c></ti>
</tr>
<tr>
 <ti>nforce-net</ti>
 <ti>提供对 NVIDIA NForce(2) 板载网卡支持</ti>
 <ti><c>emerge nforce-net</c></ti>
</tr>
<tr>
 <ti>nforce-audio</ti>
 <ti>提供对 NVIDIA NForce(2) 板载声卡支持</ti>
 <ti><c>emerge nforce-audio</c></ti>
</tr>
<tr>
 <ti>e100</ti>
 <ti>提供对 Intel e100 Fast Ethernet 网卡支持</ti>
 <ti><c>emerge e100</c></ti>
</tr>
<tr>
 <ti>e1000</ti>
 <ti>提供对 Intel e1000 Gigabit Ethernet 网卡支持</ti>
 <ti><c>emerge e1000</c></ti>
</tr>
<tr>
 <ti>emu10k1</ti>
 <ti>提供对 Creative Sound Blaster Live!/Audigy 支持</ti>
 <ti><c>emerge emu10k1</c></ti>
</tr>
<tr>
 <ti>ati-drivers</ti>
 <ti>为 XFree86 提供 ATI Radeon 8500+/FireGL 图像加速卡支持</ti>
 <ti><c>emerge ati-drivers</c></ti>
</tr>
<tr>
 <ti>xfree-drm</ti>
 <ti>为 XFree86 提供 ATI Radeon up to 9200, Rage128, Matrox, Voodoo 和其它图形加速卡支持</ti>
 <ti><c>VIDEO_CARDS="yourcard" emerge xfree-drm</c></ti>
</tr>
</table>

<p>
<c>nvidia-kernel</c>, <c>ati-drivers</c> 和 <c>xfree-drm</c> 软件包需要其它设置。其它软件包
会在系统启动时由 <c>hotplug</c> 自动检测。如果你不使用 hotplug，请将模块加入 <path>/etc/modules.autoload.d/kernel-2.4</path>
文件中。
</p>

<p>
有关 <c>xfree-drm</c> 的更多资料请访问 <uri link="/doc/en/dri-howto.xml">Direct Rendering Guide</uri>。
</p>


</body>
</section>
<section>
<title>安装系统日志记录器</title>
<body>

<p>
你的内核（和模块）都已经安装完毕。下面你需要选择一种系统日志记录器。
我们推荐的是 sysklogd，一种传统系统日志记录软件。除此之外，我们还有 msyslog、syslog-ng 以及 metalog。
如果不怀疑，你可以选择 syslog-ng, 它是具有强大易用的特性。要安装日志记录器，选择下面<e>一个</e>加入:
</p>

<pre caption="选择安装日志记录器">
# <i>emerge -k app-admin/sysklogd</i>
# <i>rc-update add sysklogd default</i>
<comment>或者</comment>
# <i>emerge -k app-admin/syslog-ng</i>
# <i>rc-update add syslog-ng default</i>
<comment>或者</comment>
# <i>emerge -k app-admin/metalog</i>
# <i>rc-update add metalog default</i>
<comment>或者</comment>
# <i>emerge -k app-admin/msyslog</i>
# <i>rc-update add msyslog default</i>
</pre>

<impo>
如果你选择 <c>metalogd</c>, 请访问我们的 <uri link="faq.xml#doc_chap6_sect3">FAQ</uri> 查看关于 metalogd's 缓冲区说明。
</impo>

<p>
现在，你要选择安装一种 cron 软件，我们提供 dcron, fcron 和 vcron。如果不知道选择哪个，推荐使用 vcron。
</p>

<pre caption="选择安装 Cron 进程软件">
# <i>emerge -k sys-apps/dcron</i>
# <i>rc-update add dcron default</i>
# <i>crontab /etc/crontab</i>
<comment>或者</comment>
# <i>emerge -k sys-apps/fcron</i>
# <i>rc-update add fcron default</i>
# <i>crontab /etc/crontab</i>
<comment>或者</comment>
# <i>emerge -k sys-apps/vcron</i>
# <i>rc-update add vcron default</i>
<comment>如果你使用 vcron,你不需要 <i>crontab /etc/crontab</i>。</comment>
</pre>

<p>
想了解更多关于系统启动服务和进程的内容，请访问 <uri link="/doc/en/rc-scripts.xml">rc-script 指南</uri>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>安装其它必要的软件</title>
<section>
<body>

<p>
如果你需要使用 rp-pppoe 连接到网络，现在正是安装它的时候：
</p>

<pre caption="安装 rp-pppoe">
# <i>USE="-X" emerge rp-pppoe</i>
<comment>GRP 要这样安装:</comment>
# <i>emerge -K rp-pppoe</i>
</pre>

<note>
<i>USE="-X"</i> 这个选项是为了关闭安装 X 界面选项。因为现在 X 及其倚赖组件还没有安装。
你可以在以后安装好 X 后重新编译安装 <i>rp-pppoe</i> 。GRP 版的
rp-pppoe 已经内置 X 界面。 如果你不是 GRP 用户，按照第一种方法编译安装。
</note>
<!-- this pkg is a candidate for moving from .tbz2 to distfiles/ (source) -->


<note>
注意，rp-pppoe安装好后还必须进行必要的配置。你必须在第一次进入 Gentoo 系统后运行 <c>adsl-setup</c> 进行必要的配置。
</note>

<p>
如果你有 XFS、ReiserFS 或 LVM，你必须从 Portage 安装相应文件系统工具软件。
</p>

<pre caption="安装文件系统工具">
<comment>如果你使用 XFS: </comment>
# <i>emerge -k xfsprogs</i>
<comment>如果你使用 ReiserFS: </comment>
# <i>emerge -k reiserfsprogs</i>
<comment>如果你使用 JFS: </comment>
# <i>emerge -k jfsutils</i>
<comment>如果你使用 LVM： </comment>
# <i>emerge -k lvm-user</i>
</pre>

<p>
如果你使用手提电脑，并且开机时需要使用 PCMCIA 扩展槽，你需要安装 <i>pcmcia-cs</i> 软件。
</p>

<pre caption="安装 PCMCIA-cs">
# <i>emerge -k sys-apps/pcmcia-cs</i>
</pre>

<!-- fix the bug or fix the docs, don't send the user in circles
(drobbins)
		<warn>You will have to re-emerge <i>pcmcia-cs</i> after installation to get PCMCIA
			to work.
			</warn>
	-->

</body>
</section>
</chapter>

<chapter>
<title>用户管理</title>
<section>
<title>设置 root 密码</title>
<body>

<p>
在你忘记之前，先设置 root 的密码：
</p>

<pre caption="设置 root 密码">
# <i>passwd</i>
</pre>

</body>
</section>
<section>
<title>新增日常工作用户</title>
<body>

<p>
在 Unix/Linux 以 root 身份操作是<e>危险</e>的，应该尽量避免。所以我们<e>强烈</e>建议你新建一个日常工作用户：
</p>

<pre caption = "新建用户">
# <i>useradd your_user -m -G users,wheel,audio -s /bin/bash</i>
# <i>passwd your_user</i>
</pre>

<p>
替换 <c>your_user</c> 为你的新建用户名。
</p>

<p>
当你需要以 root 身份完成某项工作时，你可以键入 <c>su -</c> 来切换到 root 环境获得 root 权限。
查看 <c>sudo</c> 软件获得帮助。
</p>

</body>
</section>
</chapter>

<chapter>
<title>设置你的主机名</title>
<section>
<body>

<p>
编辑 <path>/etc/hostname</path> 文件，添加你的主机名，如： <c>mymachine</c>。
</p>

<pre caption="设置主机名">
# <i>echo mymachine &gt; /etc/hostname</i>
</pre>

<p>
然后编辑 <path>/etc/dnsdomainname</path> 文件设置你的域名服务器 DNS，如： <c>mydomain.com</c>。
</p>

<pre caption="设置域名服务器">
# <i>echo mydomain.com &gt; /etc/dnsdomainname</i>
</pre>

<p>
如果你有一个 NIS 域名服务器，将其加入 <path>/etc/nisdomainname</path>文件。
</p>

<pre caption="设置 NIS 域名服务器">
# <i>echo nis.mydomain.com &gt; /etc/nisdomainname</i>
</pre>

</body>
</section>
</chapter>


<chapter>
<title>设置 /etc/hosts 文件</title>
<section>
<body>

<p>
这个文件包含 IP 地址及其对应的主机名，用来解析你的域名服务器无法解析的IP地址。下面是一个范例：
</p>

<pre caption="Hosts 文件范例">
127.0.0.1      localhost
<comment># 下面一行是你的本地 IP 地址及其对应主机名</comment>
192.168.1.1    mymachine.mydomain.com	mymachine
</pre>

<note>
如果你使用 DHCP 动态 IP，在你的主机名后加入 <i>localhost</i> 将有利于 GNOME 和其它软件的运行。
</note>

</body>
</section>
</chapter>


<chapter>
<title>网络最后设置</title>
<section>
<title>加载内核模块</title>
<body>

<p>
在 <path>/etc/modules.autoload.d/kernel-2.4</path> 文件中加入你的模块名（同时可以加上一些参数）。
当 Gentoo Linux 启动时，这些模块会自动被加载。尤其是对网卡模块，如果你正好将网卡编译成了模块：
</p>

<pre caption="/etc/modules.autoload.d/kernel-2.4 文件">
<comment>这里假设你有一个 3com 网卡。
查看 /lib/modules/&lt;内核版本&gt;/kernel/drivers/net 目录可以看到你的网卡型号。 </comment>
3c59x
</pre>

</body>
</section>
<section>
<title>配置网络接口</title>
<body>

<p>
编辑 <path>/etc/conf.d/net</path> 脚本来设定启动时的开启网络。
</p>

<pre caption="启动时网络设置">
# <i>nano -w /etc/conf.d/net</i>
</pre>

<p>
如果你希望 eth0 自动获取 IP，设置 <c>iface_eth0</c> 为 <e>dhcp</e>。
否则填入 IP 地址, broadcast（广播）地址和 netmask（子网掩码）。如果你有多个网络接口，对 <c>iface_eth1</c>，<c>iface_eth2</c> 做同样设置，依此类推。
</p>

<p>
现在把 <c>net.eth0</c> 脚本加入 default 运行级。（<e>非</e> PCMCIA 卡）
</p>

<pre caption="启动时自动开启网络">
# <i>rc-update add net.eth0 default</i>
</pre>

<p>
如果你有多个网卡或令牌网接口，你需要为每个接口复制 <path>net.eth</path><comment>x</comment> 或
<path>net.tr</path><comment>x</comment> 脚本(<comment>x</comment> = 1, 2, ...)：
</p>

<pre caption="多网络接口">
# <i>cd /etc/init.d</i>
# <i>ln -s net.eth0 net.eth<comment>x</comment></i>
</pre>

<p>
现在把每个脚本加入 default 运行级 (同样<e>非</e> PCMCIA 卡):
</p>

<pre caption = "将 net.ethx 加入 default 运行级">
# <i>rc-update add net.eth<comment>x</comment> default</i>
</pre>

</body>
</section>
<section>
<title>PCMCIA 用户</title>
<body>

<p>
如果你有 PCMCIA 卡，你需要查看 <path>/etc/conf.d/pcmcia</path> 文件，确保设置正确后，键入：
</p>

<pre caption = "自动运行 PCMCIA 服务">
# <i>rc-update add pcmcia boot</i>
</pre>

<p>
这样就可以在启动网络时自动加载 PCMCIA 驱动。
</p>

</body>
</section>
</chapter>

<chapter>
<title>最后步骤： 设置基本选项(包括国际键盘设定)</title>
<section>
<body>

<pre caption="基本选项设置">
# <i>nano -w /etc/rc.conf</i>
</pre>

<p>
根据文件中的指导设置基本选项。确保 CLOCK 设置好。国际键盘用户需要设置 KEYMAP 选项（参考
 <path>/usr/share/keymaps</path> 文件获得更多帮助)。</p>

</body>
</section>
</chapter>

<chapter>
<title>设置启动程序</title>
<section>
<title>Notes</title>
<body>

<p>
Gentoo 的精神，用户现在可以选择多种启动程序。在我们的虚拟包装系统里，用户可以选择 GRUB 或 LILO 作为系统启动程序。
</p>

<p>
注意你只需要安装一个启动程序，不要安装超过一个。
</p>

<p>
另外，如果你使用 <c>genkernel</c>（内核和initrd）的话，配置启动程序和手动编译内核的方法不同，请注意这个
重要的区别。</p>

</body>
</section>
<section>
<title>设置 GRUB</title>
<body>

<p>
要理解 GRUB 最重要的就是它标识硬盘和分区的方法。你的 Linux 分区 <path>/dev/hda1</path>
在GRUB下被标识为 <path>(hd0,0)</path> 。注意那对括号－－是必需的。
硬盘和分区是从 0 开始标识而不是 1。
非 atapi-ide 设备如 cdrom、刻录机和 scsi 设备(通常它们的标识会比 IDE 设备高一点，除非BIOS里设定从SCSI设备启动）。假设你有个硬盘是 <path>/dev/hda</path>, 一个 cdrom 是<path>/dev/hdb</path>, 一个刻录机是 <path>/dev/hdc</path>, 第二个硬盘是 <path>/dev/hdd</path> 没有 SCSI 设备, <path>/dev/hdd7</path> 被翻译成 <path>(hd1,6)</path>。
这看起来真有点复杂， 但 GRUB 支持 TAB 键补全功能，当你有很多硬盘/分区的时候，你可以按 TAB 键来让系统列出所有的
硬盘/分区。要体会一下这个功能，让我们来安装 GRUB。
</p>

<p>
安装 GRUB 最简单方法就是键入 <c>grub</c> :
</p>

<pre caption="安装 GRUB">
# <i>emerge -k grub</i>
# <i>grub</i>
</pre>

<p>
现在你能看到一个 <e>grub&gt;</e> 提示符 。现在，你需要键入正确的命令来把 GRUB 启动数据安装到你的硬盘上。
在下面的例子里，我们把 GRUB 启动数据安装到硬盘的引导区（MBR）中，这样电脑开机后就会直接运行 GRUB。我是这样做的：
</p>

<pre caption="安装 GRUB 到 MBR">
grub&gt; <i>root (hd0,0)</i> <comment>(指定启动分区)</comment>
grub&gt; <i>setup (hd0)</i> <comment>(指定安装 GRUB 到 MBR)</comment>
</pre>
	
<pre caption="安装 GRUB 到其它分区">
<comment>如果你不想把 GRUB 安装到 MBR，你可以将它安装到其它分区上。</comment>
grub&gt; <i>root (hd0,0)</i> <comment>(指定启动分区)</comment>
grub&gt; <i>setup (hd0,4)</i> <comment>(指定安装 GRUB 到 /dev/hda5)</comment>
grub&gt; <i>quit</i>
</pre>

<p>
现在我来解释一下上面的两个命令。第一个 <c>root ( )</c> 命令是告诉 GRUB 你的系统启动分区的位置
 ，在我们的例子中是 <path>/dev/hda1</path> （ GRUB 所理解的 <path>(hd0,0)</path> ）。
然后第二个 <c>setup ( )</c> 命令是告诉 GRUB 安装到哪里。
在我们的例子里，我们要将 GRUB 安装到 MBR，也就是 <path>/dev/hda</path> (GRUB所理解的 <path>(hd0)</path>)。
如果你使用其它启动程序，而想把 GRUB 作为第二启动程序，你可以把 GRUB 安装到其它指定的分区上。
当 GRUB 安装完成，键入 <c>quit</c> 退出 GRUB。
</p>

<note>
在 GRUB 里, TAB 补全功能的是一个很方便的工具, 当你键入 <c> root (</c>
然后按下 TAB 键, 你将会看到所有的分区列表。 按下 TAB 后，就会自动帮你你改为 <c> root (hd</c>.
再按一次, grub 将列出可用硬盘就会变成 <c> root (hd0</c>, 然后你可以自己输入或是按下 TAB 这样就可以让 grub
 再次列出可以使用的分区。
</note>
			
<p>
Gentoo Linux 现在已经基本安装完毕，但是我们还得建立 <path>/boot/grub/grub.conf</path>
文件，这样当系统重启时我们才能看到漂亮的 GRUB 启动菜单。操作如下：
</p>

<impo>
为了保证 GRUB 的向上兼容（backwards compatibility），要为 <path>grub.conf</path> 建立一个链接：  <path>menu.lst</path>。你可以键入 <c>ln -s /boot/grub/grub.conf /boot/grub/menu.lst</c>。
</impo>

<p>
现在，使用 <c>nano -w /boot/grub/grub.conf</c> 建立 <path>grub.conf</path> 文件：
</p>

<pre caption="grub.conf 文件">
default 0
timeout 30
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

<comment># 如果你是自己编译内核，使用下面例子:</comment>
title=My example Gentoo Linux
root (hd0,0) 
kernel (hd0,0)/boot/bzImage root=/dev/hda3 

<comment># 如果你是使用 genkernel 编译的内核, 使用下面的例子:</comment>
title=My example Gentoo Linux (genkernel)
root (hd0,0)
kernel (hd0,0)/boot/kernel-KV root=/dev/hda3
initrd (hd0,0)/boot/initrd-KV

<comment># 下面是使用 GRUB 双重启动例子</comment>
title=Windows XP
root (hd0,5) 
chainloader (hd0,5)+1
</pre>

<warn>
替换 <c>KV</c> 为你的内核版本。
</warn>

<note>
(hd0,0) 中不能有任何空格。
</note>

<impo>
如果你先前曾为你的刻录机设置了 SCSI emulation ，那么要在 <path>grub.conf</path>
文件中的内核一行加入 <c>hdx=ide-scsi</c> 选项 ("hdx" 代表刻录机设备位置)。
</impo>

<p>
保存修改，Gentoo Linux 安装就已经完成。选择 GRUB 中的第一个选项直接启动 Gentoo Linux 。
<path>grub.conf</path> 文件的第二部分是可选的，只是告诉你如何用 GRUB 来启动 Windows 。
</p>

<note>
上面的 <path>(hd0,0)</path> 要指向你的启动分区。(在我们的例子里是 <path>/dev/hda1</path>)，
<path>/dev/hda3</path> 应该指向根文件系统。 <path>(hd0,5)</path> 保存 Windowd 的启动数据。
</note>

<note>
内核镜像文件的路径和启动分区是相关的。如果你的启动分区和根分区是分开的，那么 <path>grub.conf</path> 文件
中应该是 <path>/bzImage</path>。
</note>

<p>
如果你需要为装载内核增加额外的参数，那么可以直接将参数加到 <c>kernel</c> 命令后面。
比如你可以加上 <c>gentoo=nodevfs</c> 选项来关闭 devfs (如果你不确定，不推荐这么做)。
</p>

<note>
与早期的 Gentoo Linux 不同，你不必在 <c>kernel</c> 一行加入 <c>devfs=mount</c>
来开启 devfs。现在 devfs 默认情况下已被开启。
</note>

</body>
</section>
<section>
<title>设置 LILO</title>
<body>

<p>
GRUB 也许是目前最好的启动程序，但并不一直都是。 LILO,（LInuxLOader）, 是真正有实力的 Linux 启动程序。
</p>

<p>
首先我们要安装 LILO：
</p>

<pre caption="安装 LILO">
# <i>emerge -k lilo</i>
</pre>

<p>
现在来设置 LILO。下面是一个 <path>/etc/lilo.conf</path> 范例：
</p>

<pre caption="lilo.conf 范例">
boot=/dev/hda
map=/boot/map
install=/boot/boot.b
prompt
timeout=50
lba32
default=linux

<comment># 手动编译内核使用下面四行</comment>
image=/boot/bzImage
	label=linux
	read-only
	root=/dev/hda3

<comment># 使用 genkernel 编译内核使用下面五行</comment>
image=/boot/kernel-KV
	label=gk_linux
	root=/dev/hda3
	initrd=/boot/initrd-KV
	append="root=/dev/hda3 init=/linuxrc"

	
<comment># 启动 windows或其它 OS</comment>
other=/dev/hda1
	label=dos
</pre>

<warn>
替换 <c>KV</c> 为你的内核版本，（如果你使用 genkernel ,保证 <c>default=</c> 要与 <c>gk_linux</c> 一致）。
</warn>

<ul>
<li><c>boot=/dev/hda</c> 表示把 LILO 安装到第一个 IDE 硬盘上</li>
<li><c>map=/boot/map</c> LILO 的映射文件，一般不需修改 </li>
<li><c>install=/boot/boot.b</c> 表示把 LILO 安装到新的启动扇区，如果 install 行丢失，LILO 会将默认使用 <path>/boot/boot.b</path> 这个文件 </li>
<li>The existence of <c>prompt</c> 表示开机显示经典的 <e>lilo:</e> 提示，虽然不建议这么做，但如果你去掉这行，开机时你可以按 [SHIFT] 键显示它 </li>
<li><c>timeout=50</c> 设定默认的用户选择时间，设置为 50 表示 5 秒 </li>
<li><c>lba32</c> 设定 LILO 的硬盘模式。另一个有用的选项是 linear。如果你不清楚意义请不要更改，否则可能造成启动失败</li>
<li><c>default=linux</c> 表示默认启动项，必须与下面的 Label 相一致 </li>
<li><c>image=/boot/bzImage</c> 表示启动的内核</li>
<li><c>label=linux</c> LILO 启动项目的标题，如果你将其设为默认启动项目，必须与上面的 default 一致 </li>
<li><c>read-only</c> 设置根分区为只读状态，这样在启动过程中不会被更改 </li>
<li><c>root=/dev/hda3</c> 指定根分区的位置 </li>
</ul>

<p>
编辑好 <path>lilo.conf</path> 文件后，下面要运行 LILO 将启动数据写入 MBR：
</p>

<pre caption="运行 LILO">
# <i>/sbin/lilo</i>
</pre>

<p>
现在 LILO 已经设置完毕，你可以用它启动你的 Gentoo Linux 了！
</p>

</body>
</section>

<section>
<title>使用 framebuffer</title>
<body>

<p>
在内核里内置了 Framebuffer 的用户要在启动程序配置文件里加入 <c>vga=xxx</c> 参数。
 <c>xxx</c> 参考下表中的数据：
</p>

<table>
<tcolumn width="1in"/>
<tcolumn width="1in"/>
<tcolumn width="1in"/>
<tcolumn width="1in"/>
<tr><ti></ti><th>640x480</th><th>800x600</th><th>1024x768</th><th>1280x1024</th></tr>
<tr><th>8 bpp</th><ti>769</ti><ti>771</ti><ti>773</ti><ti>775</ti></tr>
<tr><th>16 bpp</th><ti>785</ti><ti>788</ti><ti>791</ti><ti>794</ti></tr>
<tr><th>32 bpp</th><ti>786</ti><ti>789</ti><ti>792</ti><ti>795</ti></tr>
</table>

<p>
LILO 用户将 <c>vga=xxx</c> 加到配置文件的最上面。
</p>

<p>
GRUB 用户将 <c>vga=xxx</c> 加到 <c>kernel (hd0,0)...</c> 一行。
</p>

</body>
</section>
</chapter>

<chapter>
<title>创建启动盘</title>
<section>
<title>GRUB 启动盘</title>
<body>

<impo>
不要忘了在开始前在软驱里插入一张磁盘。
</impo>

<p>
在第一次安装任何 Linux 时创建一张启动盘是个不错的主意。这是为了在错误发声时帮你修复系统。
如果你的硬件不允许你在 chroot 环境里安装启动程序，那么你就<e>需要</e>创建一张 GRUB 启动盘。
这样你可以用它启动系统然后再安装 GRUB 到 MBR。要创建启动盘请键入：
</p>

<pre caption="创建 GRUB 启动盘">
# <i>cd /usr/share/grub/i386-pc/</i>
# <i>cat stage1 stage2 > /dev/fd0</i>
</pre>

<p>
现在用这张启动盘重启系统，在看到 <c>grub&gt;</c> 提示时，你就可以键入 <c>root</c> 和 <c>setup</c>
命令来安装 GRUB 了。
</p>

</body>
</section>
<section>
<title>LILO 启动盘</title>
<body>

<impo>
不要忘了在开始前在软驱里插入一张磁盘。
</impo>

<p>
如果你使用 LILO，创建一张启动盘也是个好主意：
</p>

<pre caption="创建 LILO 启动盘">
# <i>dd if=/boot/your_kernel of=/dev/fd0 </i>
<comment>(你的内核必需小于 1.44M)</comment>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>使用 GRP</title>
<section>
<body>

<p>
GRP 用户在这个阶段可以安装一些二进制的软件包：
</p>

<pre caption="从 GRP 安装">
# <i>emerge -k xfree</i>
</pre>

<p>
CD 1包含了安装一个带有 XFree86 的系统所需的足够软件包。双光盘GRP套装的 CD 2 内含了 KDE，GNOME，Mozilla等其它软件。
要安装这些软件包，你需要重启进入新系统（查看本文最后的“安装完毕”部分）。当你从硬盘启动进入新系统后，你就可以
挂载第二张光盘来复制所需软件。
</p>

<pre caption="从 CD2 安装二进制软件">
# <i>mount /dev/cdrom /mnt/cdrom</i>
# <i>cp -a /mnt/cdrom/packages/* /usr/portage/packages/</i>
</pre>

<p>
参照上面的方法安装其它软件，如：
</p>

<pre caption="从 GRP 安装 KDE">
# <i>emerge -k kde</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>安装完毕！</title>
<section>
<body>

<p>
到现在，Gentoo Linux 已经安装完毕。剩下的扫尾工作就是更新设置文件、退出 chroot 环境、安全地卸载
系统分区，然后重启系统：
</p>

<warn>
<c>etc-update</c> 命令会提供给你一份需要更新的配置文件清单。
运行时请注意不会影响到一些重要的配置文件（如 <path>/etc/fstab</path>,
<path>/etc/make.conf</path>, <path>/etc/rc.conf</path>, ...)。
更新新的配置文件一般影响不大，你可以移除更新，或手动利用 diff 更新。
</warn>

<pre caption="重新启动系统">
# <i>etc-update</i>
# <i>exit</i> 
<comment>(这回退出 chroot 环境，你也可以键入 <i>^D</i>)</comment>
# <i>cd / </i>
# <i>umount /mnt/gentoo/boot</i>
# <i>umount /mnt/gentoo/proc</i>
# <i>umount /mnt/gentoo</i>
# <i>reboot</i>
<comment>(别忘了弹出安装光盘)</comment>
</pre>

<note>
重启系统后，我们建议你运行一下 <c>modules-update</c> 来建立 <path>/etc/modules.conf</path> 文件。
不要直接修改这个文件，如果需要应该修改 <path>/etc/modules.d</path> 中的相应文件。
</note>

<p>
如果你有任何问题或是想加入 Gentoo Linux 开发组，请加入我们的 gentoo-user 和 gentoo-dev 邮件列表
(更多信息请访问我们的 <uri
link="http://www.gentoo.org/main/en/lists.xml">邮件列表</uri> 页).
你也可以阅读 <uri
link="http://www.gentoo.org/doc/en/desktop.xml">桌面设置向导</uri> 文档来帮助你进一步配置你的桌面系统。 <uri
link="http://www.gentoo.org/doc/en/portage-user.xml">Portage 用户指南</uri>
将指导你了解有关 Portage 的知识。你可以在 <uri
link="http://www.gentoo.org/main/en/docs.xml">这里</uri> 找到有关 Gentoo Linux 的其它文档。如果你有安装或其它方面的问题，请访问我们的 <uri
link="http://www.gentoo.org/doc/en/faq.xml">FAQ</uri> 页。欢迎使用 Gentoo Linux！
</p>

</body>
</section>
</chapter>

<!--
            Gentoo Stats is down currently. Commenting out for the
            time being. I've also changed double-dash to dash-space-dash
            because otherwise commenting fails.
<chapter>
<title>Gentoo-Stats</title>
<section>
<body>

<p>
The Gentoo Linux usage statistics program was started as an attempt to give 
the developers a way to find out about their user base. It collects information
about Gentoo Linux usage to help us in set priorities our development. 
Installing it is completely optional and it would be greatly appreciated if 
you decide to use it. Compiled statistics can be viewed at 
<uri>http://stats.gentoo.org/</uri>.
</p>

<p>
The gentoo-stats server will assign a unique ID to your system.
This ID is used to make sure that each system is counted only once. The ID 
will not be used to individually identify your system, nor will it be matched 
against an IP address or other personal information. Every precaution has been 
taken to assure your privacy in the development of this system. The following 
are the things that we are monitoring right now through our "gentoo-stats" 
program:
</p>

<ul>
<li>installed packages and their version numbers</li>
<li>CPU information: speed (MHz), vendor name, model name, CPU flags (like "mmx" or "3dnow")</li>
<li>memory information (total available physical RAM, total available swap space)</li>
<li>PCI cards and network controller chips</li>
<li>the Gentoo Linux profile your machine is using (that is, where the <path>/etc/make.profile</path> link is pointing to).</li>
</ul>

<p>
We are aware that disclosure of sensitive information is a threat to most 
Gentoo Linux users (just as it is to the developers).
</p>

<ul>
<li>Unless you modify the gentoo-stats program, it will never transmit sensitive information such as your passwords, configuration data, shoe size...</li>
<li>Transmission of your e-mail addresses is optional and turned off by default.</li>
<li>The IP address your data transmission originates from will never be logged in such a way that we can identify you. There are no "IP address/system ID" pairs.</li>
</ul>

<p>
The installation is easy - just run the following commands:
</p>

<pre caption="Installing gentoo-stats">
# <i>emerge gentoo-stats</i>   <comment>(Installs gentoo-stats)</comment>
# <i>gentoo-stats - -new</i>    <comment>(Obtains a new system ID)</comment>
</pre>

<p>
The second command above will request a new system ID and enter it into
<path>/etc/gentoo-stats/gentoo-stats.conf</path> automatically. You can view 
this file to see additional configuration options.
</p>

<p>
After that, the program should be run on a regular schedule (gentoo-stats does 
not have to be run as root). Add this line to your <path>crontab</path>:
</p>

<pre caption="Updating gentoo-stats with cron">
0 0 * * 0,4 /usr/sbin/gentoo-stats - -update &gt; /dev/null
</pre>

<p>
The <c>gentoo-stats</c> program is a simple perl script which can be
viewed with your favorite pager or editor: <path>/usr/sbin/gentoo-stats</path>.
</p>

</body>
</section>
</chapter>

-->

<chapter>
<title>在不常见的硬件上使用 Gentoo</title>
<section>
<title>ATA RAID</title>
<body>

<p>
想在 ATA RAID 上安装 Gentoo Linux 的用户必须注意下面的步骤，这样才能帮助你安装 Gentoo Linux：
</p>

<ul>
<li>
首先启动 Live CD 时必须使用 <c>doataraid</c> 内核参数。</li>
<li>如果启动时你忘了使用 <c>doataraid</c> 参数，或是模块没有装载成功，你要手动装载：
<pre caption = "装载 RAID 模块">
# <i>modprobe ataraid</i>
<comment>针对 Promise Raid 控制芯片：</comment>
# <i>modprobe pdcraid</i>
<comment>针对 Highpoint Raid 控制芯片：</comment>
# <i>modprobe hptraid</i>
</pre></li>
<li>某些 ATA RAID 控制芯片需要分区后重启系统，否则有可能导致失败。</li>
<li>在进入 chroot 环境前，将设备树（devicetree）载入新环境：
<pre caption = "挂载 /dev 到 /mnt/gentoo/dev">
# <i>mount -o bind /dev /mnt/gentoo/dev</i>
</pre></li>
<li>在配置内核时,要编译进所需的 RAID 选项：
<pre caption = "内核配置中的 RAID 选项">
<comment>针对 Highpoint RAID 控制芯片：</comment>
ATA/IDE/MFM/RLL support  ---&gt;
[*] HPT36X/37X chipset support 
[*] Support for IDE Raid controllers
[*] Highpoint 370 software RAID
<comment>针对 Promise RAID 控制芯片：</comment>
ATA/IDE/MFM/RLL support  ---&gt;
[*] PROMISE PDC202{46|62|65|67} support 
<comment>和/或</comment>
[*] PROMISE PDC202{68|69|70|71|75|76|77} support
[*] Support for IDE Raid controllers
[*] Support Promise software RAID (Fasttrak(tm))
</pre></li>
<li>在 GRUB 安装阶段，把 <c>--stage2=/boot/grub/stage2</c> 参数加入 <c>setup</c> 命令中：
<pre caption = "为 RAID 系统安装 GRUB">
grub&gt; <i>root (hd0,0)</i>
grub&gt; <i>setup --stage2=/boot/grub/stage2 (hd0)</i>
grub&gt; <i>quit</i>
</pre>
同样，在 GRUB 配置文件中也要确保将根分区指向正确的 RAID 设备：
<pre caption = "使用 RAID 的grub.conf">
title=My Gentoo Linux on RAID
root (hd0,0)
kernel (hd0,0)/boot/bzImage root=/dev/ataraid/dXpY
</pre></li>
<li>LILO 用户需要将 <c>root</c> 指向正确的 RAID 设备：
<pre caption = "使用 RAID 的lilo.conf">
image=/boot/bzImage
label=linux
read-only
root=/dev/ataraid/dXpY
</pre></li>
</ul>

<p>
如果你还有关于 Gentoo Linux 上使用 RAID 的问题，请将问题报告至 <uri>http://bugs.gentoo.org</uri>。
</p>

<p>
感谢你选择 Gentoo Linux，享受你的 Gentoo 吧！</p>


</body>
</section>
</chapter>
</guide>
