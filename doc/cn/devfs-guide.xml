<?xml version='1.0' encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/guide.xsl" ?>
<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/devfs-guide.xml, v1.5 2003/12/11 16:13:37 dertobi123 Exp $ -->

<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/zh_cn/devfs-guide.xml">
<title>设备文件系统教程</title>
<author title="Author">
  <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Reviewer">
  <mail link="seemant@gentoo.org">Seemant Kulleen</mail>
</author>
<author title="Translator">
  <mail link="kuyeboy@hotmail.com">Xuqing Kuang</mail>
</author>

<abstract>
在本文档中，你将能了解到 devfs 的性质以及它的工作原理。
</abstract>

<license/>

<version>0.1</version>
<date>2003年9月11日</date>

<chapter>
<title>什么是 devfs？</title>
<section>
<title>在过去。。。。。。</title>
<body>

<p>
在过去的 Linux 系统中提供了一个抽象化的设备目录，叫做 <path>/dev</path>。
在该目录中用户可以找到<e>设备节点</e>，这些特殊的文件直接指向了系统中的
硬件设备。例如，<path>/dev/hda</path> 指向了系统中的第一个 IDE 设备。利用这
些提供给用户的设备文件，他们可以编写应用程序像访问普通文件一样来访问硬件，
而不需要通过特殊的 API。
</p>

<p>
设备文件分为两类，称作<e>字符</e>设备与<e>块</e>设备，第一类包含了那些
进行读写操作时不需要通过缓冲区的设备。第二组自然包含了那些做读写操作时
需要缓冲区的设备。两种设备都可以在同一时间内读取一个字符，或者一个块。
因此这意味着声音的冲突是不可避免的。
</p>

<p>
如果你查看一个设备文件，你将会看到类似下面的内容:
</p>

<pre caption = "查看设备文件信息">
# <i>ls -l /dev/hda</i>
brw-rw----    1 root     disk       3,  0 Jul  5  2000 /dev/hda
</pre>

<p>
在上一个范例中我们看到 <path>/dev/hda</path> 是一个块设备。但是，更重要的是，
它链接了两个特殊的号码 <path>3,0</path>。这对号码称为<e>主-次</e>对。它用于
核心将该设备文件映射到真实设备上。
主编号指向了该设备，而次编号指向了子设备，这看起来冲突吗？不会的。
</p>

<p>
这里有两个范例为 <path>/dev/hda4</path> 和 <path>/dev/tty5</path>。第一个设
备文件指向了第一个 IDE 设备的第四个分区。它的主次对为<path>3,4</path>，在
这里，次编号指向了分区而主编号指向了设备。第二个范例中，主次对为 <path>3,4</path>，
在这里，主编号指向到终端设备，次编号指向终端编号(在这里时第五个终端)。
</p>

</body>
</section>
<section>
<title>相关问题</title>
<body>

<p>
如果你快速扫描一次 <path>/dev</path> 中的文件，你将会发现其中不光不仅仅
有你机器上的所有设备，或者说在你机器上<e>所有</e>你可以看到的设备，换句话说，
你还有许多你并没有指向该设备的设备文件。至于如何管理这大量的设备组
将会在后面提到。你可以先想像一下改变你机器上所有设备所对应的设备文件的权限，
然后将它们恢复过来。
</p>

<p>
当你添加一个新设备到你的系统中时，但是这个设备之前并没有对应的设备文件， 
你应该自己创建一个，高级用户可以很熟练地通过 <path>/dev</path> 中的 
<c>./MAKEDEV</c> 来做这件事情，但是你知道哪种设备文件需要你创建吗?
</p>

<p>
当你有了一个通过设备文件来访问硬件的程序时，你不能将根目录以只读属性加载，
没有其它办法必须以可读写模式加载。并且你不能将 <path>/dev</path> 加载于
任何一个单独的分区上，因为 mount 命令需要 <path>/dev</path> 来加载分区。
</p>

</body>
</section>
<section>
<title>实际问题</title>
<body>

<p>
你可以想像，内核开发者们当然找到了前面所提到的种种问题。不管怎样，其中大多
数问题能在这里得到更详细的描述 
<uri>http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html#faq-why</uri>。

我们现在并没有在讨论这些，但是请注意这些问题将直接关系到稳定版内核：devfs。
</p>

</body>
</section>
<section>
<title>devfs 就是解决方案</title>
<body>

<p>
devfs 处理了所有的问题。它只是提供给用户管理这些已有设备的功能，当新硬
件添加时的自动添加新的节点，使将根目录以只读属性加载成为可能。以及解决
了其它我们之前还没有发现的问题。 
</p>

<p>
举个例子，通过 devfs，你将可以逃离主次对管理的痛苦。它始终支持着（为了向
后兼容），但是不必要。它使 Linux 自动支持更多的设备成为可能，知道没有
任何资源可以分配（数字总是有限的 :-)）
</p>

</body>
</section>
</chapter>

<chapter>
<title>设备树浏览</title>
<section>
<title>目录</title>
<body>

<p>
首先你要注意的事情是 devs 通过设备组目录树来组织设备文件。这种方式提高了可读
性，同事所有相关设备都将放在其标准的目录里。
</p>

<p>
举个例子，所有的 IDE 相关设备都在 <path>/dev/ide/</path> 设备目录里，而 SCSI 
相关设备在 <path>/dev/scsi/</path>。SCSI 和 IDE 磁盘在某种程度上有些相同点，
这意味着他们可能在同一个子目录结构里。
</p>

<p>
IDE 和 SCSI 磁盘通过其控制卡进行控制（可以是内置与主板上的，也可以是单独的控
制卡），叫做<e>控制器</e>，每个控制卡可以有很多通道。
一个通道<e>总线</e>。在每一个总线里，还能有许多编号。假设某个编号控制着一个
磁盘，该编号成为<e>目标</e>。许多 SCSI 设备还可以有多个逻辑单元号(<e>Logical 
Unit Numbers</e>)，

举个例子某个设备链接到多个媒体（如高端的磁带设备）。你通常只有一个逻辑单元号，
<path>lun0/</path>。
</p>

<p>
所以，当 <path>/dev/hda4</path> 如果已经被使用过了，我们会拥有一个
<path>/dev/ide/host0/bus0/target0/lun0/part4</path>。这将使管理容易很多。:)
</p>

<note>
你同样能使用类似 Unix 的磁盘命名方式来管理磁盘，如<path>c0b0t0u0p2</path>。
他们能在<path>/dev/ide/hd</path>或者<path>/dev/scsi/hd</path>类似的路径中找到。
</note>

<p>
这里是一个目录范例，这是我的笔记本的目录列表：
</p>

<pre caption = "/dev 目录列表">
cdroms/     cpu/        discs/          floppy/
ide/        input/      loop/           misc/
netlink/    printers/   pts/            pty/
scsi/       sg/         shm/            sound/
sr/         usb/        vc/             vcc/
</pre>

</body>
</section>
<section>
<title>通过 devfsd 实现向后兼容</title>
<body>

<p>
使用新的声音主题自然能够增加情趣，但是许多工具和程序使用的是旧的主题。
请确认你的系统运行正常，<c>devfsd</c> 正常运行。并且该守护进程创建了
旧方式的名称来指向设备文件。
</p>

<pre caption = "创建链接">
$ <i>ls -l /dev/hda4</i>
lr-xr-xr-x    1 root     root           33 Aug 25 12:08 /dev/hda4 -> ide/host0/bus0/target0/lun0/part4
</pre>

<p>
通过<c>devfsd</c>，你可以设置权限，创建新的设备文件，定义行为动作（Actions）等。
相关内容将在下一节中介绍
</p>

</body>
</section>
</chapter>

<chapter>
<title>管理设备树</title>
<section>
<title>重启 devfsd</title>
<body>

<p>
当你修改 <path>/dev/devfsd.conf</path> 配置文件后，而你就想使修改在当前系统中生效，
你不需要重新启动。关于你的想法，你可以通过两种“信号”（Signal）中的任意一种来实现它。
</p>

<p>
<b>SIGHUP</b> 将能够使 <c>devfsd</c> 重新读取配置文件，重新读取共享目标并为设备树中
的子节点重新生成注册信息。
</p>

<p>
<b>SIGUSR1</b> 也可以实现此目的，但不生成注册信息。
</p>

<p>
要发送信号，可以简单地通过 <c>kill</c> 或者 <c>killall</c>命令：
</p>

<pre caption = "发送 SIGHUP 信号给devfsd">
# <i>kill -s SIGHUP `pidof devfsd`</i>
<comment>或者</comment>
# <i>killall -s SIGHUP devfsd</i>
</pre>

</body>
</section>
<section>
<title>删除兼容链接</title>
<body>

<warn>
目前，Gentoo 还无法脱离兼容链接而正常运行。
</warn>

<p>
如果你想将 <path>/dev</path> 中凌乱的兼容链接从你的 Gentoo 系统中删除
（Gentoo 是默认启用它的），编辑你的 <path>/etc/devfsd.conf</path> 并删除下
面两行：

</p>

<pre caption = "通过 /etc/devfsd.conf 实现向后兼容">
<comment># 注释下面两行以删除符号链接</comment>
REGISTER        。*  MKOLDCOMPAT
UNREGISTER      。*  RMOLDCOMPAT
</pre>

<p>
你需要重新启动以便使修改生效。
</p>

</body>
</section>
<section>
<title>删除自动加载函数</title>
<body>

<p>
当你加载一个内核模块时，devfs 将为它自动创建一个设备文件。如果你喜欢这样，
可以删除 <path>/etc/devfsd.conf</path> 中的下列内容：
</p>

<pre caption = "/etc/devfsd.conf，自动加载函数">
LOOKUP      。*  MODLOAD
</pre>

</body>
</section>
</chapter>

<chapter>
<title>关于权限</title>
<section>
<title>通过 PAM 设置、修改权限</title>
<body>

<p>
虽然你可以在 <path>/etc/devfsd.conf</path> 设置权限，但依然建议你通过可
插拔验证模块（Pluggable Authentication Module，PAM）来实现这一点。这是因为
 PAM 才是最终的身份验证方式，它可以使你在不改动 <path>/etc/devfsd.conf</path> 
来改变设备文件权限。
</p>

<p>
PAM 使用 <path>/etc/security/console.perms</path> 文件来配置权限。该文件包含
两部分：第一部分是组的详细信息，第二部分是权限设置。
</p>

<p>
让我们首先来看一下组的设置。我们以声音组来作为范例：
</p>

<pre caption = "/etc/security/console.perms 的声音组权限设置">
&lt;sound&gt;=/dev/dsp* /dev/audio* /dev/midi* \
    /dev/mixer* /dev/sequencer* \
    /dev/sound/* /dev/snd/* /dev/beep \
    /dev/admm* \
    /dev/adsp* /dev/aload* /dev/amidi* /dev/dmfm* \
    /dev/dmmidi* /dev/sndstat
</pre>                  

<p>
这里的语法非常简单：以一个组名开始，以该组中包含的设备文件结束。
</p>

<p>
目前，组部分并不是非常通用在你还对其无法进行修改之前。所以在下一章中将介绍如何
设置权限。
</p>

<pre caption = "/etc/security/console.perms 里声音组的权限配置">
&lt;console&gt;  0600 &lt;sound&gt;      0600 root.audio
</pre>

<p>
第一部分是终端类型的检查。在大多数系统中，这里称为“控制台组”（console-group）。
PAM 将在每次启动时检查这一段。如果你在控制台组设备中登陆，PAM 将检查并修改
其中一些设备文件的权限。
</p>

<p>
第二部分包含了可登陆设备文件的权限配置。当某人登陆进系统中时，该设备文件原默认的
所有者/所有组，将会被 PAM 改为登陆用户的用户名和组。同时，权限也在第二部分设置，
在这里，0600 将会被使用（所有者将对其拥有读写权限，
而其它用户不行）。
</p>

<p>
第三部分包含了设备组中哪些设备的权限将被修改。在这里，该声音组（所有关于声音的设备
）都将被修改。
</p>

<p>
第四部分内容定义了了默认状态下设备文件的权限。在这里，当这些设备的所有者登出系统
之后，PAM 将会将这些设备文件恢复成默认的权限设置，而第四部分旧包含了具体的配置。
</p>

<p>
第五部分内容定义了默认状态下设备文件所有者（组）。在这里当这些设备的所有者登出系统
之后，PAM 将会将这些设备文件恢复成默认的所有者，而第五部分旧包含了具体的配置。
</p>

</body>
</section>
<section>
<title>通过 devfsd 来设置、修改权限</title>
<body>

<p>
如果你希望通过 <path>/etc/devfsd.conf</path> 来修改权限，你可以参考下列范例：
</p>

<pre caption = "/etc/devfsd.conf 中的权限设置">
REGISTER    ^cdroms/.*  PERMISSIONS root.cdrom 0660
</pre>

<p>
第二部分内容是关于设备组，以 <path>/dev</path> 开始。他是一个正则表达式，意味着你可
以在一个规则里选择多个设备。
</p>

<p>
第四部分是关于设备文件的拥有者。不像 PAM 这里不会改变（unless it is mentioned in 
<path>console.perms</path> since PAM always wins）。
</p>

<p>
第五部分包含了设备文件的权限设置。
</p>

</body>
</section>
<section>
<title>自定义权限并通过 devfs 保存改变后的设置</title>
<body>

<p>
Gentoo 在默认情况下：当你 <c>chown</c> (改变所有者) 或者 <c>chmod</c> (修改权限)
一些设备文件的权限时，<c>devfsd</c> 将会在关机前自动保存这些信息。这是因为在 
<path>/etc/devfsd.conf</path> 配置文件中包含下面几行：
</p>

<pre caption = "/etc/devfsd.conf 自动保存权限修改设置">
REGISTER        ^pt[sy]/。*   IGNORE
CHANGE          ^pt[sy]/。*   IGNORE
CREATE          ^pt[sy]/。*   IGNORE
DELETE          ^pt[sy]      IGNORE
REGISTER        ^log         IGNORE
CHANGE          ^log         IGNORE
CREATE          ^log         IGNORE
DELETE          ^log         IGNORE
REGISTER        。*           COPY    /lib/dev-state/$devname $devpath
CHANGE          。*           COPY    $devpath /lib/dev-state/$devname
CREATE          。*           COPY    $devpath /lib/dev-state/$devname
DELETE          。*           CFUNCTION GLOBAL unlink
/lib/dev-state/$devname
RESTORE         /lib/dev-state
</pre>

<p>
在上面的内容中，被改变的设备文件将会在关机前被拷贝到 
<path>/lib/dev-state</path>，并在开机时拷贝回 <path>/dev</path>。
</p>

<p>
另一种方式时在启动时将 <path>/lib/dev-state</path> 加载到 <path>/dev</path>，
你必须确认 devfs 并没有在开机时自动加载（这可能以为着你需要重新编译内核），
同时你的 <path>/dev/console</path>  存在。然后在你的开机自启动脚本开头加上下面内容：
</p>

<pre caption = "加载 /lib/dev-state 到 /dev">
mount --bind /dev /lib/dev-state
mount -t devfs none /dev
devfsd /dev
</pre>

</body>
</section>
</chapter>

<chapter>
<title>相关资源</title>
<section>
<body>

<p>
想更多地了解 devfs，请查看下列相关资源。
</p>

<p>
devfsd。conf 的 man 帮助页中叙述了 <path>/etc/devfsd.conf</path> 的语法，
可以通过 <c>man devfsd.conf</c> 来查看它。
</p>

<p>
<uri
link="http://www.atnf.csiro.au/people/rgooch/linux/docs/devfs.html">devfs
FAQ</uri> 叙述了关于 devfs 的几乎所有内容，当然也包含了 devfs 的内部结构
以及如何使设备支持 devfs。
</p>

<p>
<uri link="http://www.linuxjournal.com">LinuxJournal</uri> 里有一些有趣的内容 - <uri
link="http://www。linuxjournal。com/article。php?sid=6035">devfs 系统管理</uri>。
</p>

<p>
丹尼尔罗宾斯在 IBM's DeveloperWorks 写的一份关于高级文件系统的论文中，
有三部分内容与 devfs 有关:
</p>

<ul>
  <li>
    <uri link="http://www-900.ibm.com/developerWorks/zh_cn/linux/filesystem/l-fs4/">
    介绍 devfs</uri>
  </li>
  <li>
    <uri link="http://www-900.ibm.com/developerWorks/zh_cn/linux/filesystem/l-fs5/">
    设置 devfs</uri>
  </li>
  <li>
    <uri link="http://www-900.ibm.com/developerWorks/zh_cn/linux/filesystem/l-fs6/">
    实现 devfs（使用初始化封装器）</uri>
  </li>
</ul>

</body>
</section>
</chapter>
</guide>
