<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type="text/xsl" href="/xsl/guide.xsl" ?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/handbook/hb-working-variables.xml,v 1.6 2004/03/01 05:43:42 swift Exp $ -->

<sections>
<section>
<title>环境变量？</title>
<subsection>
<title>它们是什么？</title>
<body>

<p>
一个环境变量是一个包含了被一个或多个程序所用的信息的对象。很多用户（特别是Linux的新手）发现这些变量有些奇怪或者不好管理。而事实上这是错误的：通过使用环境变量，用户可以很容易的给一个或多个程序修改一处配置。
</p>

</body>
</subsection>
<subsection>
<title>重要的例子</title>
<body>

<p>
下表列出了一些Linux系统使用的环境变量以及他们的用处。在表后举例给出了这些变量的值。
</p>

<table>
<tr>
  <th>变量</th>
  <th>描述</th>
</tr>
<tr>
  <ti>PATH</ti>
  <ti>
    这个变量包含了一系列由冒号隔开的文件夹，你的系统将会在这些文件夹中寻找可执行文件。如果你输入一个可执行程序的名字（如<c>ls</c>、<c>rc-update</c>或者<c>emerge</c>）而并不在这一系列文件夹中，你的系统将不会执行它（除非你输入命令的全路径，如<c>/bin/ls</c>）。
  </ti>
</tr>
<tr>
  <ti>ROOTPATH</ti>
  <ti>
    这个变量同<c>PATH</c>功能相同，但是这个只列出超级用户输入命令时所查看的文件夹。
  </ti>
</tr>
<tr>
  <ti>LDPATH</ti>
  <ti>
    这个变量包含了一系列冒号隔开的文件夹，动态链接程序将在这些文件夹里搜索库文件。
  </ti>
</tr>
<tr>
  <ti>MANPATH</ti>
  <ti>
    这个变量包含了一系列冒号隔开的文件夹，命令<c>man</c>将在这些文件夹里搜索手册页面（man）。
  </ti>
</tr>
<tr>
  <ti>INFODIR</ti>
  <ti>
    这个变量包含了一系列冒号隔开的文件夹，命令<c>info</c>将在这些文件夹里搜索帮助页面（info）。
  </ti>
</tr>
<tr>
  <ti>PAGER</ti>
  <ti>
    这个变量包含了用作列出文件内容的程序的路径（如<c>less</c>或者<c>more</c>）。
  </ti>
</tr>
<tr>
  <ti>EDITOR</ti>
  <ti>
    这个变量包含了用作编辑文件内容的程序的路径（如<c>nano</c>或者<c>vi</c>）。
  </ti>
</tr>
<tr>
  <ti>KDEDIRS</ti>
  <ti>
    这个变量包含了一系列冒号隔开的包含KDE相关资料的文件夹。
  </ti>
</tr>
<tr>
  <ti>CLASSPATH</ti>
  <ti>
    这个变量包含了一系列冒号隔开的包含Java class的文件夹。
  </ti>
</tr>
<tr>
  <ti>CONFIG_PROTECT</ti>
  <ti>
    这个变量包含了一系列空格隔开的在更新时需要由Portage保护的文件夹。
  </ti>
</tr>
<tr>
  <ti>CONFIG_PROTECT_MASK</ti>
  <ti>
    这个变量包含了一系列空格隔开的在更新时不需由Portage保护地文件夹。
  </ti>
</tr>
</table>

<p>
在下面你可以找到所有这些变量的定义样例：
</p>

<pre caption="定义样例">
PATH="/bin:/usr/bin:/usr/local/bin:/opt/bin:/usr/games/bin"
ROOTPATH="/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin"
LDPATH="/lib:/usr/lib:/usr/local/lib:/usr/lib/gcc-lib/i686-pc-linux-gnu/3.2.3"
MANPATH="/usr/share/man:/usr/local/share/man"
INFODIR="/usr/share/info:/usr/local/share/info"
PAGER="/usr/bin/less"
EDITOR="/usr/bin/vim"
KDEDIRS="/usr"
CLASSPATH="/opt/blackdown-jre-1.4.1/lib/rt.jar:."
CONFIG_PROTECT="/usr/X11R6/lib/X11/xkb /opt/tomcat/conf \
                /usr/kde/3.1/share/config /usr/share/texmf/tex/generic/config/ \
                /usr/share/texmf/tex/platex/config/ /usr/share/config"
CONFIG_PROTECT_MASK="/etc/gconf"
</pre>

</body>
</subsection>
</section>
<section>
<title>全局定义变量</title>
<subsection>
<title>文件夹/etc/env.d</title>
<body>

<p>
Gentoo提供了文件夹<path>/etc/env.d</path>来集中这些变量的定义。在这个文件夹里，你将找到许多文件，如<path>00basic</path>、<path>05gcc</path>等等，这些包含了文件名中提到的程序需要的变量。
</p>

<p>
比如，当你安装<c>gcc</c>时，一个叫做<path>05gcc</path>的文件将会由Ebuild创建，文件里包含了下面变量的定义：
</p>

<pre caption="/etc/conf.d/05gcc">
PATH="/usr/i686-pc-linux-gnu/gcc-bin/3.2"
ROOTPATH="/usr/i686-pc-linux-gnu/gcc-bin/3.2"
MANPATH="/usr/share/gcc-data/i686-pc-linux-gnu/3.2/man"
INFOPATH="/usr/share/gcc-data/i686-pc-linux-gnu/3.2/info"
CC="gcc"
CXX="g++"
LDPATH="/usr/lib/gcc-lib/i686-pc-linux-gnu/3.2.3"
</pre>

<p>
其他的发行版告诉你要去<path>/etc/profile</path>或者其他位置修改或者添加这些变量声明。而Gentoo使得你（以及Portage）维护和管理这些变量更加简便，不需要把集中力放在许多包含环境变量的文件上。
</p>

<p>
比如，当<c>gcc</c>更新时，不需要任何和用户的交互询问也将文件<path>/etc/env.d/05gcc</path>更新。
</p>

<p>
这不仅对Portage受益，也对你有益。偶尔你可能被要求设置某一个系统范围的变量。我们拿变量<c>http_proxy</c>作为例子，你只需要创建一个文件（<path>/etc/env.d/99local</path>）并在其中输入这些变量的声明：
</p>

<pre caption="/etc/env.d/99local">
http_proxy="proxy.server.com:8080"
</pre>

<p>
通过对你所有的变量使用相同的文件，你可以得到你已定义的变量的概述。
</p>

</body>
</subsection>
<subsection>
<title>脚本env-update</title>
<body>

<p>
<path>/etc/env.d</path>里的几个文件都定义了变量<c>PATH</c>，这并没有错误：当你运行<c>env-update</c>，它将在更新环境变量之前合并这几个定义，这样使得软件包（或者用户）添加它们自己的环境变量更容易，也不会影响到已存在的值。
</p>

<p>
脚本<c>env-update</c>将会根据<path>/etc/env.d</path>里文件的字母顺序来附加变量的值。这也就是为什么<path>/etc/env.d</path>里的文件命名以数字开头。
</p>

<pre caption="env-update的更新顺序">
         00basic        99kde-env       99local
     +-------------+----------------+-------------+
PATH="/bin:/usr/bin:/usr/kde/3.2/bin:/usr/local/bin"
</pre>

<p>
当你运行<c>env-update</c>时，这个脚本将会在<path>/etc/profile.env</path>（<path>/etc/profile</path>要使用到）里创建所有的环境变量。它也会抽象变量<c>LDPATH</c>的信息来创建文件<path>/etc/ld.so.conf</path>。然后，它将运行<c>ldconfig</c>来重新创建动态链接程序所需要的文件<path>/etc/ld.so.cache</path>。
</p>

<p>
如果你想在运行<c>env-update</c>后立即能看到它的效用，执行下面的命令来更新你的环境。自己安装Gentoo的用户很可能记得在安装说明中有这个：
</p>

<pre caption="更新环境">
# <i>env-update &amp;&amp; source /etc/profile</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>定义本地变量</title>
<subsection>
<title>特定用户</title>
<body>

<p>
你并不是一直都要全局定义一个环境变量。比如，你可能要将<path>/home/my_user/bin</path>添加到变量<c>PATH</c>中，但并不需要其他所有的用户在他们的变量<c>PATH</c>中有这个。如果你要定义一个本地的环境变量，你应该使用<path>~/.bashrc</path>或者<path>~/.bash_profile</path>：
</p>

<pre caption="在~/.bashrc扩展PATH作为本地使用">
PATH="${PATH}:/home/my_user/bin"
</pre>

<p>
当你重新登录时，变量<c>PATH</c>将会更新。
</p>

</body>
</subsection>
<subsection>
<title>特定期间</title>
<body>

<p>
有时候需要更严格的定义。你可能想使用一个你创建的临时文件夹里的程序，而不使用程序的文件夹或者为这一会儿编辑<path>~/.bashrc</path>。
</p>

<p>
在这种情况下，你只需要使用命令<c>export</c>在你的当前期间定义变量<c>PATH</c>。只要你没有注销登录，变量<c>PATH</c>将会使用这个临时设置。
</p>

<pre caption="定义一个特定期间的环境变量">
# <i>export PATH="${PATH}:/home/my_user/tmp/usr/bin"</i>
</pre>

</body>
</subsection>
</section>
</sections>
