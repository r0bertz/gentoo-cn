<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type="text/xsl" href="/xsl/guide.xsl" ?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/handbook/hb-working-behaviour.xml,v 1.14 2004/07/20 17:12:29 vapier Exp $ -->

<sections>
<section>
<title>配置文件的保护</title>
<subsection>
<title>保护？</title>
<body>

<p>
Portage有一个“保护文件”的概念，也就是说，当你更新软件时，它不会立即用新的版本覆盖这些文件，而是会先告诉你现在已经有了一个新的版本。这对配置文件（在<path>/etc</path>里的文件）来说当然是很有用的。
</p>

<p>
它不会覆盖这些文件，反而会创建一个新的名为<path>._cfg0000_&lt;name&gt;</path>的文件，这里<path>&lt;name&gt;</path>是原文件名。然后就该用户自己来比较与已有文件的不同。用户也可以使用命令<c>etc-update</c>来简化这个程序。后面我们将会讲到<c>etc-update</c>。
</p>

</body>
</subsection>
<subsection>
<title>声明CONFIG_PROTECT</title>
<body>

<p>
Portage不会保护在文件的基础上保护一个文件，反而它只会保护整个文件夹。变量<c>CONFIG_PROTECT</c>列出了所有受保护的文件夹。所列文件夹里的子文件夹当然也是受保护的。我们在<path>/etc/make.globals</path>中定义变量<c>CONFIG_PROTECT</c>，但是如果你要修改的话，就应该在<path>/etc/make.conf</path>中声明它（为统一起见，<path>/etc/make.conf</path>是用作所有的Portage配置文件）。
</p>

<pre caption="一个CONFIG_PROTECT设置的样例">
CONFIG_PROTECT="/etc /usr/share/config /usr/kde/3.1/share/config"
</pre>

<p>
如果你要保护某个文件夹，但不包括其所有的子文件，你可以通过将这些文件夹列表于变量<c>CONFIG_PROTECT_MASK</c>去掉保护。这个变量在<path>/etc/make.globals</path>中也有一个默认值，但是我们仍然应该在<path>/etc/make.conf</path>中声明：
</p>

<pre caption="一个CONFIG_PROTECT_MASK设置的样例">
CONFIG_PROTECT_MASK="/etc/init.d"
</pre>

<p>
更多有关配置文件的保护的信息可以在<c>emerge</c>的在线帮助中找到：
</p>

<pre caption="获得有关配置文件保护的信息">
# <i>emerge --help config</i>
</pre>

</body>
</subsection>
<subsection>
<title>etc-update</title>
<body>

<p>
<c>etc-update</c>是一个处理文件<path>._cfg0000_&lt;name&gt;</path>的工具。它提供了交互式的设置方式，也可以对一些微小的修改进行自动处理。
</p>

<p>
运行<c>etc-update</c>是很直接的：
</p>

<pre caption="运行etc-update">
# <i>etc-update</i>
</pre>

<p>
将微小的变化融入配置文件后，它会提示给你一系列的需要更新的受保护的文件。在底部你可能有几个可能的选择：
</p>

<pre caption="etc-update选项">
Please select a file to edit by entering the corresponding number.
              (-1 to exit) (-3 to auto merge all remaining files)
                           (-5 to auto-merge AND not use 'mv -i'): 
</pre>

<p>
如果你输入<c>-1</c>，<c>etc-update</c>将不会作任何事情而退出。如果你输入<c>-3</c>或者<c>-5</c>，<e>所有的</e>列出配置文件都将会被新的版本覆盖。因此很重要的一点，就是不要在开始学习选择不应该自动更新的配置文件。这个过程很简单，只是将输入处理配置文件办法的标号即可。
</p>

<p>
作为一个例子，我们选择配置文件<path>/etc/pear.conf</path>：
</p>

<pre caption="更新一个指定的配置文件">
Beginning of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
<comment>[...]</comment>
End of differences between /etc/pear.conf and /etc/._cfg0000_pear.conf
1) Replace original with update
2) Delete update, keeping original as is
3) Interactively merge original with update
4) Show differences again
</pre>

<p>
现在你可以看到两个文件的不同之处。如果你肯定更新后的配置文件使用起来会没有问题，输入<c>1</c>。如果你肯定更新的配置文件不是很必要，或者并没有提供任何新的或者有用的信息，输入<c>2</c>。如果你要交互的更新你目前的配置文件，输入<c>3</c>。
</p>

<p>
在这里讲解太多的交互式合并并没多大用处。为了方便起见，我们着里将列出你可以在交互合并这两个文件所可能用到的命令。在这个程序里，你将会看到两行（原文件的和新文件的）和一个提示符，这里你可以输入下面的命令：
</p>

<pre caption="Commands available for the interactive merging">
ed:     编辑并使用这两个版本，每个都有一个头标识。
eb:     编辑并使用这两个版本。
el:     编辑并使用左边的版本。
er:     编辑并使用右边的版本。
e:      编辑一个新的版本。
l:      使用左边的版本。
r:      使用右边的版本。
s:      包含相同的行，并不给出具体信息。
v:      包含相同的行，并给出具体信息。
q:      退出。
</pre>

<p>
当你完成一个重要文件的更新时，你现在可以自动更新所有其他的配置文件了。如果找不到其他需要更新的配置文件，<c>etc-update</c>将会退出。
</p>

</body>
</subsection>
</section>
<section>
<title>网络选项</title>
<subsection>
<title>镜像</title>
<body>

<p>
随着Gentoo的日渐流行，镜像的使用应该受到极大的重视。Portage使用三个变量用于镜像：一个用于rsync镜像（这个用于更新你的Portage树），一个用于源文件（这个用于下载源代码），还有一个用于预编译软件包。
</p>

<p>
所有可能的源文件镜像列表于<uri link="/main/en/mirrors.xml">Gentoo镜像页面</uri>。你也可以使用方便设置系统镜像的<c>mirrorselect</c>。但是首先，我们来一个个看看这些变量……
</p>

<p>
变量<c>SYNC</c>包含了你希望使用的rsync镜像。比如，要使用<uri>rsync://rsync.namerica.gentoo.org/gentoo-portage</uri>，你可以在<path>/etc/make.conf</path>这样定义：
</p>

<pre caption="在/etc/make.conf里定义SYNC">
SYNC="rsync://rsync.namerica.gentoo.org/gentoo-portage"
</pre>

<p>
变量<c>GENTOO_MIRRORS</c>包含了一系列的你希望使用的源代码镜像。比如，要使用<uri>ftp://ibiblio.org/pub/Linux/distributions/gentoo</uri>作为第一选择，使用<uri>http://www.gtlib.cc.gatech.edu/pub/gentoo</uri>作为第二选择，你可以在<path>/etc/make.conf</path>这样定义：
</p>

<pre caption="在/etc/make.conf里定义GENTOO_MIRRORS">
GENTOO_MIRRORS="ftp://ibiblio.org/pub/Linux/distributions/gentoo
                http://www.gtlib.cc.gatech.edu/pub/gentoo"
</pre>

<p>
变量<c>PORTAGE_BINHOST</c>包含了一系里你希望使用的预编译软件包镜像。比如，要使用<uri>ftp://login:pass@grp.mirror.site/pub/grp/i686/athlon-xp</uri>，你可以在<path>/etc/make.conf</path>这样定义：
</p>

<pre caption="在/etc/make.conf里定义PORTAGE_BINHOST">
PORTAGE_BINHOST="ftp://login:pass@grp.mirror.site/pub/grp/i686/athlon-xp"
</pre>

</body>
</subsection>
<subsection>
<title>Mirrorselect</title>
<body>

<p>
如果你要使用<c>mirrorselect</c>，首先安装它（如果你还没这样做的话）。
</p>

<pre caption="安装mirrorselect">
# <i>emerge mirrorselect</i>
</pre>

<p>
现在你可以让<c>mirrorselect</c>自动为你选择最好的镜像，或者从一个列表中选择。有关更多怎样使用<c>mirrorselect</c>的信息，只需要在命令行运行<c>mirrorselect</c>，它将会给你一个有关<c>mirrorselect</c>的快速概述。
</p>

<pre caption="运行mirrorselect">
# <i>mirrorselect</i>
</pre>

</body>
</subsection>
<subsection>
<title>下载</title>
<body>

<p>
Portage用来下载档案文件的程序可以通过设置变量<c>FETCHCOMMAND</c>和<c>RESUMECOMMAND</c>来指定。在<path>/etc/make.conf</path>和<path>/etc/make.globals</path>中有几个样例。默认情况下Portage将使用<c>wget</c>：
</p>

<pre caption="默认的FETCHCOMMAND和RESUMECOMMAND">
FETCHCOMMAND="/usr/bin/wget -t 5 --passive-ftp -P \${DISTDIR} \${URI}"
RESUMECOMMAND="/usr/bin/wget -c -t 5 --passive-ftp -P \${DISTDIR} \${URI}"
</pre>

<p>
变量<c>${DISTDIR}</c>将替换为下载文件保存的位置（<path>/usr/portage/distfiles</path>），而变量<c>${URI}</c>将替换为Portage要下载的文件。
</p>

<p>
因为Portage默认情况下使用<c>wget</c>，你可以通过定义<c>http_proxy</c>和<c>ftp_proxy</c>（注意是小写）来配置使用代理服务器。虽然你也可以在<path>/etc/make.conf</path>来做这个，但我们建议你是用一种更通用的方法如变量<c>http_proxy</c>和<c>ftp_proxy</c>（<path>/etc/make.conf</path>只用于Portage）请阅读有关<uri link="?part=2&amp;chap=6">环境变量</uri>这一章了解怎样声明系统范围的环境变量。
</p>

</body>
</subsection>
<subsection>
<title>配置rsync</title>
<body>

<p>
<c>rsync</c>是给<c>emerge sync</c>来更新你的Portage树。Portage用来改变<c>rsync</c>的行为的三个变量分别是：<c>RSYNC_EXCLUDEFROM</c>、<c>RSYNC_RETRIES</c>和<c>RSYNC_TIMEOUT</c>。
</p>

<p>
一种用来“保护”ebuilds防止在运行<c>emerge sync</c>时将其升级或者删除的方法是使用变量<c>RSYNC_EXCLUDEFROM</c>。这个变量应该设置为<c>rsync</c>要使用的一个文件，用来排除指定文件，默认情况下这个文件是<path>/etc/portage/rsync_excludes</path>。<e>不</e>推荐使用这种方法，因为一不小心它可能破坏依赖性。我们稍后将讲到<c>PORTDIR_OVERLAY</c>，这是我们推荐使用的。有关更多这方面的信息，请阅读<c>rsync</c>的手册。
</p>

<pre caption="变量RSYNC_EXCLUDEFROM">
RSYNC_EXCLUDEFROM="/etc/portage/rsync_excludes"
</pre>

<p>
当<c>rsync</c>失败后，它将测试一定的次数才转到另一个可能的rsync服务器。重试的此时是在<c>RSYNC_RETRIES</c>中定义，默认值为<c>3</c>：
</p>

<pre caption="变量RSYNC_RETRIES">
RSYNC_RETRIES="3"
</pre>

<p>
如果你使用一个（非常）慢的rsync服务器，如果没有流量<c>rsync</c>会超时终止。超时前等待的秒数可以在变量<c>RSYNC_TIMEOUT</c>中定义，默认值为<c>180</c>：
</p>

<pre caption="变量RSYNC_TIMEOUT">
RSYNC_TIMEOUT="180"
</pre>

</body>
</subsection>
</section>
<section>
<title>文件夹位置</title>
<subsection>
<title>简介</title>
<body>

<p>
任何有关Portage的都可以配置，就是各种各样的任务和Poratage所需的文件等用的文件夹也如此。要改变这些默认位置（在<path>/etc/make.globals</path>中定义），你需要在<path>/etc/make.conf</path>中准确的定义这些变量。
</p>

<warn>
如果你修改一个变量使其指向一个不同的位置，<e>不要</e>在路径后面加上<path>/</path>！
</warn>

</body>
</subsection>
<subsection>
<title>Portage树</title>
<body>

<p>
Portage树的位置在变量<c>PORTDIR</c>中定义，默认值为<path>/usr/portage</path>：
</p>

<pre caption="变量PORTDIR">
PORTDIR="/usr/portage"
</pre>

<p>
如果你要在官方的Portage树后面紧接一个本地Portage树，你需要定义变量<c>PORTDIR_OVERLAY</c>。<c>emerge sync</c>将不会影响这些文件夹位置：在这些位置中的ebuilds将不会更新和删除，但是也是你的Portage树的一部分。
</p>

<pre caption="变量PORTDIR_OVERLAY">
PORTDIR_OVERLAY="/usr/local/portage"
</pre>

</body>
</subsection>
<subsection>
<title>源文件（distfiles）</title>
<body>

<p>
下载的源文件（因此成为distfiles）的位置在变量<c>DISTDIR</c>中定义，默认值为<path>${PORTDIR}/distfiles</path>：
</p>

<pre caption="变量DISTDIR">
DISTDIR="${PORTDIR}/distfiles"
</pre>

</body>
</subsection>
<subsection>
<title>软件包和RPMs</title>
<body>

<p>
预编译包的位置在变量<c>PKGDIR</c>中定义，默认值为<path>${PORTDIR}/packages</path>：
</p>

<pre caption="变量PKGDIR">
PKGDIR="${PORTDIR}/packages"
</pre>

<p>
RPMs（有一些软件包以RPM形式存在）的位置在变量<c>RPMDIR</c>中定义，默认值为<path>${PORTDIR}/rpm</path>：
</p>

<pre caption="变量RPMDIR">
RPMDIR="${PORTDIR}/rpm"
</pre>

</body>
</subsection>
<subsection>
<title>临时的Portage文件</title>
<body>

<p>
Poratage使用一个临时的文件夹来编译它的ebuilds，这个位置在变量<c>PORTAGE_TMPDIR</c>中定义，默认值为<path>/var/tmp</path>：
</p>

<pre caption="变量PORTAGE_TMPDIR">
PORTAGE_TMPDIR="/var/tmp"
</pre>

<p>
默认情况下，Portage将会在<c>PORTAGE_TMPDIR</c>下创建一个文件夹<path>portage</path>，这个是在变量<c>BUILD_PREFIX</c>中定义：
</p>

<pre caption="变量BUILD_PREFIX">
BUILD_PREFIX="${PORTAGE_TMPDIR}/portage"
</pre>

<p>
如果你打算改变这个位置，确保这个临时文件夹是在一个有足够剩余空间的分区上：在编译大的软件时，这个文件夹可以超过2Gb的大小！
</p>

</body>
</subsection>
<subsection>
<title>日志</title>
<body>

<p>
<c>PORT_LOGDIR</c>是一个特殊的变量，默认情况下没有设定。当你定义好后，Portage将会在这个指定的文件夹里创建每个ebuild的日志文件：
</p>

<pre caption="变量PORT_LOGDIR">
PORT_LOGDIR="/var/log/portage"
</pre>

</body>
</subsection>
</section>
<section>
<title>其他的Portage选项</title>
<subsection>
<title>优先值</title>
<body>

<p>
Portage支持在编译时有不同的优先值。如果你要Portage编译软件包时有一个较高的优先值（在编译时系统更稳定，但也增加了编译时间），你需要设置变量<c>PORTAGE_NICENESS</c>为一个正数：
</p>

<pre caption="变量PORTAGE_NICENESS">
PORTAGE_NICENESS="3"
</pre>

</body>
</subsection>
<subsection>
<title>SLOT的软件包和自动清除</title>
<body>

<p>
在有些情况下，你需要一个软件包（包括库）的不同版本在你的系统上。Portage通过在ebuilds中定义变量<c>SLOT</c>来支持这个。作为一个用户，你不需要了解<c>SLOT</c>是怎样工作的，但是很必要知道它支持这个。
</p>

<p>
如果你安装一个软件的新版本，Portage会检查变量<c>SLOT</c>是否在这个软件包中声明。如果已经声明，软件包（旧版和新版）之间的变量<c>SLOT</c>不同，Portage将不会改动这个软件包的旧版。
</p>

<p>
但是，如果变量<c>SLOT</c>是一样的（大部分的情况下如此），默认情况下旧版的软件将会被删除。为了可以让用户打断这个删除，Portage将会倒计时一段时间。这个时间在变量<c>CLEAN_DELAY</c>中定义，默认值为<c>5</c>秒：
</p>

<pre caption="变量CLEAN_DELAY">
CLEAN_DELAY="5"
</pre>

<p>
如果你不想要让Portage自动删除旧的版本（称作“清除（cleaning）”），你可以设置变量<c>AUTOCLEAN</c>为<c>no</c>：
</p>

<pre caption="变量AUTOCLEAN">
AUTOCLEAN="no"
</pre>

</body>
</subsection>
<subsection>
<title>编译相关的变量</title>
<body>

<p>
我们已经朋到了大量的这种变量，但是我们还有些没有讨论过。安装Gentoo的人们都知道变量<c>CHOST</c>、<c>CFLAGS</c>和<c>CXXFLAGS</c>，这是编译器用来编译和优化软件包的。
</p>

<p>
更多有关这三个变脸的信息可以查看<c>gcc</c>的帮助页面（info）或者在线的<uri link="http://gcc.gnu.org/onlinedocs/">GCC在线手册</uri>.
</p>

<pre caption="获得有关CHOST, CFLAGS和CXXFLAGS的信息">
# <i>info gcc</i>
<comment>（选择"Invoking gcc"）</comment>
<comment>（选择"Optimize options"）</comment>
</pre>

<p>
如果变量<c>DEBUGBUILD</c>已经定义，Portage将不会去掉程序和库文件来使得调试更件简单。这个会减缓你系统速度和增加文件大小。
</p>

<pre caption="变量DEBUGBUILD">
<comment># 不要设置这个为“false”，但可以删除这一行，Portage不会</comment>
<comment># 检查这个值，它只会检查这个值是否定义</comment>
DEBUGBUILD="true"
</pre>

<p>
变量<c>MAKEOPTS</c>是给<c>make</c>使用的，用来简化一个软件包的编译。通常情况下是用来告诉<c>make</c>来并行运行几个编译（特别是你有一个多CPU系统，或者使用前面提到过的<c>distcc</c>）。
</p>

<p>
要让<c>make</c>来同时并行运行三个编译，设置变量<c>MAKEOPTS</c>为<c>-j3</c>：
</p>

<pre caption="变量MAKEOPTS">
MAKEOPTS="-j3"
</pre>

<p>
变量<c>ROOT</c>不应该在<path>/etc/make.conf</path>中设置，而是应该作为一个环境变量设置。Portage将会检查这个变量来确认软件包应该装在哪里。当然，这个默认为<path>/</path>。作为一个例子，我们给你展示一下怎样将<c>gnumeric</c>安装在<path>/mnt/gentoo</path>而不是你的当前系统：
</p>

<pre caption="变量ROOT">
# <i>ROOT="/mnt/gentoo" emerge gnumeric</i>
</pre>

</body>
</subsection>
<subsection>
<title>输出的格式</title>
<body>

<p>
默认情况下，Portage在输出中使用色彩提高可读性。如果你不需要这个，你可以设置变量<c>NOCOLOR</c>为<c>true</c>：
</p>

<pre caption="变量NOCOLOR">
NOCOLOR="true"
</pre>

</body>
</subsection>
</section>
<section>
<title>资源列表</title>
<subsection>
<title>手册</title>
<body>

<p>
如果你需要所有列出变量的快速参考，请查阅<path>make.conf</path>的手册：
</p>

<pre caption="查阅make.conf的手册">
# <i>man make.conf</i>
</pre>

</body>
</subsection>
<subsection>
<title>注释的例子</title>
<body>

<p>
文件<path>/etc/make.conf</path>包含了很多注释，其中包括了一些你可能感兴趣的样例。但是，绝大部分的人没有交互的升级<path>/etc/make.conf</path>而因此遗失了对这个文件的更新。你可以在我们的<uri link="http://www.gentoo.org/cgi-bin/viewcvs.cgi/*checkout*/portage/cnf/make.conf?rev=HEAD&amp;cvsroot=gentoo-src&amp;content-type=text/plain">在线ViewCVS仓库</uri>找到最新的<path>/etc/make.conf</path>文件。
</p>

</body>
</subsection>
</section>
</sections>
