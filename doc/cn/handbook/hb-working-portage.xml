<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet type="text/xsl" href="/xsl/guide.xsl" ?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/handbook/hb-working-portage.xml,v 1.28 2004/07/26 11:41:23 swift Exp $ -->

<sections>
<section>
<title>获取软件包的信息</title>
<subsection>
<title>所有软件的鼻祖：emerge</title>
<body>

<p>
绝大部分用户将使用的主要的Portage工具是<c>emerge</c>。在Gentoo的安装以及前一章节里我们已经使用过它，但是只是简单的解释了怎样使用而已。这一章将集中于<c>emerge</c>和教会你怎样使用<c>emerge</c>来满足你在软件方面的需求。
</p>

<p>
<c>emerge</c>是用来安装、删除、查询和维护软件包的命令。它是<c>ebuild</c>的一个前端；希望成为Gentoo专家的用户将会在后面继续学习怎样使用<c>ebuild</c>。而现在，我们将集中于<c>ebuild</c>缺少的功能（比如解决依赖性、搜索Portage树等等）来讨论<c>emerge</c>。
</p>

<p>
既然<c>emerge</c>是给Gentoo用户的最重要的工具，输入<c>man emerge</c>可以得到它的一个详细的使用手册。你也可以运行<c>emerge --help</c>来查看它自带的帮助。
</p>

<pre caption="获得emerge的帮助信息">
# <i>man emerge</i>
# <i>emerge --help</i>
</pre>

</body>
</subsection>
<subsection>
<title>Portage树</title>
<body>

<p>
在我们继续描述<c>emerge</c>之前，我们先来看看Portage树。进入<path>/usr/portage</path>，查看一下里面已有文件夹的列表。我们使用<c>ls --claasify</c>来显示一个文件夹的内容，它会在显示文件夹时带上一个尾巴“/”。
</p>

<pre caption="查看Portage树">
# <i>cd /usr/portage; ls --classify</i>
app-admin/       dev-ml/            gnome-libs/     net-print/
app-arch/        dev-perl/          gnome-office/   net-wireless/
app-benchmarks/  dev-php/           header.txt      net-www/
app-cdr/         dev-python/        incoming/       net-zope/
app-crypt/       dev-ruby/          jython/         packages/
app-dicts/       dev-tcltk/         kde-apps/       profiles/
app-doc/         dev-tex/           kde-base/       releases/
app-editors/     dev-util/          kde-i18n/       scripts/
app-emacs/       distfiles/         kde-libs/       sec-policy/
app-emulation/   eclass/            licenses/       skel.ChangeLog
app-games/       experimental/      media-fonts/    skel.ebuild
app-gnustep/     files/             media-gfx/      skel.metadata.xml
app-i18n/        fresco-base/       media-libs/     snapshots/
app-misc/        games-action/      media-plugins/  sys-apps/
app-office/      games-arcade/      media-radio/    sys-build/
app-pda/         games-board/       media-sound/    sys-cluster/
app-portage/     games-emulation/   media-tv/       sys-devel/
app-sci/         games-engines/     media-video/    sys-fs/
app-shells/      games-fps/         metadata/       sys-kernel/
app-text/        games-kids/        net-analyzer/   sys-kmods/
app-vim/         games-misc/        net-apache/     sys-libs/
app-xemacs/      games-mud/         net-dialup/     unix2tcp/
berlin-base/     games-puzzle/      net-dns/        x11-base/
dev-ada/         games-roguelike/   net-firewall/   x11-libs/
dev-cpp/         games-rpg/         net-fs/         x11-misc/
dev-db/          games-server/      net-ftp/        x11-plugins/
dev-dotnet/      games-simulation/  net-im/         x11-terms/
dev-embedded/    games-sports/      net-irc/        x11-themes/
dev-games/       games-strategy/    net-libs/       x11-wm/
dev-haskell/     games-util/        net-mail/       xfce-base/
dev-java/        glep/              net-misc/       xfce-extra/
dev-lang/        gnome-apps/        net-nds/
dev-libs/        gnome-base/        net-news/
dev-lisp/        gnome-extra/       net-p2p/
</pre>

<p>
就同你看到的，Portage树有一些子文件夹。它们中的大部分是称为<e>ebuilds</e>的Gentoo软件包所属的分类。让我们来看看，比如说<path>app-office</path>：
</p>

<pre caption="查看一个分类">
# <i>cd app-office; ls --classify</i>
abiword/     gnotime/   kmymoney2/  ooodi/              plan/     timestamp.x
dia/         gnucash/   koffice/    oooqs/              qhacc/
dia2code/    gnumeric/  lxbank/     openoffice/         sc/
facturalux/  ical/      lyx/        openoffice-bin/     scribus/
gaby/        kbudget/   mdbtools/   openoffice-ximian/  siag/
gnofin/      khacc/     mrproject/  phprojekt/          texmacs/
</pre>

<p>
在一个分类中，你会找到属于这个分类的软件包，每个软件包都有一个单独的文件夹。让我们看看<c>openoffice</c>软件包：
</p>

<pre caption="查看一个软件包">
# <i>cd openoffice; ls --classify</i>
ChangeLog  files/        openoffice-1.0.3-r1.ebuild  openoffice-1.1.0-r2.ebuild
Manifest   metadata.xml  openoffice-1.1.0-r1.ebuild  openoffice-1.1.0.ebuild
</pre>

<p>
记得前面我们说的成为一个ebuild的Gentoo软件包？在这个样例中，有四个这样的ebuilds存储在这里。它们的名字是很典型的，仅仅在版本名上不同而已。你可以随意查看这样一个软件包的内容：它们都是普通的脚本。我们现在暂时不来讨论这些，因为如果你打算只是使用Gentoo而已，这些内容不是很必要学习。
</p>

<p>
其他的文件分别是<path>ChangLog</path>（包含了ebuilds的更新列表），<path>Manifest</path>（包含这个文件夹的所有文件的checksun和文件大小）和<path>metadata.xml</path>（包含了这个软件包更多的信息，如开发负责小组，被称为<e>herd</e>，和更详细的描述信息）。
</p>

<p>
在文件夹<path>files</path>里，你会找到一些Portage需要的额外的文件：digests（该软件包某一版本需要的文件的checksum和许可），补丁和一些配置文件样例等等。
</p>

<pre caption="查看额外的文件">
# <i>cd files; ls --classify</i>
1.0.3/  digest-openoffice-1.0.3-r1  digest-openoffice-1.1.0-r1
1.1.0/  digest-openoffice-1.1.0     digest-openoffice-1.1.0-r2
# <i>cd 1.1.0; ls --classify</i>
fixed-gcc.patch      ooffice-wrapper-1.3
newstlportfix.patch  openoffice-1.1.0-linux-2.6-fix.patch
no-mozab.patch       openoffice-1.1.0-sparc64-fix.patch
nptl.patch
</pre>

<p>
如果你回到Portage树的根目录（<path>/usr/portage</path>），你会注意到那里还有其他一些非分类的文件夹。我们在这一章的后面将会讨论到这些。
</p>

</body>
</subsection>
<subsection>
<title>搜索一个软件包</title>
<body>

<p>
如果你是Linux或者Gentoo的新用户，你可能想知道什么工具适合你的工作。为方便搜索，<c>emerge</c>给你提供了一个搜索你系统已有软件包的方法。这里有两种方法你可以用来搜索软件包：使用<e>软件名称</e>或者使用<e>软件名称</e>和<e>软件描述</e>。
</p>

<p>
使用<c>emerge search</c>来通过软件名称来搜索Portage树。举例说，要找到更多关于<c>mozilla</c>的信息：
</p>

<pre caption="显示有关mozilla的信息">
# <i>emerge search mozilla</i>
Searching...   
[ Results for search key : mozilla ]
[ Applications found : 5 ]
<comment>（为方便阅读，一些输出被删减）</comment>
*  net-www/mozilla
      Latest version available: 1.5-r1
      Latest version installed: 1.4-r3
      Size of downloaded files: 29,153 kB
      Homepage:    http://www.mozilla.org
      Description: The Mozilla Web Browser

*  net-www/mozilla-firebird
      Latest version available: 0.7
      Latest version installed: [ Not Installed ]
      Size of downloaded files: 37,850 kB
      Homepage:    http://www.mozilla.org/projects/firebird/
      Description: The Mozilla Firebird Web Browser
<comment>(...)</comment>
</pre>

<p>
如果你搜索时也在软件描述中搜索，使用参数<c>--searchdesc</c>：
</p>

<pre caption="在软件名称和描述中搜索">
# <i>emerge --searchdesc mozilla</i>
Searching...   
[ Results for search key : mozilla ]
[ Applications found : 10 ]
<comment>(Some output removed to improve readability)</comment>
*  dev-libs/nss-3.8
      Latest version available: 3.8
      Latest version installed: 3.8
      Size of downloaded files:  2,782 kB
      Homepage:    http://www.mozilla.org/projects/security/pki/nss/
      Description: Mozilla's Netscape Security Services Library that implements PKI support
</pre>

<p>
就同你能看到的，<c>emerge</c>的输出告诉你这个软件包的分类和名称、已有的版本、目前安装的版本、下载文件的大小、主页和一些简短的描述。
</p>

<p>
你是不是已经看到什么新的内容？对，就是<e>下载的文件</e>。你告诉Portage去安装一个软件包时，它当然需要有一些源代码（或者预编译软件包）。因此，它会检查<path>/usr/portage/distfiles</path>（用于存储源代码）或者<path>/usr/portage/packages/All</path>（用于存储预编译软件包）的内容，看是否需要的文件都在。如果不是，它将会下载需要的文件，并把他们放在这些文件夹里。
</p>

<!--
<note>
Searching the Portage Tree, especially when using <c>- -searchdesc</c>, is very
time consuming. There are other, best performing tools available. We will
describe those in the chapter on <uri link="?part=2&amp;chap=7">Gentoolkit and
Other Tools</uri>.
</note>
-->

</body>
</subsection>
<subsection>
<title>查看ChangeLog</title>
<body>

<p>
在查看Portage树的内容时，你会发现每一个软件包都有一个ChangeLog。你也可以使用<c>emerge</c>来查看安装的版本与已有版本之间的ChangeLog记录。只需要使用<c>--pretend --changelog</c>（可缩写为<c>-pl</c>）选项即可。做为一个例子，我们来看看<c>gnumeric</c>的ChangeLog记录：
</p>

<pre caption="查看gnumeric的ChangeLog记录">
# <i>emerge --pretend --changelog gnumeric</i>
<comment>（为方便阅读，一些输出被删减）</comment>
*gnumeric-1.2.2

  27 Nov 2003; foser &lt;foser@gentoo.org&gt; gnumeric-1.2.2.ebuild :
  New release, requested in #34492
  updated deps

  12 Nov 2003; Jason Wever &lt;weeve@gentoo.org&gt; gnumeric-1.2.0.ebuild:
  Marked stable on sparc, fixes bug #32405.

  14 Oct 2003; Jason Wever &lt;weeve@gentoo.org&gt; gnumeric-1.0.8.ebuild:
  Added ~sparc keyword.  Fixes bug #31150.
</pre>

</body>
</subsection>
</section>
<section>
<title>更新Portage</title>
<subsection>
<title>简介</title>
<body>

<p>
在Portage搜索是很好的，但是如果你不有规律的更新你的Portage树，你将会停滞在你系统的软件包已有的版本中。这就意味着，你的系统很快就落伍了，你还会错失一些bug修正和可能的安全问题的补救。
</p>

<p>
这里有几种方法来更新你的Portage树。最常用的方法是使用我们的<uri link="/main/en/mirrors.xml">镜像列表</uri>。另外一种方法是使用一个Portage快照（在一个防火墙或者网络不同禁止了rsync服务器的使用的情况下）。
</p>

</body>
</subsection>
<subsection>
<title>选择给rsync使用的一个镜像</title>
<body>

<p>
我们建议你首先选择离你近的一个快速<uri link="/main/en/mirrors.xml">镜像</uri>。你可以手动（设置<path>/etc/make.conf</path>里的<c>SYNC</c>变量)或者使用<c>mirrorselect</c>来自动完成这个。因为在后面我们还要讨论到变量<c>SYNC</c>，这里我们先集中讨论<c>mirrorselect</c>的使用。首先通过emerge这个软件包来安装<c>mirrorselect</c>：
</p>

<pre caption="安装mirrorselect">
# <i>emerge --usepkg mirrorselect</i>
</pre>

<p>
现在运行<c>mirrorselect</c>来自动给你选择镜像（它也会使用给源代码使用的镜像来安装Portage）：
</p>

<pre caption="运行mirrorselect">
# <i>mirrorselect -a -s3</i>
</pre>

</body>
</subsection>
<subsection>
<title>更新Portage</title>
<body>

<p>
使用rsync来更新Portage，只需要简单的运行<c>emerge sync</c>：
</p>

<pre caption="使用emerge sync来更新Portage">
# <i>emerge sync</i>
</pre>

<p>
如果这个失败了（由于网络问题或者防火墙），你可以尝试使用<c>emerge-webrsync</c>，这个将会使用<c>wget</c>来下载一个Portage树的快照。这也意味着如果需要你可以使用代理。我们在Gentoo安装中已经讲过怎样设置系统来使用防火墙。
</p>

<pre caption="使用emerge-webrsync来更新Portage">
# <i>emerge-webrsync</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>维护软件包</title>
<subsection>
<title>编译还是预编译？</title>
<body>

<p>
Gentoo提供了可以供你使用的Gentoo软件包ebuilds。但是当你要安装这样的一个ebuild时，你可以选择<e>编译</e>这个软件包和使用一个<e>预编译</e>的软件包。但是，这两种方法有什么有点和缺点呢？它们是否可以依次使用呢？
</p>

<p>
就同你可能已经猜到的，编译软件包需要很长的时间（特别是你的硬件资源较小或者要编译一个大的软件包，如<uri link="http://www.kde.org">KDE</uri>、<uri link="http://www.openoffice.org">OpenOffice.org</uri>等等）。编译软件包时，你可以使用<c>USE</c>设置来将这个软件融合到你的系统中。当然，你可以设置高级别的优化选项（在变量<c>CFLAGS</c>和<c>CXXFLAGS</c>）来编译这些软件。
</p>

<p>
使用预编译软件包可以减少安装时间（因为不需要编译），但是你会失去使用<c>USE</c>设置和变量<c>CFLAGS</c>和<c>CXXFLAGS</c>的优点。
</p>

<p>
前面已说过，预编译的软件包存储在文件夹<path>/usr/portage/packages/All</path>里，而软件的源代码存储在<path>/usr/portage/distfiles</path>文件夹里。如果你完成安装一个软件包，你可以从相应的文件夹里删掉这个软件包或者源代码。但是，你可能需要保留软件包/源代码的最新版本，以防你要重新安装这些软件（这样你就不需重新下载）。
</p>

</body>
</subsection>
<subsection>
<title>从源代码安装软件</title>
<body>

<p>
好的，我们已经说的够多了，我们来做做看。安装一个软件包，你需要使用<c>emerge</c>命令。如果你不要使用任何预编译软件包，你只需要使用<c>emerge &lt;package-name&gt;</c>或者<c>emerge &lt;category&gt;/&lt;package-name&gt;</c>。作为一个例子，我们将安装<c>gnumeric</c>：
</p>

<pre caption="编译gnumeric">
# <i>emerge gnumeric</i>
</pre>

<p>
这会为你下载所需的源代码并且解压缩，编译和安装这个软件包到你的系统中。它也会对所有的依赖性软件包作同样的事情。如果你要查看这个软件包将安装的依赖性软件，使用选项<c>--pretend</c>（简称<c>-p</c>）：
</p>

<pre caption="假装要编译gnumeric">
# <i>emerge --pretend gnumeric</i>
</pre>

<p>
如果你要下载这个软件的源代码和它的依赖性软件，但是不去编译这个软件包，使用选项<c>--fetchonly</c>（简称<c>-f</c>）：
</p>

<pre caption="获得gnumeric的源代码">
# <i>emerge --fetchonly gnumeric</i>
</pre>

<p>
如果你要查看<c>emerge</c>要从哪里下这这些源代码，组合使用选项<c>--fectchonly</c>和<c>--pretend</c>：
</p>

<pre caption="查看gnumuric所需源代码的网址">
# <i>emerge --fetchonly --pretend gnumeric</i>
</pre>

<p>
你也可以安装一个软件的特定版本。比如说，由于某个缘由，你要安装一个版本低于1.2的gnumeric，你可以输入：
</p>

<pre caption="安装特定版本的gnumeric">
# <i>emerge "&lt;gnumeric-1.2"</i>
</pre>

<p>
当然还可能是“&gt;”（更新版本）和“=”（准确的版本）。
</p>

</body>
</subsection>
<subsection>
<title>安装预编译的软件包</title>
<body>

<p>
当你要安装一个预编译的软件包时，你应该使用<c>--usepkg</c>选项（简称<c>-k</c>）。如果在<path>/usr/portage/packages/All</path>有符合版本的该软件的二进制包时，它将会使用这些二进制包。
</p>

<pre caption="安装gnumeric的预编译软件包">
# <i>emerge --usepkg gnumeric</i>
</pre>

<p>
如果你只使用二进制包，甚至这个版本不符合也如此，使用选项<c>--usepkgonly</c>（简称<c>-K</c>）。
</p>

<pre caption="安装gnumerick的预编译软件包">
# <i>emerge --usepkgonly gnumeric</i>
</pre>

<p>
如果你的系统还没有这些预编译软件包，你可以让<c>emerge</c>从一个镜像中下载。这个镜像地址是在<path>/etc/make.conf</path>里的变量<c>PORTAGE_BINHOST</c>声明的。
</p>

<p>
使用<c>--getbinpkg</c>（简称<c>-g</c>）来下载二进制包，以防这个软件的二进制包并不在你的系统里存在：
</p>

<pre caption="下载和安装gnumeric的预编译软件包">
# <i>emerge --getbinpkg gnumeric</i>
</pre>

<p>
这将会为你下载这个软件包和软件相关的信息，并将这个软件和它的依赖性安装在你的系统里。如果你要查看这个软件包安装时将会安装的依赖性软件包，使用选项<c>--pretend</c>（简称<c>-p</c>）：
</p>

<pre caption="假装下载gnumeric余姚的预编译包">
# <i>emerge --getbinpkg --pretend gnumeric</i>
</pre>

<p>
你也可以下载预编译包（以及软件包相关的信息）时，<e>不</e>检查你的本地系统的信息，<e>不</e>使用你系统上已有的预编译包（如果适合），那么你需要使用选项<c>--getbinpkgonly</c>（简称<c>-G</c>）：
</p>

<pre caption="不使用本地信息来安装一个预编译软件包">
# <i>emerge --getbinpkgonly gnumeric</i>
</pre>

<p>
你也可以安装一个软件包的特定版本。比如说，由于某个原因，你要安装一个版本低于1.2的gnumeric，你可以输入：
</p>

<pre caption="安装特定版本的gnumeric">
# <i>emerge --usepkg "&lt;gnumeric-1.2"</i>
</pre>

<p>
当然还可能是“&gt;”（更新版本）和“=”（准确的版本）。
</p>


</body>
</subsection>
<subsection>
<title>与依赖性打交道</title>
<body>

<p>
Portage对于依赖性处理上有一个扩展的支持。虽然你通常甚至并不需要考虑这个（因为Portage可以自动处理依赖性），一些用户还是想知道怎样和<c>emerge</c>以及依赖性一起工作。
</p>

<p>
比如说，如果你要Portage假装一个软件包的依赖性都没有安装，你可以使用<c>--emptytree</c>（简称<c>-e</c>）。这个和<c>--pretend</c>一起工作时很有用，将会显示任何一个软件包的完整的依赖性树。如果没有选项<c>--pretend</c>，<c>emerge</c>将会（重新）编译所有列出的软件包。
</p>

<pre caption="显示gnumeric所有的依赖性">
# <i>emerge --emptytree --pretend gnumeric</i>
</pre>

<p>
另外一个参数是<c>--nodeps</c>，这个将会要求Portage安装给定的软件包时不用考虑任何依赖性。显然这个将会导致编译失败。
</p>

<pre caption="不考虑依赖性安装gnumeric">
# <i>emerge --nodeps gnumeric</i>
</pre>

<p>
和<c>--nodeps</c>相反的是<c>--onlydeps</c>，这个将让Portage安装给定软件包的所有依赖性软件，但是不包括这个软件包本身：
</p>

<pre caption="安装gnumeric的依赖性">
# <i>emerge --onlydeps gnumeric</i>
</pre>

</body>
</subsection>
<subsection>
<title>更新你的系统</title>
<body>

<p>
Portage有两个表示一系列软件包的标签：<e>system</e>和<e>world</e>。在前面Gentoo的安装过程中如果你没有使用<e>stage3</e>的话，你应该已经看到前者了。我们再来回忆一下：<e>system</e>是一个可以使用的Gentoo系统所需要的一系列的<e>核心</e>软件包。
</p>

<p>
标签<e>world</e>包含了你在你的系统上安装的所有的软件和<e>system</e>信息。换句话说，每次你使用<c>emerge &lt;package-name&gt;</c>安装一个软件包时，这个<c>&lt;package-name&gt;</c>就会在文件<e>world</e>（<path>/var/cache/edb/world</path>）里注册。依赖性<e>不是</e>文件<e>world</e>的一部分，这个我们将稍后再讨论。
</p>

<p>
如果你要更新系统软件包，使用选项<c>--update</c>（简称<c>-u</c>）：
</p>

<pre caption="更新系统软件包">
# <i>emerge --update system</i>
</pre>

<p>
world软件包的更新可以使用一种典型的方法：
</p>

<pre caption="更新整个系统">
# <i>emerge --update world</i>
</pre>

<p>
同样，如果你想知道<c>emerge</c>要更新什么，组合使用选项<c>--pretend</c>和<c>--update</c>：
</p>

<pre caption="假装要更新整个系统">
# <i>emerge --pretend --update world</i>
<comment>（为方便阅读，一些输出被删减）</comment>
[ebuild     U ] net-misc/wget-1.9-r1 [1.9] 
[ebuild     UD] media-video/dvdauthor-0.5.0 [0.5.3] 
[ebuild     U ] net-analyzer/ethereal-0.9.16 [0.9.14] 
</pre>

<p>
在单词“world”紧随其后你会注意到有一个字母（或者几个字母的组合），它们将告诉你这个软件包更多的信息：
</p>

<ul>
  <li>
    <e>B</e> (blocks)左边列出的软件包阻止在右边列出软件包的安装
  </li>
  <li>
    <e>N</e> (new)在你的系统中，这个软件包是新的，将会第一次安装
  </li>
  <li>
    <e>R</e> (reemerge)这个软件包不是新的，但是需要重新安装
  </li>
  <li>
    <e>F</e> (fetch)这个软件包需要你手动下载源代码（比如由于版权问题）
  </li>
  <li>
    <e>U</e> (update)这个软件包在你的系统中已有，但是需要升级
  </li>
  <li>
    <e>UD</e> (downgrade)这个软件包在你的系统中已有，但是需要降级
  </li>
  <li>
    <e>U-</e> (slot warning)在你系统安装的这个软件包被现是为不能和其他版本共存，但是升级后可以。新的版本将会安装，而旧版将会被删除。
  </li>
</ul>

<p>
在一些情况下，一次更新可能是一次降级（比如说用一个旧的版本替代一个新的版本）。如果你不想这个发生，使用选项<c>--updateonly</c>（简称<c>-U</c>）：
</p>

<pre caption="升级你整个系统">
# <i>emerge --update --upgradeonly world</i>
</pre>

<p>
我们前面提过文件<e>world</e>并不包括依赖性。当你运行<c>emerge --update</c>仅仅是文件<e>world</e>里提到的软件包和它的很近的依赖性软件包被检查到，必要时进行升级。如果你要<c>emerge</c>检查<e>所有的</e>依赖性（包含依赖性的依赖性），添加参数<c>--deep</c>：
</p>

<pre caption="升级整个系统，包括所有的依赖性">
# <i>emerge --update --deep world</i>
</pre>

<p>
当然，我们这里讨论的是<e>system</e>和<e>world</e>，但是对于单个的软件包，你也可以同样做。
</p>

</body>
</subsection>
<subsection>
<title>删除软件</title>
<body>

<p>
如果你要从你的系统中删除软件，你可以使用选项<c>unmerge</c>（简称<c>-C</c>）：
</p>

<pre caption="删除软件">
# <i>emerge unmerge gnumeric</i>
</pre>

<p>
如果你要测试一个删除（但并不执行），你可以再次使用<c>--pretend</c>：
</p>

<pre caption="假装删除软件">
# <i>emerge --pretend unmerge gnumeric</i>
</pre>

<warn>
Portage不会检查一个软件包是否是另一个软件包的依赖性。它也不会警告你这个软件包是否是<e>system</e>的一部分，比如，你系统正常工作的一个必须的核心程序。
</warn>

<p>
一旦unmerge开始，你将会看到一个长长的该软件包所有的文件列表。这些文件名中的一些在起名字之前可能有一个参数。这些参数<c>!mtime</c>、<c>!empty</c>和<c>cfgpro</c>说明了这个软件所删除时这些文件没有被删除的原因。没有给出上述三个参数的任何一个的文件都成功的从系统中删除。这三个参数说明了如下的理由：
</p>

<ul>
  <li>
    <c>!mtime</c>：所列的文件在安装后已被改动过，可能是由你或者其他的工具所修改
  </li>
  <li>
    <c>!empty</c>：所列的文件夹非空
  </li>
  <li>
    <c>cfgpro</c>：这个文件处于一个受保护的文件夹里，为了安全不能接触
  </li>
</ul>

</body>
</subsection>
</section>
<section>
<title>已有的软件？</title>
<subsection>
<title>ARCH或者没有？</title>
<body>

<p>
Gentoo将其软件包主要分为两大类：<e>ARCH</e>和<e>~ARCH</e>。不要顾名思义：类别是基于你使用的架构。换句话说，对于基于x86的系统来说，你的分为<e>x86</e>和<e>~x86</e>；而对于ppc系统来说，你的分为<e>ppc</e>和<e>~ppc</e>等等。
</p>

<p>
<e>~ARCH</e>这一类表明这个软件包在开发者那可以工作，但并没有在社区里彻底的测试通过而放到<e>ARCH</e>里。<e>~ARCH</e>软件包通常情况下会在一段充足的时间测试无bug之后进入<e>ARCH</e>。
</p>

<p>
默认情况下你的系统将会使用<e>ARCH</e>软件包。如果你喜欢走极端，并不介意某个时候装上一个损坏的软件包，也知道怎么处理出现问题的系统，并且喜欢提交bug报告到<uri link="http://bugs.gentoo.org">bugs.gentoo.org</uri>，那你可能偏向于使用<e>~ARCH</e>软件包。让你的系统成为使用<e>~ARCH</e>的系统，编辑<path>/etc/make.conf</path>里的<c>ACCEPT_KEYWORDS</c>变量为<e>~ARCH</e>（同样对于x86系统来说：<e>~x86</e>等等）。
</p>

<p>
注意到是很难（或者说不可能）从<e>ARCH</e>转到<e>~ARCH</e>的。
</p>

<p>
如果你现在要更新你的系统，你将会注意到<e>很多</e>软件包将需要升级！
</p>

</body>
</subsection>
<subsection>
<title>被mask的软件包</title>
<body>

<p>
当你要安装一个软件包时，你可能遇到下面类似的信息：
</p>

<pre caption="被mask的软件包的信息">
Calculating dependencies   
!!! <comment>all ebuilds that could satisfy </comment>&lt;your package&gt;<comment> have been masked.</comment>
</pre>

<p>
一个软件包可以由于两种原因被mask：
</p>

<ol>
  <li>这个软件包目前处于<e>~ARCH</e>，而你使用的是<e>ARCH</e></li>
  <li>这个软件包明显被强行mask</li>
</ol>

<p>
如果软件包是由于第一个原因被mask了，而你<e>真的</e>很想安装它（也知道它没有出现在<e>ARCH</e>是有原因的），你可以接受任何软件的<e>~ARCH</e>版本，只需要添加其到你的<path>/etc/portage/package.keywords</path>文件里：
</p>

<pre caption="接受一个软件的~ARCH版本">
# <i>echo "app-office/gnumeric ~x86" &gt;&gt; /etc/portage/package.keywords</i>
# <i>emerge gnumeric</i>
</pre>

<p>
一个软件被强行mask是由于它出现在文件<path>/usr/portage/profiles/package.mask</path>里。如果你阅读了此文件，你也将会知道他被强行mask的原因（通常会以注释方式出现）。如果你还是要安装这个软件（尽管有我们已经告诉你有的各种可能的警告，如“毁坏系统”、“毁坏其他软件包”、“非常需要测试”等），创建文件<path>/etc/portage/package.unmask</path>，并将这个软件包列在其中（使用<path>/usr/portage/profiles/package.mask</path>里同样的格式）。
</p>

<p>
千万<e>不要</e>修改文件<path>/usr/portage/profiles/package.mask</path>，因为在下一次更新你的Portage树时任何修改都会被取消。如果你要强行mask一个软件包，只需要创建文件<path>/etc/portage/package.mask</path>，并将起列于其中（使用上面提到的相同的格式）。
</p>

<!--
<p>
Another trick to circumvent the "masked package" problem is to install the
package using the full path. This will ignore both the <c>ACCEPT_KEYWORD</c> 
settings and the <path>package.mask</path> listing.
</p>

<pre caption="Installing a package without checking for stadium / masking">
# <i>emerge /usr/portage/app-office/gnumeric/gnumeric-1.2.0.ebuild</i>
</pre>
-->

</body>
</subsection>
<subsection>
<title>相冲突的软件包</title>
<body>

<p>
你可能碰到在你显示屏收到如下错误的情况：
</p>

<pre caption="想冲突的软件包">
[blocks B     ] gnome-base/bonobo-activation (from pkg gnome-base/libbonobo-2.4.0) 
</pre>

<p>
在上面这个例子中，软件包<c>bonobo-activation</c>和<c>libbonobo</c>的安装冲突。为解决这个问题，删除软件包<c>bonbo-activation</c>后继续：
</p>

<pre caption="解决冲突的情况">
# <i>emerge unmerge bonobo-activation</i>
</pre>

</body>
</subsection>
</section>
</sections>
