<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sections SYSTEM "/dtd/book.dtd">

<!-- The content of this document is licensed under the CC-BY-SA license -->
<!-- See http://creativecommons.org/licenses/by-sa/1.0 -->

<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/handbook/hb-install-config.xml,v 1.33 2004/04/15 07:06:36 swift Exp $ -->

<sections>
<section>
<title>文件系统信息</title>
<subsection>
<title>fstab是什么？</title>
<body>

<p>
在Linux下，系统所要用的分区都必须列表于文件<path>/etc/fstab</path>中。这个文件包含了这些分区的挂载点（在系统目录树结构中的位置），挂载方法（特殊的选项）和挂载的时间（是否自动挂载，是否可以用户挂载等）。
etc.).
</p>

</body>
</subsection>
<subsection>
<title>创建/etc/fstab</title>
<body>

<p>
<path>/etc/fstab</path>使用一种特殊的语法格式。每行都包含七个由空白键（whitespace键、tab键或者两者的混合）分开的字段，每一个字段都有它自己的意思：
</p>

<ul>
<li>
  第一个字段给出<b>分区</b>的描述（设备文件的路径）
</li>
<li>
  第二个字段给出<b>挂载点</b>，这是分区应该挂载的地方
</li>
<li>
  第三个字段给出分区所用的<b>文件系统</b>
</li>
<li>
  第四个字段给出挂载这个分区时命令<c>mount</c>的<b>挂载选项</b>。因为每个文件系统都有自己的挂载选项，我们建议你阅读一下mount的手册（<c>man mount</c>）给出一个全面的列表。多个挂载选项用逗号隔开。
</li>
<li>
  第五个字段是给<c>dump</c>使用，用来决定这个分区是否需要<b>废弃</b>。一般情况下，你可以设定其为<c>0</c>（零）。
</li>
<li>
  第六个字段是给<c>fsck</c>使用，用来决定在系统非法关机后分区的<b>检查</b>顺序。根目录的文件系统应该设定值为<c>1</c>，而其他的设定为<c>2</c>（或者在不需要自检的情况下设为<c>0</c>）
</li>
</ul>

<p>
就这样用<c>nano</c>（或者你喜欢的编辑器）来创建你的<path>/etc/fstab</path>：
</p>

<pre caption="打开/etc/fstab">
# <i>nano -w /etc/fstab</i>
</pre>

<p>
让我们来看看我们给<path>/boot</path>分区怎样写挂载选项。这只是一个例子，因此如果你的机器的架构不需要一个<path>/boot</path>分区（如<b>PPC</b>），不要复制过去。
</p>

<p>
在我们默认的x86架构的分区例子中，<path>/boot</path>是<path>/dev/hda1</path>分区，使用<c>ext2</c>文件系统。这个分区不应自动挂载（<c>noauto</c>），但是必须自检。因此我们这样写：
</p>

<pre caption="/etc/fstab中/boot行的一个例子">
/dev/hda1   /boot     ext2    noauto        1 2
</pre>

<p>
现在，为了改进性能，大部分用户会添加一个<c>noatime</c>挂载选项，这个由于不更新分区的存取时间（一般来说你并不需要它）而致使系统更快：
Now, to improve performance, most users would want to add the <c>noatime</c>
option as mountoption, which results in a faster system since access times
aren't registered (you don't need those generally anyway):
</p>

<pre caption="/etc/fstab中/boot行改进的一个例子">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
</pre>

<p>
如果我们继续，我们将添加下面三行来结束（给<path>/boot</path>、<path>/</path>和交换分区）：
</p>

<pre caption="/etc/fstab中的三行">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
/dev/hda2   none      swap    sw                0 0
/dev/hda3   /         ext3    noatime           0 1
</pre>

<p>
为完成这个，你还应该给<path>/proc</path>、<c>tmpfs</c>（必须）和你的光驱（当然，如果你有其他的分区或驱动器，也可加上）添加一些挂载选项：
</p>

<pre caption="/etc/fstab的一个完整例子">
/dev/hda1   /boot     ext2    noauto,noatime    1 2
/dev/hda2   none      swap    sw                0 0
/dev/hda3   /         ext3    noatime           0 1

none        /proc     proc    defaults          0 0
none        /dev/shm  tmpfs   defaults          0 0

/dev/cdroms/cdrom0    /mnt/cdrom    auto      noauto,user    0 0
</pre>

<p>
<c>auto</c>使得<c>mount</c>自动检测文件系统（对于可卸载的设备推荐使用，因为它们可以有不同的文件系统），<c>user</c>使得非超级用户可以使用CD驱动器。
</p>

<p>
现在就用上面的这个例子创建你的<path>/etc/fstab</path>。如果你是一个<b>SPARC</b>用户，你还应该添加下面一行当你的<path>/etc/fstab</path>：
</p>

<pre caption="添加openprom文件系统到/etc/fstab">
none        /proc/openprom  openpromfs    defaults      0 0
</pre>

<p>
如果你需要<c>usbfs</c>，添加下面一行到<path>/etc/fstab</path>：
</p>

<pre caption="添加usbfs文件系统到/etc/fstab">
none        /proc/bus/usb   usbfs         defaults      0 0
</pre>

<p>
重新看一下你的<path>/etc/fstab</path>，保存并退出，继续我们的安装。
</p>

</body>
</subsection>
</section>
<section>
<title>网络信息</title>
<subsection>
<title>主机名、域名等</title>
<body>

<p>
用户的一个选择就是给他（她）的机器命名。这看起来很简单，但是<e>很多</e>的用户却有困难为它们的Linux机器找到一个很好的名字。为加快这个进度，你应该知道不管什么名字到以后都可以重新修改的。一般来说，你可以称你的机器为<c>tux</c>，域名为<c>homenetwork</c>。
</p>

<p>
我们在下一个例子中将会用到这些值。首先我们设定主机名：
</p>

<pre caption="设定主机名">
# <i>echo tux &gt; /etc/hostname</i>
</pre>

<p>
接着我们来设定域名：
</p>

<pre caption="设定域名">
# <i>echo homenetwork &gt; /etc/dnsdomainname</i>
</pre>

<p>
如果你有一个NIS域（如果你不知道这是什么，那你就没有），你也需要定义一个：
</p>

<pre caption="设定NIS域名">
# <i>echo nis.homenetwork &gt; /etc/nisdomainname</i>
</pre>

<p>
现在添加<c>domainname</c>脚本到默认运行级别：
</p>

<pre caption="添加domainname到默认运行级别">
# <i>rc-update add domainname default</i>
</pre>

</body>
</subsection>
<subsection>
<title>配置你的网络</title>
<body>

<p>
在准备说“嘿，我们已经有了”之前，你应该记住在gentoo安装初期设置好网络也是为了安装。现在你将准备为你的Gentoo系统永久的配置好网络。
</p>

<p>
所有的网络信息可以在<path>/etc/conf.d/net</path>里收集到。这个文件使用直接但并对不知怎么手动配置网络的用户并不直观的语法。但是不用怕，我们将一一解释:)
</p>

<p>
首先用你喜欢的编辑器（这里以<c>nano</c>为例）打开文件<path>/etc/conf.d/net</path>：
</p>

<pre caption="打开/etc/conf.d/net准备编辑">
# <i>nano -w /etc/conf.d/net</i>
</pre>

<p>
你找到的第一个变量是<c>iface_eth0</c>，它使用如下语法：
</p>

<pre caption="iface_eth0语法">
iface_eth0="<i>&lt;your ip address&gt;</i> broadcast <i>&lt;your broadcast address&gt;</i> netmask <i>&lt;your netmask&gt;</i>"
</pre>

<p>
如果你使用DHCP（自动获取IP），你应该设定<c>iface_eth0</c>为<c>dhcp</c>。如果你使用rp-pppoe（如用作ADSL拨号），设定其为<c>up</c>。如果你需要手动设置网络，而又对上述名词不熟悉，在没有完成这些之前请先阅读<uri link="?part=1&amp;chap=3#doc_chap4_sect3">理解网络名词</uri>。
</p>

<p>
这样我们给出三个例子；第一个例子使用DHCP，第二个使用静态IP（192.168.0.2）和网络掩码为255.255.255.0，broadcast为192.168.0.255和网关为192.168.0.1，第三个只是激活给rp-pppoe使用的接口：
</p>

<pre caption="/etc/conf.d/net的例子">
<comment>（对于DHCP）</comment>
iface_eth0="dhcp"

<comment>（对于静态IP）</comment>
iface_eth0="192.168.0.2 broadcast 192.168.0.255 netmask 255.255.255.0"
gateway="eth0/192.168.0.1"

<comment>（对于rp-pppoe）</comment>
iface_eth0="up"
</pre>

<p>
如果你有几个网络接口，创建额外的<c>iface_eth</c>变量，就像<c>iface_eth1</c>、<c>iface_eth2</c>等。变量<c>gateway</c>不需要重新设定，因为每台电脑只能使用一个网关。
</p>

<p>
现在可以保存配置并退出，以继续下面的安装和配置。
</p>

</body>
</subsection>
<subsection>
<title>在启动时自动启用网络</title>
<body>

<p>
为在启动时激活网络接口，你必须添加这些到默认的运行级别。如果你有PCMCIA接口，你应该跳过这块儿，因为PCMCIA接口是由PCMCIA启动脚本启动。
</p>

<pre caption="添加net.eth0到默认的运行级别">
# <i>rc-update add net.eth0 default</i>
</pre>

<p>
如果你有几个网络接口，你需要为它们准确的创建<path>net.eth1</path>、<path>net.eth2</path>等启动脚本。你可以使用<c>ln</c>来做这个：
</p>

<pre caption="创建额外的启动脚本">
# <i>cd /etc/init.d</i>
# <i>ln -s net.eth0 net.eth1</i>
# <i>rc-update add net.eth1 default</i>
</pre>

</body>
</subsection>
<subsection>
<title>写下网络信息</title>
<body>

<p>
现在你需要告诉Linux有关你的网络。这个在<path>/etc/hosts</path>里定义并帮助将无法被你的域名解析服务器解析的主机名解析出IP地址。打比方说，如果你的内网由三台PC机组成：<c>jenny</c>（192.168.0.5）、<c>benny</c>（192.168.0.6）和<c>tux</c>（192.168.0.7，你的机器），你可以打开文件<path>/etc/hosts</path>并填入下列值：
</p>

<pre caption="打开/etc/hosts">
# <i>nano -w /etc/hosts</i>
</pre>

<pre caption="填入网络信息">
127.0.0.1     localhost
192.168.0.5   jenny.homenetwork jenny
192.168.0.6   benny.homenetwork benny
192.168.0.7   tux.homenetwork tux
</pre>

<p>
如果你的机器是单独的（或者域名解析服务器可以处理所有的域名解析），一行就足够了：
</p>

<pre caption="单机或者全解析的机器的/etc/hosts">
127.0.0.1     localhost
</pre>

<p>
保存并退出编辑器，继续下面的过程。
</p>

<p>
如果你没有PCMCIA，你可以从<uri link="#doc_chap3">系统信息</uri>继续。对于PCMCIA用户，应该读读下面有关PCMCIA的信息。
</p>

</body>
</subsection>
<subsection>
<title>可选：启用PCMCIA</title>
<body>

<note>
pcmcia-cs之存在于x86、amd64和ppc平台。
</note>

<p>
PCMCIA用户首先应该安装<c>pcmcia-cs</c>软件包。为避免这个时候装上XFree86，参数<c>USE="-X"</c>是必须的：
</p>

<pre caption="安装pcmcia-cs">
# <i>USE="-X" emerge pcmcia-cs</i>
</pre>

<p>
当<c>pcmcia-cs</c>装上后，添加<c>pcmcia</c>到<e>默认</e>的运行级别：
</p>

<pre caption="添加pcmcia到默认的运行级别">
# <i>rc-update add pcmcia default</i>
</pre>

</body>
</subsection>
</section>
<section>
<title>系统信息</title>
<body>

<p>
Gentoo使用<path>/etc/rc.conf</path>作为通用的系统范围的配置。打开<path>/etc/rc.conf</path>，然后好好看看这个文件里的注解:)
</p>

<pre caption="打开/etc/rc.conf">
# <i>nano -w /etc/rc.conf</i>
</pre>

<p>
就同你看到的，这个文件注解很丰富，可以帮助你设定必须的配置变量。对<c>KEYMAP</c>设定要特别注意：如果你选择错误的<c>KEYMAP</c>，你将会对你的键盘输入得到的结果很奇怪。
</p>

<note>
基于USB的<b>SPARC</b>系统和<b>SPARC</b>克隆机的用户可能需要选择一个i386的键盘布局（如“us”）来代替“sunkeymap”。
</note>

<p>
<b>PPC</b>在大部分系统上使用x86的键盘布局。需要在启动时使用ADB键盘布局的用户必须在内核中启用ADB keycode sendings，并在<path>rc.conf</path>设定一个mac/ppc键盘布局。
</p>

<p>
我们完成配置<path>/etc/rc.conf</path>后，保存并退出，然后从<uri link="?part=1&amp;chap=9">配置启动程序</uri>继续。
</p>

</body>
</section>
</sections>
