<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/guide.xsl" ?>
<!-- $Header: /var/www/www.gentoo.org/raw_cvs/gentoo/xml/htdocs/doc/en/dri-howto.xml,v 1.13 2004/04/11 10:52:16 cam Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/en/dri-howto.xml">
<title>硬件3D加速指南</title>
<author title="Author">
  <mail link="spyderous@gentoo.org">Donnie Berkholz</mail>
</author>
<author title="Editor">
  <mail link="peesh@gentoo.org">Jorge Paulo</mail>
</author>
<author title="Translator">
  <mail link="dragonnapalm@163.com">dragonnapalm</mail>
</author>

<abstract>
本指南描述了如何在Gentoo Linux的XFree86中使用XFree-DRM以获得3D加速。
</abstract>

<license/>

<version>1.0.2</version>
<date>December 20 2003</date>

<chapter>
<title>前言</title>
<section>
<title>什么是硬件3D加速？我为什么需要使用它？</title>
<body>

<p>
硬件3D加速可以允许你使用显示卡上的图形处理器来处理三维图形渲染而不需要占用宝贵的CPU资源。
作为“软件加速”的反面，它也被称作“硬件加速”。在没有硬件3D加速的情况下，CPU自身会被强制使用
Mesa软件渲染函数库来进行贴图处理，这会占用相当多的CPU资源。虽然XFree86一般都支持2D硬件加速，
但它却常常缺乏硬件3D加速功能。而对于某些需要进行3D渲染的工作（比如3D CAD和三维建模），三维硬件
加速将会显得非常重要。
</p>

</body>
</section>
<section>
<title>我如何才能使用硬件3D加速？</title>
<body>

<p>
在大多数情况下,你可以选择二进制编码驱动程序或者开放源代码驱动程序。由于我们使用的操作系统是Linux
并且开放源代码是Linux的基本准则，因此我们推荐你使用开放源代码的驱动程序。但有时二进制编码驱动程序
也许是你唯一的选择――比如对于nVidia显示卡。二进制编码驱动程序包含了适用于nVidia显示卡的
media-video/nvidia-kernel以及media-video/nvidia-glx、适用于Matrox显示卡的media-video/mgavideo，
以及适用于ATI显示卡的media-video/ati-drivers。而开放源代码的驱动程序则包含了适用于
KyroII的media-video/kyro-kernel以及适用于ATI显示卡的media-video/ati-gatos，后者为
ATI显示卡提供了更为全面的视频功能的支持。
</p>

</body>
</section>
<section>
<title>什么是 DRI?</title>
<body>

<p>
Direct Rendering Infrastructure (<uri 
link="http://dri.sourceforge.net">dri.sourceforge.net</uri>)，也就是所说的DRI，
是一个允许应用程序以高效安全的方式直接访问图形处理硬件的框架控制系统。它包含了对X
服务器、一些客户端函数库以及系统内核的某些修改。DRI最主要的用处是实现OpenGL的快速高效执行。
</p>

</body>
</section>
<section>
<title>什么是XFree-DRM？它是如何与普通的XFree86进行关联的？</title>
<body>

<p>
XFree-DRM是一套为XFree86提供<e>增强</e>性能的组件，它通过为直接渲染添加必要的内核模块
来为你的显示卡提供3D加速。
</p>

</body>
</section>
<section>
<title>目的</title>
<body>

<p>
本指南是为那些无法在XFree中使用DRI的用户准备的。XFree-DRM适用于3dfx, gamma,
i8x0, matrox, rage128, radeon, mach64（从xfree-drm-4.3.0-r7开始支持）以及
sis300系列驱动程序。由于2.4系统内核的直接渲染管理器（DRM）不再支持XFree 4.3，
因此你需要安装xfree-drm软件包，不过，2.6系统内核可以支持XFree 4.3。但是Gentoo的
XFree-DRM软件包尚无法在2.6系统内核中工作。请参看<uri 
link="http://dri.sourceforge.net">DRI 主页</uri>以获得更多信息。
</p>

</body>
</section>
<section>
<title>意见反馈</title>
<body>

<p>
如果你有任何建议或者疑问，请将E-mail发送到这里： <mail 
link="spyderous@gentoo.org">Donnie Berkholz</mail>.
</p>

</body>
</section>
</chapter>

<chapter>
<title>安装XFree86并配置你的系统内核</title>
<section>
<title>安装 XFree86</title>
<body>

<pre caption="安装 XFree86">
# <i>emerge x11-base/xfree</i>
</pre>

</body>
</section>
<section>
<title>配置你的系统内核</title>
<body>

<p>
检测你的芯片组并且打开相应的内核支持。
</p>

<pre caption="检查你所使用的AGP芯片组">
# <i>emerge pciutils; lspci | grep AGP</i>
# <i>00:01.0 PCI bridge: Intel Corp. 440BX/ZX/DX - 82443BX/ZX/DX AGP bridge (rev 03)</i>
<codenote>以上的输出结果会因为不同的硬件而有所差异。</codenote>
</pre>

<p>
在大多数情况下，系统内核应该含有以下的选项。以下是在使用gentoo-sources-2.4.20-r5的情况下进行配置的：
</p>

<pre caption="配置内核">
# <i>ls -l /usr/src/linux </i>
lrwxrwxrwx    1 root     root           22 May 29 18:20 /usr/src/linux -> linux-2.4.20-gentoo-r5
<codenote>请确保 /usr/src/linux 已经指向当前内核.</codenote>
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<pre caption="make menuconfig 选项">
Processor type and features ---&gt;
&lt;*&gt; MTRR (Memory Type Range Register) support
Character devices ---&gt;
&lt;M&gt; /dev/agpgart (AGP Support)
[*] Intel 440LX/BX/GX and I815/I820/I830M/I830MP/I840/I845/I850/I860 support
<codenote>请为你自己所使用的芯片组打开相应的内核支持</codenote>
[ ] Direct Rendering Manager (XFree86 DRI support)
</pre>

<p>
请确保Direct Rendering Manager (DRM，直接渲染管理器)已经处于<e>关闭状态</e>。
XFree-DRM软件包将会提供它所附带的直接渲染管理器。2.4版本的系统内核可以支持 XFree 4.2。
</p>

</body>
</section>
<section>
<title>编译并安装你的系统内核</title>
<body>

<pre caption="编译并安装你的系统内核">
# <i>make dep &amp;&amp; make clean bzImage modules modules_install</i>
# <i>mount /boot</i>
# <i>cp arch/i386/boot/bzImage /boot</i>
</pre>

<p>
如果你想让你的新内核使用一个bzImage以外的其他名称，请将它复制到/boot/yourname 。
当然，不要忘记修改grub.conf和lilo.conf，如果你使用的是LILO，你还需要运行/sbin/lilo 。
</p>

</body>
</section>
</chapter>

<chapter>
<title>安装 XFree-DRM 并配置直接渲染</title>
<section>
<title>安装 XFree-DRM</title>
<body>

<pre caption="安装 XFree-DRM">
# <i>ACCEPT_KEYWORDS="~x86" emerge xfree-drm</i>
</pre>

</body>
</section>
<section>
<title>配置 XF86Config</title>
<body>

<p>
用你喜欢的编辑器打开<path>/etc/X11/XF86Config</path>，然后编辑这个文件以让它启用DRI和GLX。
</p>

<pre caption="XF86Config">
...
Section "Module"
  Load "dri"
  Load "glx"
  ...
EndSection
...
Section "Device"
  Driver "radeon"
  ...
EndSection
...
Section "dri"
  Mode 0666
EndSection
</pre>

<p>
如果你正在使用其它显示卡，请将"radeon"替换为你自己的驱动程序名称。
</p>

</body>
</section>
</chapter>

<chapter>
<title>测试3D加速</title>
<section>
<title>用你的新内核启动系统</title>
<body>

<p>
用你的新内核启动系统。现在你可以看看直接渲染是否已经开启并且体验它为你的系统所带来的改善。
</p>

<pre caption="测试渲染功能">
# <i>startx</i>
<codenote>如果agpgart已经被编译为模块，你则不必为你的驱动程序或者agpgart加载模块，</codenote>
<codenote>它们会被自动加载。</codenote>
# <i>glxinfo | grep rendering</i>
direct rendering: Yes
<codenote>如果你得到的提示是"No," 说明你的3D加速没有被打开或者你的显示卡不支持3D加速.</codenote>
# <i>glxgears</i>
<codenote>以默认大小测试你的FPS，你所得到的数字</codenote>
<codenote>应该会比在安装xfree-drm之前有显著提高，我们建议你在CPU足够空闲的情况下做这项测试。</codenote>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>使用CVS源代码</title>
<section>
<body>

<warn>
如果一切都已经正常工作的话，请不要轻易尝试。
</warn>

<note>
CVS源代码程序是一直在更新和变化的，因此也许你的配置不会和下面的讲解完全一样。
</note>

</body>
</section>
<section>
<title>你需要CVS源代码版本吗?</title>
<body>

<p>
首先你得弄明白xfree-drm是否可以正常工作，如果它确实有问题并且不是由于你的配置错误而引起的话
（你可以检查Log文件来进行验证），你也许可以考虑一下CVS源代码版本了。但是如果你不想编译完整的CVS，
你也可以找到许多daily driver snapshots（每日驱动程序更新快照）。
</p>

</body>
</section>
<section>
<title>CVS源代码版本支持你的显示卡吗?</title>
<body>

<p>
浏览一下DRI <uri link="http://dri.sourceforge.net/dri_status.phtml">已经支持的显示卡
列表</uri>，看看CVS版本的程序是否可以支持你的显示卡，即便你没有找到，你也可以尝试一个与
你的显示卡类似型号的CVS程序。
</p>

<warn>
“Linux 2.4内核不支持AGP 8X，所以我不得不去寻找一个backport。现在这个backport可以正常工作了…
但是它修补得并不是那样完美，而且它需要2.4.21的系统内核（使用vanilla成功运行，直接通过tarball
方式编译）。首先从kernel.org上下载2.4.20-2.4.21的补丁，然后下载AGP 8X的补丁――你可以从邮件列表
上的某个地方找到它。在打补丁的过程中会遇到一个有关pci_ids.h文件的小问题，但是如果你打开这个文件并且看一下
reject list，这个问题便可以很容易的解决。现在有关AGP 8X的问题确实得到修复了，我可以使用 xfree-drm
在1600x1200分辨率下进行工作（但是由于缺少DGA，因此速度有点慢）。（来自#gentoo频道上的SanityInAnarchy）
</warn>

<impo>
这个补丁需要一点技巧才能安装成功，你可以在<uri 
link="http://www.ussg.iu.edu/hypermail/linux/kernel/0302.2/att-1618/01-agp3.diff.bz2">这里</uri>
找到下载的地方。如果你可以在BIOS中关掉8X AGP并且打开AGP 4X的话，也许你就可以不必使用这个补丁了。
</impo>

</body>
</section>
<section>
<title>安装CVS源代码版本程序</title>
<body>

<p>
按照本文档完成到“编译并安装你的系统内核”这一节，然后从<uri 
link="http://dri.sourceforge.net/doc/DRIcompile.html">DRI 编译指南</uri>
的第6步做到第8.3步即可。
</p>

</body>
</section>
<section>
<title>匿名CVS下载</title>
<body>

<p>
为你的CVS文件创建一个存放目录：
</p>

<pre caption="为CVS创建一个目录">
# <i>cd ~</i>
# <i>mkdir DRI-CVS</i>
</pre>

<p>
查看CVS源代码程序更新:
</p>

<pre caption="查看CVS源代码程序更新">
# <i>cd ~/DRI-CVS</i>
# <i>cvs -d:pserver:anonymous@cvs.dri.sourceforge.net:/cvsroot/dri login</i>
<codenote>(当提示你输入密码时请按ENTER键)</codenote>
# <i>cvs -z3 -d:pserver:anonymous@cvs.dri.sourceforge.net:/cvsroot/dri co xc</i>
<codenote>-z3参数允许你在下载时启用压缩以节省时间</codenote>
</pre>

</body>
</section>
<section>
<title>更新你的CVS源代码</title>
<body>

<p>
也许以后你想要更新你的DRI源代码本地副本以获得最新的CVS版本，这时你可以使用以下的步骤：
</p>

<pre caption="更新本地副本">
# <i>cd ~/DRI-CVS</i>
# <i>cvs -z3 update -dA xc</i>
<codenote>-d参数允许自动创建子目录。</codenote>
<codenote>-A参数允许你下载最近的主干源代码文件而不是分支源代码文件。</codenote>
</pre>

</body>
</section>
<section>
<title>创建编译树</title>
<body>

<p>
所有的目标文件和库文件都应放在平行<e>编译</e>树而不是源代码树下面。你可以使用<c>lndir</c>
命令来创建编译树：
</p>

<pre caption="创建平行编译树">
# <i>cd ~/DRI-CVS</i>
# <i>ln -s xc XFree40</i>
# <i>mkdir build; cd build</i>
# <i>lndir -silent -ignorelinks ../XFree40</i>
</pre>

<p>
编译树由指向CVS源代码树的符号连接构成。我们建议有经验的用户创建多个编译树以方便你使用不同的选项
进行编译和测试。
</p>

</body>
</section>
<section>
<title>编辑 host.def 文件</title>
<body>

<p>
<path>~/DRI-CVS/build/xc/config/cf/host.def</path>文件用于配置XFree86的编译过程。
你可以通过对这个文件的修改来定义你的编译选项或者为你自己的系统进行某些特定的调整。
默认的host.def看起来应该像这个样子：
</p>

<pre caption="host.def">
#define DefaultCCOptions -Wall
<codenote>适用于 i386 构架:</codenote>
#define DefaultGcc2i386Opt -O2
<codenote>适用于 Alpha 构架:</codenote>
#define DefaultGcc2AxpOpt -O2 -mcpu=ev6 (or similar)
<codenote>适用于所有计算机构架</codenote>
#define LibraryCDebugFlags -O2
#define BuildServersOnly YES
#define XF86CardDrivers vga tdfx mga ati i810
#define LinuxDistribution LinuxRedHat
#define DefaultCCOptions -ansi GccWarningOptions -pipe
#define BuildXF86DRI YES
/* Optionally turn these on for debugging */
/* #define GlxBuiltInTdfx YES */
/* #define GlxBuiltInMga YES */
/* #define GlxBuiltInR128 YES */
/* #define GlxBuiltInRadeon YES */
/* #define DoLoadableServer NO */
#define SharedLibFont NO
</pre>

<pre caption="host.def的后续内容">
<codenote>请注意，你的显示卡驱动程序名称应该加入到XF86CardDrivers这一行</codenote>
<codenote>如果你想在Mesa和DRI驱动程序中使用3DNow!优化指令，请加入以下的代码：</codenote>
#define MesaUse3DNow YES
<codenote>如果你没有AMD处理器，你同样可以使用这个选项。</codenote>
<codenote>DRI将在运行时自动检查你的处理器是否支持3DNow!，如果支持的话，DRI将自动启用它。</codenote>
</pre>

<p>
如果你想在Mesa和DRI驱动程序中使用SSE优化指令，你必须将你的系统内核升级到2.4.X版本。
Mesa将在运行过程中检查你的处理器和操作系统是否都支持SSE指令。另外，如果你要将Mesa编译进DRI，
你需要保证<path>/usr/src/linux</path>下面已经包含了Linux 2.4.x 的内核头文件。
如果你的<path>/usr/src/linux</path>下面是较早的Linux内核文件而且你又开启了SSE优化指令支持，
Mesa将给你发出一个警告并且停止编译。如果你确实已经安装了2.4.x内核，请在host.def中加入以下的内容：
</p>

<pre caption="更新 host.def">
#define MesaUseKatmai YES
</pre>

</body>
</section>
<section>
<title>编译XFree86/DRI树</title>
<body>

<p>
用以下命令来编译完整的DRI树：
</p>

<pre caption="编译 DRI 树">
# <i>cd ~/DRI-CVS/build/xc/</i>
# <i>make World &gt;&amp; world.log</i>
</pre>

<p>
根据host.def的所在位置，你也许还要做以下的步骤：
</p>

<pre caption="额外的编译步骤">
# <i>cd ~/DRI-CVS/build/xc/programs/Xserver/hw/xfree86/os-support/linux/drm/kernel</i>
# <i>make -f Makefile.linux radeon.o</i>
<codenote>请将 radeon 更改为你所使用的驱动程序名称。</codenote>
</pre>

<p>
使用默认的编译参数你会在编译过程中得到许多警告信息，这是正常的。编译需要花费一点时间，
也许你可以在这个过程中去收收电子邮件，浏览一下网站什么的。
</p>

<warn>
make的时候不要使用 -j参数（也就是不要使用distcc）。据说这个参数无法在XFree86/DRI下正常工作。
</warn>

<p>
用你喜欢的文本编辑器检查world.log中的出错信息，你可以使用***通配符进行相关信息的搜索。
</p>

</body>
</section>
<section>
<title>安装CVS</title>
<body>

<p>
确认对应你的操作系统的DRI内核模块已经编译过了：
</p>

<pre caption="确认">
# <i>cd ~/DRI-CVS/build/xc/programs/Xserver/hw/xfree86/os-support/linux/drm/kernel; ls</i>
</pre>

<p>
如果你使用的是3dfx Voodoo显示卡，你看到的应该是<path>tdfx.o</path>，如果你使用的是
Matrox G200/G400显示卡，你看到的应该是<path>mga.o</path>，如果你使用的是ATI Rage 128显示卡，
你看到的应该是<path>r128.o</path>，如果你使用的是ATI Radeon显示卡，你看到的应该是<path>r128.o</path>，
如果你使用的是Intel i810，你看到的应该是<path>i810.o</path>。如果DRI内核模块编译失败，
你需要检查一下你的Linux内核版本是否正确，因为并不是内核越新就越会被支持。
</p>

<p>
安装程序会对已有的 XFree86进行覆盖，因此也许你想要备份你的xfree 。
</p>

<pre caption="备份 XFree">
# <i>quickpkg xfree</i>
<codenote>这将备份你的XFree86组件.</codenote>
# <i>make install</i>
</pre>

<p>
请参看之前的“配置 XF86Config”小节以继续。
</p>

<p>
要将正确的DRM模块载入到运行的系统内核中，请将内核模块复制到
<path>/lib/modules/`uname -r`/kernel/drivers/char/drm/</path>，
运行<c>modules-update</c>命令，然后重新启动X服务器。如果DRI即将运行的所在内核
并不是你现在正在运行的内核，请将<c>`uname -r`,</c>替换为该内核的名称。
</p>

<warn>
在这之前，请确保所有可能已经加载的老版本DRI模块已经被卸载。注意，某些DRM模块需要你事先加载
agpgart模块才能正常运行。
</warn>

</body>
</section>
</chapter>

<chapter>
<title>优化性能</title>
<section>
<title>发挥直接渲染的最大性能</title>
<body>

<p>
有一些XF86Config选项可以提高30%（或更高）的性能。你可以在<path>/etc/X11/XF86Config</path>中进行设置。
</p>

<pre caption="XF86Config">
Section "Device"
  Option     "AGPMode" "4"
  <codenote>这个选项可以将FPS从609提高到618.</codenote>
  Option     "AGPFastWrite" "True"
  <codenote>这个选项没有明显的效果，而且它可能会使你的计算机变得不稳定。</codenote>
  <codenote>你也可以在BIOS中设置这个选项。</codenote>
  Option     "EnablePageFlip" "True"
  <codenote>这个选项可以将FPS从618提高到702，它同样具有一定的风险性，但是几乎没有人在使用过程中碰到问题。</codenote>
  ...
EndSection
</pre>

<p>
如果你想了解更多的特性，请参看DRI网站上的<uri 
link="http://dri.sourceforge.net/doc/dri_driver_features.phtml">特性列表
</uri> 
</p>

</body>
</section>
</chapter>

<chapter>
<title>疑难解答</title>
<section>
<title>重新编译了内核或者升级了内核之后，程序无法工作。</title>
<body>

<p>
每当你重新编译了内核或者升级了内核之后，你需要重新编译内核模块。注意，你不必再次
emerge xfree，但是你得重新emerge xfree-drm 。
</p>

</body>
</section>

<section>
<title>我不知道为什么无法得到贴图渲染。</title>
<body>

<p>
在你启动X服务器之前先尝试一下<c>insmod radeon</c>，或者不要将agpgart编译为模块，将它
编译进内核试一试。
</p>

</body>
</section>
<section>
<title>运行startx时得到如下错误: "[drm] failed to load kernel module agpgart"</title>
<body>

<p>
这是因为你将agpgart编译进了内核而不是编译为了模块。除非你在使用过程中确实遇到问题，否则请忽略它。
</p>

</body>
</section>
<section>
<title>直接渲染没有工作, /var/log/XFree86.0.log 提示我驱动程序版本太低。</title>
<body>

<p>
你没有使用xfree-drm驱动程序。DRM不能编译进系统内核，检查一下你是这样做过。
</p>

</body>
</section>
<section>
<title>如何使用我的Radeon显示卡上的TV-Out功能？</title>
<body>

<p>
尝试一下ati-gatos驱动程序，这项工作可以使用<c>emerge -s gatos</c>命令完成。
</p>

</body>
</section>
<section>
<title>我的显示卡是最新型号的，可是它没有被支持，因此程序无法工作。</title>
<body>

<p>
尝试一下二进制编码驱动程序（binary driver）。对于ati用户，你可以在
<uri>http://www.schneider-digital.de/html/download_ati.html</uri>
找到驱动程序列表。如果这些程序还不能使你的显示卡工作的话，请使用fbdev。
虽然它很慢，但至少能用。
</p>

</body>
</section>
<section>
<title>我有一块PCI显示卡但是却无法工作，帮帮我！</title>
<body>

<p>
在"Device"段落中添加 ForcePCIMode 选项. 
</p>

<pre caption="打开ForcePCIMode">
Option "ForcePCIMode" "True"
</pre>

</body>
</section>
</chapter>

<chapter>
<title>感谢</title>
<section>
<body>

<ol>
  <li>
    Christopher Webber为如何解决在升级或重新编译内核后出现的相关问题提供了建议。
  </li>
  <li>
    Steve,为XF86Config中DRI和dri的大小写问题提供了建议。
  </li>
</ol>

</body>
</section>
</chapter>

<chapter>
<title>参考资源</title>
<section>
<body>

<ol>
  <li>http://forums.gentoo.org/viewtopic.php?t=46681</li>
  <li>http://forums.gentoo.org/viewtopic.php?t=29264</li>
  <li>http://dri.sourceforge.net/</li>
  <li>http://www.retinalburn.net/linux/dri_status.html</li>
</ol>

</body>
</section>
</chapter>
</guide>
